(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_core-js_modules_es_function_bind_js-node_modules_live-form-validation-es-11302a"],{

/***/ "./node_modules/core-js/internals/a-callable.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-callable.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-non-enumerable-property.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/engine-user-agent.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "./node_modules/core-js/internals/engine-v8-version.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] < 4 ? 1 : match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aCallable(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-name.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-name.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = has(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-method.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/get-method.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");

var hasOwnProperty = {}.hasOwnProperty;

module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inspect-source.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/inspect-source.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

var functionToString = Function.toString;

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-callable.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/is-callable.js ***!
  \*******************************************************/
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-symbol.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-symbol.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && Object(it) instanceof $Symbol;
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/ordinary-to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var CONFIGURABLE_FUNCTION_NAME = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!has(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = function (key, value) {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-store.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/shared-store.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.18.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = exoticToPrim.call(input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-property-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/to-property-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : String(key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/try-to-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/try-to-string.js ***!
  \*********************************************************/
/***/ ((module) => {

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/use-symbol-as-uid.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.bind.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.bind.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");

// `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind
$({ target: 'Function', proto: true }, {
  bind: bind
});


/***/ }),

/***/ "./node_modules/live-form-validation-es6/live-form-validation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/live-form-validation-es6/live-form-validation.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Live Form Validation for Nette Forms 2.4
 *
 * @author Robert Pösel, zakrava, Radek Ježdík, MartyIX, David Grudl
 * @version 1.9.0-dev
 * @url https://github.com/Robyer/nette-live-form-validation/
 */

(function (global, factoryLiveValidation, factoryNetteForm) {

  if (true) {
	// AMD
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return {
        LiveForm: factoryLiveValidation(global),
        Nette: factoryNetteForm(global)
      }
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else { var init; }
  
  
}(typeof window !== 'undefined' ? window : this, function (window) {
  'use strict'
  

  var LiveForm = {
    options: {
		// CSS class of control's parent where error/valid class should be added; or "false" to use control directly
		showMessageClassOnParent: 'form-group',

		// CSS class of control's parent where error/valid message should be added (fallback to direct parent if not found); or "false" to use control's direct parent
		messageParentClass: false,

		// CSS class for an invalid control
		controlErrorClass: 'has-error',

		// CSS class for a valid control
		controlValidClass: 'has-success',

		// CSS class for an error message
		messageErrorClass: 'help-block text-danger',

		// control with this CSS class will show error/valid message even when control itself is hidden (useful for controls which are hidden and wrapped into special component)
		enableHiddenMessageClass: 'show-hidden-error',

		// control with this CSS class will have disabled live validation
		disableLiveValidationClass: 'no-live-validation',

		// control with this CSS class will not show valid message
		disableShowValidClass: 'no-show-valid',

		// tag that will hold the error/valid message
		messageTag: 'span',

		// message element id = control id + this postfix
		messageIdPostfix: '_message',

		// show this html before error message itself
		messageErrorPrefix: '&nbsp;<i class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></i>&nbsp;',

		// show all errors when submitting form; or use "false" to show only first error
		showAllErrors: true,

		// show message when valid
		showValid: false,

		// delay in ms before validating on keyup/keydown; or use "false" to disable it
		wait: false,

		// vertical screen offset in px to scroll after focusing element with error (useful when using fixed navbar menu which may otherwise obscure the element in focus); or use "false" for default behavior
		focusScreenOffsetY: false
	},

	forms: { }
};

LiveForm.setOptions = function(userOptions) {
	for (var prop in userOptions) {
		if (Object.prototype.hasOwnProperty.call(this.options, prop)) {
			this.options[prop] = userOptions[prop];
		}
	}
}

// Allow setting options before loading the script just by creating global LiveFormOptions object with options.
if (typeof window.LiveFormOptions !== 'undefined') {
	LiveForm.setOptions(window.LiveFormOptions);
}

LiveForm.isSpecialKey = function(k) {
	// http://stackoverflow.com/questions/7770561/jquery-javascript-reject-control-keys-on-keydown-event
	return (k == 20 /* Caps lock */
		|| k == 16 /* Shift */
		|| k == 9 /* Tab */
		|| k == 27 /* Escape Key */
		|| k == 17 /* Control Key */
		|| k == 91 /* Windows Command Key */
		|| k == 19 /* Pause Break */
		|| k == 18 /* Alt Key */
		|| k == 93 /* Right Click Point Key */
		|| (k >= 35 && k <= 40) /* Home, End, Arrow Keys */
		|| k == 45 /* Insert Key */
		|| (k >= 33 && k <= 34) /*Page Down, Page Up */
		|| (k >= 112 && k <= 123) /* F1 - F12 */
		|| (k >= 144 && k <= 145)); /* Num Lock, Scroll Lock */
}

/**
 * Handlers for all the events that trigger validation
 * YOU CAN CHANGE these handlers (ie. to use jQuery events instead)
 */
LiveForm.setupHandlers = function(el) {
	if (this.hasClass(el, this.options.disableLiveValidationClass))
		return;

	// Check if element was already initialized
	if (el.getAttribute("data-lfv-initialized"))
		return;

	// Remember we initialized this element so we won't do it again
	el.setAttribute('data-lfv-initialized', 'true');

	var handler = function(event) {
		event = event || window.event;
		Nette.validateControl(event.target ? event.target : event.srcElement);
	};

	var self = this;

	Nette.addEvent(el, "change", handler);
	Nette.addEvent(el, "blur", handler);
	Nette.addEvent(el, "keydown", function (event) {
		if (!self.isSpecialKey(event.which) && (self.options.wait === false || self.options.wait >= 200)) {
			// Hide validation span tag.
			self.removeClass(self.getGroupElement(this), self.options.controlErrorClass);
			self.removeClass(self.getGroupElement(this), self.options.controlValidClass);

			var messageEl = self.getMessageElement(this);
			messageEl.innerHTML = '';
			messageEl.className = '';

			// Cancel timeout to run validation handler
			if (self.timeout) {
				clearTimeout(self.timeout);
			}
		}
	});
	Nette.addEvent(el, "keyup", function(event) {
		if (self.options.wait !== false) {
			event = event || window.event;
			if (event.keyCode !== 9) {
				if (self.timeout) clearTimeout(self.timeout);
					self.timeout = setTimeout(function() {
					handler(event);
				}, self.options.wait);
			}
		}
	});
};

LiveForm.processServerErrors = function(el) {
	var messageEl = this.getMessageElement(el);
	var parentEl = this.getMessageParent(el); // This is parent element which contain the error elements

	var errors = [];

	// Find existing error elements by class (from server-validation)
	var errorEls = parentEl.getElementsByClassName(this.options.messageErrorClass);
	for (var i = errorEls.length - 1; i > -1; i--) {
		// Don't touch our main message element
		if (errorEls[i] == messageEl)
			continue;

		// Remove only direct children
		var errorParent = errorEls[i].parentNode;
		if (errorParent == parentEl) {
			errors.push(errorEls[i].outerHTML);
			errorParent.removeChild(errorEls[i]);
		}
	}

	// Wrap all server errors into one element
	if (errors.length > 0) {
		messageEl.innerHTML = errors.join("");
	}
};

LiveForm.addError = function(el, message) {
	// Ignore elements with disabled live validation
	if (this.hasClass(el, this.options.disableLiveValidationClass))
		return;

	var groupEl = this.getGroupElement(el);
	this.setFormProperty(el.form, "hasError", true);
	this.addClass(groupEl, this.options.controlErrorClass);

	if (this.options.showValid) {
		this.removeClass(groupEl, this.options.controlValidClass);
	}

	if (!message) {
		message = '&nbsp;';
	} else {
		message = this.options.messageErrorPrefix + message;
	}

	var messageEl = this.getMessageElement(el);
	messageEl.innerHTML = message;
	messageEl.className = this.options.messageErrorClass;
};

LiveForm.removeError = function(el) {
	// We don't want to remove any errors during onLoadValidation
	if (this.getFormProperty(el.form, "onLoadValidation"))
		return;

	var groupEl = this.getGroupElement(el);
	this.removeClass(groupEl, this.options.controlErrorClass);

	var id = el.getAttribute('data-lfv-message-id');
	if (id) {
		var messageEl = this.getMessageElement(el);
		messageEl.innerHTML = '';
		messageEl.className = '';
	}

	if (this.options.showValid) {
		if (this.showValid(el))
			this.addClass(groupEl, this.options.controlValidClass);
		else
			this.removeClass(groupEl, this.options.controlValidClass);
	}
};

LiveForm.showValid = function(el) {
	if (el.type) {
		var type = el.type.toLowerCase();
		if (type == 'checkbox' || type == 'radio') {
			return false;
		}
	}

	var rules = Nette.parseJSON(el.getAttribute('data-nette-rules'));
	if (rules.length == 0) {
		return false;
	}
  
	if (Nette.getEffectiveValue(el) == '') {
		return false;
	}

	if (this.hasClass(el, this.options.disableShowValidClass)) {
		return false;
	}

	return true;
};

LiveForm.getGroupElement = function(el) {
	if (this.options.showMessageClassOnParent === false)
		return el;

	var groupEl = el;

	while (!this.hasClass(groupEl, this.options.showMessageClassOnParent)) {
		groupEl = groupEl.parentNode;

		if (groupEl === null) {
			return el;
		}
	}

	return groupEl;
}

LiveForm.getMessageId = function(el) {
	var tmp = el.id + this.options.messageIdPostfix;
	
	// For elements without ID, or multi elements (with same name), we must generate whole ID ourselves
	if (el.name && (!el.id || !el.form.elements[el.name].tagName)) {
		// Strip possible [] from name
		var name = el.name.match(/\[\]$/) ? el.name.match(/(.*)\[\]$/)[1] : el.name;
		// Generate new ID based on form ID, element name and messageIdPostfix from options
		tmp = (el.form.id ? el.form.id : 'frm') + '-' + name + this.options.messageIdPostfix;
	}
	
	// We want unique ID which doesn't exist yet
	var id = tmp,
	    i = 0;
	while (document.getElementById(id)) {
		id = id + '_' + ++i;
	}

	return id;
}

LiveForm.getMessageElement = function(el) {
	// For multi elements (with same name) work only with first element attributes
	if (el.name && el.name.match(/\[\]$/)) {
		el = el.form.elements[el.name].tagName ? el : el.form.elements[el.name][0];
	}

	var id = el.getAttribute('data-lfv-message-id');
	if (!id) {
		// ID is not specified yet, let's create a new one
		id = this.getMessageId(el);

		// Remember this id for next use
		el.setAttribute('data-lfv-message-id', id);
	}

	var messageEl = document.getElementById(id);
	if (!messageEl) {
		// Message element doesn't exist, lets create a new one
		messageEl = document.createElement(this.options.messageTag);
		messageEl.id = id;
		if (el.style.display == 'none' && !this.hasClass(el, this.options.enableHiddenMessageClass)) {
			messageEl.style.display = 'none';
		}

		var parentEl = this.getMessageParent(el);
		if (parentEl === el.parentNode) {
			parentEl.insertBefore(messageEl, el.nextSibling);
		} else if(parentEl) {
			parentEl.append(messageEl);
		}
	}

	return messageEl;
};

LiveForm.getMessageParent = function(el) {
	var parentEl = el.parentNode;
	var parentFound = false;
	
	if (this.options.messageParentClass !== false) {
		parentFound = true;
		while (!this.hasClass(parentEl, this.options.messageParentClass)) {
			parentEl = parentEl.parentNode;

			if (parentEl === null) {
				// We didn't found wanted parent, so use element's direct parent
				parentEl = el.parentNode;
				parentFound = false;
				break;
			}
		}
	}

	// Don't append error message to radio/checkbox input's label, but along label
	if (el.type) {
		var type = el.type.toLowerCase();
		if ((type == 'checkbox' || type == 'radio') && parentEl.tagName == 'LABEL') {
			parentEl = parentEl.parentNode;
		}
	}

	// For multi elements (with same name) use parent's parent as parent (if wanted one is not found)
	if (!parentFound && el.name && !el.form.elements[el.name].tagName) {
		parentEl = parentEl.parentNode; 
	}

	return parentEl;
}

LiveForm.addClass = function(el, className) {
	if (!el.className) {
		el.className = className;
	} else if (!this.hasClass(el, className)) {
		el.className += ' ' + className;
	}
};

LiveForm.hasClass = function(el, className) {
	if (el.className)
		return el.className.match(new RegExp('(\\s|^)' + className + '(\\s|$)'));
	return false;
};

LiveForm.removeClass = function(el, className) {
	if (this.hasClass(el, className)) {
		var reg = new RegExp('(\\s|^)'+ className + '(\\s|$)');
		var m = el.className.match(reg);
		el.className = el.className.replace(reg, (m[1] == ' ' && m[2] == ' ') ? ' ' : '');
	}
};

LiveForm.getFormProperty = function(form, propertyName) {
	if (form == null || this.forms[form.id] == null)
		return false;

	return this.forms[form.id][propertyName];
};

LiveForm.setFormProperty = function(form, propertyName, value) {
	if (form == null)
		return;

	if (this.forms[form.id] == null)
		this.forms[form.id] = {};

	this.forms[form.id][propertyName] = value;
};

return LiveForm;

////////////////////////////   modified netteForms.js   ///////////////////////////////////

/**
 * NetteForms - simple form validation.
 *
 * This file is part of the Nette Framework (https://nette.org)
 * Copyright (c) 2004 David Grudl (https://davidgrudl.com)
 */

// LiveForm: original netteForms.js code
/*
(function(global, factory) {
	if (!global.JSON) {
		return;
	}

	if (typeof define === 'function' && define.amd) {
		define(function() {
			return factory(global);
		});
	} else if (typeof module === 'object' && typeof module.exports === 'object') {
		module.exports = factory(global);
	} else {
		var init = !global.Nette || !global.Nette.noInit;
		global.Nette = factory(global);
		if (init) {
			global.Nette.initOnLoad();
		}
	}

}(typeof window !== 'undefined' ? window : this, function(window) {
*/

// LiveForm: addition
}, function (window) {
'use strict';

var Nette = {};

// LiveForm: original netteForms.js code
// Nette.formErrors = [];
Nette.version = '2.4';


/**
 * Attaches a handler to an event for the element.
 */
Nette.addEvent = function(element, on, callback) {
	if (element.addEventListener) {
		element.addEventListener(on, callback);
	} else if (on === 'DOMContentLoaded') {
		element.attachEvent('onreadystatechange', function() {
			if (element.readyState === 'complete') {
				callback.call(this);
			}
		});
	} else {
		element.attachEvent('on' + on, getHandler(callback));
	}
};


function getHandler(callback) {
	return function(e) {
		return callback.call(this, e);
	};
}


/**
 * Returns the value of form element.
 */
Nette.getValue = function(elem) {
	var i;
	if (!elem) {
		return null;

	} else if (!elem.tagName) { // RadioNodeList, HTMLCollection, array
		return elem[0] ? Nette.getValue(elem[0]) : null;

	} else if (elem.type === 'radio') {
		var elements = elem.form.elements; // prevents problem with name 'item' or 'namedItem'
		for (i = 0; i < elements.length; i++) {
			if (elements[i].name === elem.name && elements[i].checked) {
				return elements[i].value;
			}
		}
		return null;

	} else if (elem.type === 'file') {
		return elem.files || elem.value;

	} else if (elem.tagName.toLowerCase() === 'select') {
		var index = elem.selectedIndex,
			options = elem.options,
			values = [];

		if (elem.type === 'select-one') {
			return index < 0 ? null : options[index].value;
		}

		for (i = 0; i < options.length; i++) {
			if (options[i].selected) {
				values.push(options[i].value);
			}
		}
		return values;

	} else if (elem.name && elem.name.match(/\[\]$/)) { // multiple elements []
		var elements = elem.form.elements[elem.name].tagName ? [elem] : elem.form.elements[elem.name],
			values = [];

		for (i = 0; i < elements.length; i++) {
			// LiveForm: original netteForms.js code
			/*if (elements[i].type !== 'checkbox' || elements[i].checked) {
				values.push(elements[i].value);
			}*/
			// LiveForm: addition
			var value = elements[i].value;
			if (elements[i].type === 'checkbox' && elements[i].checked) {
				values.push(value);
			} else if (elements[i].type !== 'checkbox' && value !== '') {
				values.push(value);
			}
		}
		return values;

	} else if (elem.type === 'checkbox') {
		return elem.checked;

	} else if (elem.tagName.toLowerCase() === 'textarea') {
		return elem.value.replace("\r", '');

	} else {
		return elem.value.replace("\r", '').replace(/^\s+|\s+$/g, '');
	}
};


/**
 * Returns the effective value of form element.
 */
Nette.getEffectiveValue = function(elem) {
	var val = Nette.getValue(elem);
	if (elem.getAttribute) {
		if (val === elem.getAttribute('data-nette-empty-value')) {
			val = '';
		}
	}
	return val;
};


/**
 * Validates form element against given rules.
 */
Nette.validateControl = function(elem, rules, onlyCheck, value, emptyOptional) {
	// LiveForm: addition
	// Fix for CheckboxList - validation rules are present always only on first input
	if (elem.name && elem.name.match(/\[\]$/) && elem.type.toLowerCase() == 'checkbox') {
		elem = elem.form.elements[elem.name].tagName ? elem : elem.form.elements[elem.name][0];
	}
	
	elem = elem.tagName ? elem : elem[0]; // RadioNodeList
	rules = rules || Nette.parseJSON(elem.getAttribute('data-nette-rules'));
	value = value === undefined ? {value: Nette.getEffectiveValue(elem)} : value;

	for (var id = 0, len = rules.length; id < len; id++) {
		var rule = rules[id],
			op = rule.op.match(/(~)?([^?]+)/),
			curElem = rule.control ? elem.form.elements.namedItem(rule.control) : elem;

		rule.neg = op[1];
		rule.op = op[2];
		rule.condition = !!rule.rules;

		if (!curElem) {
			continue;
		} else if (rule.op === 'optional') {
			emptyOptional = !Nette.validateRule(elem, ':filled', null, value);
			continue;
		} else if (emptyOptional && !rule.condition && rule.op !== ':filled') {
			continue;
		}

		curElem = curElem.tagName ? curElem : curElem[0]; // RadioNodeList
		var curValue = elem === curElem ? value : {value: Nette.getEffectiveValue(curElem)},
			success = Nette.validateRule(curElem, rule.op, rule.arg, curValue);

		if (success === null) {
			continue;
		} else if (rule.neg) {
			success = !success;
		}

		if (rule.condition && success) {
			if (!Nette.validateControl(elem, rule.rules, onlyCheck, value, rule.op === ':blank' ? false : emptyOptional)) {
				return false;
			}
		} else if (!rule.condition && !success) {
			if (Nette.isDisabled(curElem)) {
				continue;
			}
			if (!onlyCheck) {
				var arr = Nette.isArray(rule.arg) ? rule.arg : [rule.arg],
					message = rule.msg.replace(/%(value|\d+)/g, function(foo, m) {
						return Nette.getValue(m === 'value' ? curElem : elem.form.elements.namedItem(arr[m].control));
					});
				Nette.addError(curElem, message);
			}
			return false;
		}
	}

	if (elem.type === 'number' && !elem.validity.valid) {
		if (!onlyCheck) {
			Nette.addError(elem, 'Please enter a valid value.');
		}
		return false;
	}

	// LiveForm: addition
	if (!onlyCheck) {
		LiveForm.removeError(elem);
	}

	return true;
};


/**
 * Validates whole form.
 */
Nette.validateForm = function(sender, onlyCheck) {
	var form = sender.form || sender,
		scope = false;

	// LiveForm: addition
	LiveForm.setFormProperty(form, "hasError", false);

	// LiveForm: original netteForms.js code
	// Nette.formErrors = [];

	if (form['nette-submittedBy'] && form['nette-submittedBy'].getAttribute('formnovalidate') !== null) {
		var scopeArr = Nette.parseJSON(form['nette-submittedBy'].getAttribute('data-nette-validation-scope'));
		if (scopeArr.length) {
			scope = new RegExp('^(' + scopeArr.join('-|') + '-)');
		} else {
			// LiveForm: original netteForms.js code
			// Nette.showFormErrors(form, []);
			return true;
		}
	}

	var radios = {}, i, elem;
	// LiveForm: addition
	var success = true;

	for (i = 0; i < form.elements.length; i++) {
		elem = form.elements[i];

		if (elem.tagName && !(elem.tagName.toLowerCase() in {input: 1, select: 1, textarea: 1, button: 1})) {
			continue;

		} else if (elem.type === 'radio') {
			if (radios[elem.name]) {
				continue;
			}
			radios[elem.name] = true;
		}

		if ((scope && !elem.name.replace(/]\[|\[|]|$/g, '-').match(scope)) || Nette.isDisabled(elem)) {
			continue;
		}

		// LiveForm: addition
		success = Nette.validateControl(elem) && success;
		if (!success && !LiveForm.options.showAllErrors) {
			break;
		}
		// LiveForm: original netteForms.js code
		/*if (!Nette.validateControl(elem, null, onlyCheck) && !Nette.formErrors.length) {
			return false;
		}*/
	}
	// LiveForm: change
	return success;

	// LiveForm: original netteForms.js code
	/*var success = !Nette.formErrors.length;
	Nette.showFormErrors(form, Nette.formErrors);
	return success;*/
};


/**
 * Check if input is disabled.
 */
Nette.isDisabled = function(elem) {
	if (elem.type === 'radio') {
		for (var i = 0, elements = elem.form.elements; i < elements.length; i++) {
			if (elements[i].name === elem.name && !elements[i].disabled) {
				return false;
			}
		}
		return true;
	}
	return elem.disabled;
};

// LiveForm: change
/**
 * Display error message.
 */
Nette.addError = function(elem, message) {
	// LiveForm: addition
	var noLiveValidation = LiveForm.hasClass(elem, LiveForm.options.disableLiveValidationClass);
	// User explicitly disabled live-validation so we want to show simple alerts
	if (noLiveValidation) {
		// notify errors for elements with disabled live validation (but only errors and not during onLoadValidation)
		if (message && !LiveForm.getFormProperty(elem.form, "hasError") && !LiveForm.getFormProperty(elem.form, "onLoadValidation")) {
			alert(message);
		}
	}
	if (elem.focus && !LiveForm.getFormProperty(elem.form, "hasError")) {
		if (!LiveForm.focusing) {
			LiveForm.focusing = true;
			elem.focus();
			setTimeout(function() {
				LiveForm.focusing = false;

				// Scroll by defined offset (if enabled)
				// NOTE: We use it with setTimetout because IE9 doesn't always catch instant scrollTo request
				var focusOffsetY = LiveForm.options.focusScreenOffsetY;
				if (focusOffsetY !== false && elem.getBoundingClientRect().top < focusOffsetY) {
					window.scrollBy(0, elem.getBoundingClientRect().top - focusOffsetY);
				}
			}, 10);
		}
	}
	if (!noLiveValidation) {
		LiveForm.addError(elem, message);
	}
};


// LiveForm: original netteForms.js code
/**
 * Adds error message to the queue.
 */
/*Nette.addError = function(elem, message) {
	Nette.formErrors.push({
		element: elem,
		message: message
	});
};*/


// LiveForm: original netteForms.js code
/**
 * Display error messages.
 */
/*Nette.showFormErrors = function(form, errors) {
	var messages = [],
		focusElem;

	for (var i = 0; i < errors.length; i++) {
		var elem = errors[i].element,
			message = errors[i].message;

		if (!Nette.inArray(messages, message)) {
			messages.push(message);

			if (!focusElem && elem.focus) {
				focusElem = elem;
			}
		}
	}

	if (messages.length) {
		alert(messages.join('\n'));

		if (focusElem) {
			focusElem.focus();
		}
	}
};*/


/**
 * Expand rule argument.
 */
Nette.expandRuleArgument = function(form, arg) {
	if (arg && arg.control) {
		var control = form.elements.namedItem(arg.control),
			value = {value: Nette.getEffectiveValue(control)};
		Nette.validateControl(control, null, true, value);
		arg = value.value;
	}
	return arg;
};


/**
 * Validates single rule.
 */
Nette.validateRule = function(elem, op, arg, value) {
	value = value === undefined ? {value: Nette.getEffectiveValue(elem)} : value;

	if (op.charAt(0) === ':') {
		op = op.substr(1);
	}
	op = op.replace('::', '_');
	op = op.replace(/\\/g, '');

	var arr = Nette.isArray(arg) ? arg.slice(0) : [arg];
	for (var i = 0, len = arr.length; i < len; i++) {
		arr[i] = Nette.expandRuleArgument(elem.form, arr[i]);
	}
	return Nette.validators[op]
		? Nette.validators[op](elem, Nette.isArray(arg) ? arr : arr[0], value.value, value)
		: null;
};


Nette.validators = {
	filled: function(elem, arg, val) {
		if (elem.type === 'number' && elem.validity.badInput) {
			return true;
		}
		return val !== '' && val !== false && val !== null
			&& (!Nette.isArray(val) || !!val.length)
			&& (!window.FileList || !(val instanceof window.FileList) || val.length);
	},

	blank: function(elem, arg, val) {
		return !Nette.validators.filled(elem, arg, val);
	},

	valid: function(elem, arg, val) {
		return Nette.validateControl(elem, null, true);
	},

	equal: function(elem, arg, val) {
		if (arg === undefined) {
			return null;
		}

		function toString(val) {
			if (typeof val === 'number' || typeof val === 'string') {
				return '' + val;
			} else {
				return val === true ? '1' : '';
			}
		}

		val = Nette.isArray(val) ? val : [val];
		arg = Nette.isArray(arg) ? arg : [arg];
		loop:
		for (var i1 = 0, len1 = val.length; i1 < len1; i1++) {
			for (var i2 = 0, len2 = arg.length; i2 < len2; i2++) {
				if (toString(val[i1]) === toString(arg[i2])) {
					continue loop;
				}
			}
			return false;
		}
		return true;
	},

	notEqual: function(elem, arg, val) {
		return arg === undefined ? null : !Nette.validators.equal(elem, arg, val);
	},

	minLength: function(elem, arg, val) {
		if (elem.type === 'number') {
			if (elem.validity.tooShort) {
				return false
			} else if (elem.validity.badInput) {
				return null;
			}
		}
		return val.length >= arg;
	},

	maxLength: function(elem, arg, val) {
		if (elem.type === 'number') {
			if (elem.validity.tooLong) {
				return false
			} else if (elem.validity.badInput) {
				return null;
			}
		}
		return val.length <= arg;
	},

	length: function(elem, arg, val) {
		if (elem.type === 'number') {
			if (elem.validity.tooShort || elem.validity.tooLong) {
				return false
			} else if (elem.validity.badInput) {
				return null;
			}
		}
		arg = Nette.isArray(arg) ? arg : [arg, arg];
		return (arg[0] === null || val.length >= arg[0]) && (arg[1] === null || val.length <= arg[1]);
	},

	email: function(elem, arg, val) {
		return (/^("([ !#-[\]-~]|\\[ -~])+"|[-a-z0-9!#$%&'*+\/=?^_`{|}~]+(\.[-a-z0-9!#$%&'*+\/=?^_`{|}~]+)*)@([0-9a-z\u00C0-\u02FF\u0370-\u1EFF]([-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,61}[0-9a-z\u00C0-\u02FF\u0370-\u1EFF])?\.)+[a-z\u00C0-\u02FF\u0370-\u1EFF]([-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,17}[a-z\u00C0-\u02FF\u0370-\u1EFF])?$/i).test(val);
	},

	url: function(elem, arg, val, value) {
		if (!(/^[a-z\d+.-]+:/).test(val)) {
			val = 'http://' + val;
		}
		if ((/^https?:\/\/((([-_0-9a-z\u00C0-\u02FF\u0370-\u1EFF]+\.)*[0-9a-z\u00C0-\u02FF\u0370-\u1EFF]([-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,61}[0-9a-z\u00C0-\u02FF\u0370-\u1EFF])?\.)?[a-z\u00C0-\u02FF\u0370-\u1EFF]([-0-9a-z\u00C0-\u02FF\u0370-\u1EFF]{0,17}[a-z\u00C0-\u02FF\u0370-\u1EFF])?|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|\[[0-9a-f:]{3,39}\])(:\d{1,5})?(\/\S*)?$/i).test(val)) {
			value.value = val;
			return true;
		}
		return false;
	},

	regexp: function(elem, arg, val) {
		var parts = typeof arg === 'string' ? arg.match(/^\/(.*)\/([imu]*)$/) : false;
		try {
			return parts && (new RegExp(parts[1], parts[2].replace('u', ''))).test(val);
		} catch (e) {}
	},

    pattern: function(elem, arg, val) {
        if (typeof arg !== 'string') {
            return null;
        }

        if (val instanceof FileList) {
            try {
                for (var i = 0; i < val.length; i++) {
                    if ((new RegExp('^(?:' + arg + ')$')).test(val[i].name) === false) {
                        return false;
                    }
                }
                return true;
            } catch (e) {}
        } else {
            try {
                return (new RegExp('^(?:' + arg + ')$')).test(val);
            } catch (e) {}
        }
    },

	integer: function(elem, arg, val) {
		if (elem.type === 'number' && elem.validity.badInput) {
			return false;
		}
		return (/^-?[0-9]+$/).test(val);
	},

	'float': function(elem, arg, val, value) {
		if (elem.type === 'number' && elem.validity.badInput) {
			return false;
		}
		val = val.replace(' ', '').replace(',', '.');
		if ((/^-?[0-9]*[.,]?[0-9]+$/).test(val)) {
			value.value = val;
			return true;
		}
		return false;
	},

	min: function(elem, arg, val) {
		if (elem.type === 'number') {
			if (elem.validity.rangeUnderflow) {
				return false
			} else if (elem.validity.badInput) {
				return null;
			}
		}
		return Nette.validators.range(elem, [arg, null], val);
	},

	max: function(elem, arg, val) {
		if (elem.type === 'number') {
			if (elem.validity.rangeOverflow) {
				return false
			} else if (elem.validity.badInput) {
				return null;
			}
		}
		return Nette.validators.range(elem, [null, arg], val);
	},

	range: function(elem, arg, val) {
		if (elem.type === 'number') {
			if ((elem.validity.rangeUnderflow && arg[0] !== null) || (elem.validity.rangeOverflow && arg[1] !== null)) {
				return false
			} else if (elem.validity.badInput) {
				return null;
			}
		}
		
		if (elem.type === 'date') {
			arg[0] = (arg[0] === null ? null : new Date(arg[0]).getTime());
			arg[1] = (arg[1] === null ? null : new Date(arg[1]).getTime());
			val = new Date(val).getTime()
		}
		
		return Nette.isArray(arg) ?
			((arg[0] === null || parseFloat(val) >= arg[0]) && (arg[1] === null || parseFloat(val) <= arg[1])) : null;
	},

	submitted: function(elem, arg, val) {
		return elem.form['nette-submittedBy'] === elem;
	},

	fileSize: function(elem, arg, val) {
		if (window.FileList) {
			for (var i = 0; i < val.length; i++) {
				if (val[i].size > arg) {
					return false;
				}
			}
		}
		return true;
	},

	image: function (elem, arg, val) {
		if (window.FileList && val instanceof window.FileList) {
			for (var i = 0; i < val.length; i++) {
				var type = val[i].type;
				if (type && type !== 'image/gif' && type !== 'image/png' && type !== 'image/jpeg') {
					return false;
				}
			}
		}
		return true;
	}
};


/**
 * Process all toggles in form.
 */
Nette.toggleForm = function(form, elem) {
	var i;
	Nette.toggles = {};
	for (i = 0; i < form.elements.length; i++) {
		if (form.elements[i].tagName.toLowerCase() in {input: 1, select: 1, textarea: 1, button: 1}) {
			Nette.toggleControl(form.elements[i], null, null, !elem);
		}
	}

	for (i in Nette.toggles) {
		Nette.toggle(i, Nette.toggles[i], elem);
	}
};


/**
 * Process toggles on form element.
 */
Nette.toggleControl = function(elem, rules, success, firsttime, value) {
	rules = rules || Nette.parseJSON(elem.getAttribute('data-nette-rules'));
	value = value === undefined ? {value: Nette.getEffectiveValue(elem)} : value;

	var has = false,
		handled = [],
		handler = function () {
			Nette.toggleForm(elem.form, elem);
		},
		curSuccess;

	for (var id = 0, len = rules.length; id < len; id++) {
		var rule = rules[id],
			op = rule.op.match(/(~)?([^?]+)/),
			curElem = rule.control ? elem.form.elements.namedItem(rule.control) : elem;

		if (!curElem) {
			continue;
		}

		curSuccess = success;
		if (success !== false) {
			rule.neg = op[1];
			rule.op = op[2];
			var curValue = elem === curElem ? value : {value: Nette.getEffectiveValue(curElem)};
			curSuccess = Nette.validateRule(curElem, rule.op, rule.arg, curValue);
			if (curSuccess === null) {
				continue;

			} else if (rule.neg) {
				curSuccess = !curSuccess;
			}
			if (!rule.rules) {
				success = curSuccess;
			}
		}

		if ((rule.rules && Nette.toggleControl(elem, rule.rules, curSuccess, firsttime, value)) || rule.toggle) {
			has = true;
			if (firsttime) {
				var oldIE = !document.addEventListener, // IE < 9
					name = curElem.tagName ? curElem.name : curElem[0].name,
					els = curElem.tagName ? curElem.form.elements : curElem;

				for (var i = 0; i < els.length; i++) {
					if (els[i].name === name && !Nette.inArray(handled, els[i])) {
						Nette.addEvent(els[i], oldIE && els[i].type in {checkbox: 1, radio: 1} ? 'click' : 'change', handler);
						handled.push(els[i]);
					}
				}
			}
			for (var id2 in rule.toggle || []) {
				if (Object.prototype.hasOwnProperty.call(rule.toggle, id2)) {
					Nette.toggles[id2] = Nette.toggles[id2] || (rule.toggle[id2] ? curSuccess : !curSuccess);
				}
			}
		}
	}
	return has;
};


Nette.parseJSON = function(s) {
	return (s || '').substr(0, 3) === '{op'
		? eval('[' + s + ']') // backward compatibility with Nette 2.0.x
		: JSON.parse(s || '[]');
};


/**
 * Displays or hides HTML element.
 */
Nette.toggle = function(id, visible, srcElement) {
	var elem = document.getElementById(id);
	if (elem) {
		elem.style.display = visible ? '' : 'none';
	}
};


/**
 * Setup handlers.
 */
Nette.initForm = function(form) {
	if (form.noValidate) {
		return;
	}

	form.noValidate = 'novalidate';

	// LiveForm: addition
	LiveForm.forms[form.id] = {
		hasError: false,
		onLoadValidation: false
	};

	Nette.addEvent(form, 'submit', function(e) {
		if (!Nette.validateForm(form)) {
			if (e && e.stopPropagation) {
				e.stopPropagation();
				e.preventDefault();
			} else if (window.event) {
				event.cancelBubble = true;
				event.returnValue = false;
			}
		}
	});

	Nette.toggleForm(form);

	// LiveForm: addition
	for (var i = 0; i < form.elements.length; i++) {
		LiveForm.setupHandlers(form.elements[i]);
		LiveForm.processServerErrors(form.elements[i]);
	}
};


/**
 * @private
 */
Nette.initOnLoad = function() {
	Nette.addEvent(document, 'DOMContentLoaded', function() {
// LiveForm: original netteForms.js code 
/*  
		for (var i = 0; i < document.forms.length; i++) {
			var form = document.forms[i];
			for (var j = 0; j < form.elements.length; j++) {
				if (form.elements[j].getAttribute('data-nette-rules')) {
					Nette.initForm(form);
					break;
				}
			}
		}

		Nette.addEvent(document.body, 'click', function(e) {
			var target = e.target || e.srcElement;
			if (target.form && target.type in {submit: 1, image: 1}) {
				target.form['nette-submittedBy'] = target;
			}
		});
*/
    // LiveForm: addition
    Nette.init();
	});
};

// LiveForm: addition
/**
 * Init function to be called in case usage as module
 * 
 * @public 
 */
Nette.init = function() {
  for (var i = 0; i < document.forms.length; i++) {
		var form = document.forms[i];
		for (var j = 0; j < form.elements.length; j++) {
			if (form.elements[j].getAttribute('data-nette-rules')) {
					Nette.initForm(form);

				if (LiveForm.hasClass(form, 'validate-on-load')) {
					// This is not so nice way, but I don't want to spoil validateForm, validateControl and other methods with another parameter
					LiveForm.setFormProperty(form, "onLoadValidation", true);
					Nette.validateForm(form);
					LiveForm.setFormProperty(form, "onLoadValidation", false);
				}

				break;
			}
		}
	}

	Nette.addEvent(document.body, 'click', function(e) {
		var target = e.target || e.srcElement;
		if (target.form && target.type in {submit: 1, image: 1}) {
			target.form['nette-submittedBy'] = target;
		}
	});
};


/**
 * Determines whether the argument is an array.
 */
Nette.isArray = function(arg) {
	return Object.prototype.toString.call(arg) === '[object Array]';
};


/**
 * Search for a specified value within an array.
 */
Nette.inArray = function(arr, val) {
	if ([].indexOf) {
		return arr.indexOf(val) > -1;
	} else {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] === val) {
				return true;
			}
		}
		return false;
	}
};


/**
 * Converts string to web safe characters [a-z0-9-] text.
 */
Nette.webalize = function(s) {
	s = s.toLowerCase();
	var res = '', i, ch;
	for (i = 0; i < s.length; i++) {
		ch = Nette.webalizeTable[s.charAt(i)];
		res += ch ? ch : s.charAt(i);
	}
	return res.replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
};

Nette.webalizeTable = {\u00e1: 'a', \u00e4: 'a', \u010d: 'c', \u010f: 'd', \u00e9: 'e', \u011b: 'e', \u00ed: 'i', \u013e: 'l', \u0148: 'n', \u00f3: 'o', \u00f4: 'o', \u0159: 'r', \u0161: 's', \u0165: 't', \u00fa: 'u', \u016f: 'u', \u00fd: 'y', \u017e: 'z'};

return Nette;
}));


/***/ }),

/***/ "./node_modules/naja/dist/Naja.esm.js":
/*!********************************************!*\
  !*** ./node_modules/naja/dist/Naja.esm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "HttpError": () => (/* binding */ HttpError),
/* harmony export */   "Naja": () => (/* binding */ Naja)
/* harmony export */ });
/* harmony import */ var event_target_shim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! event-target-shim */ "./node_modules/event-target-shim/index.mjs");
/*
 * Naja.js
 * 2.1.5
 *
 * by Jiří Pudil <https://jiripudil.cz>
 */


var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

(function (factory) {
  factory();
}((function () {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  var Emitter = /*#__PURE__*/function () {
    function Emitter() {
      _classCallCheck(this, Emitter);

      Object.defineProperty(this, 'listeners', {
        value: {},
        writable: true,
        configurable: true
      });
    }

    _createClass(Emitter, [{
      key: "addEventListener",
      value: function addEventListener(type, callback, options) {
        if (!(type in this.listeners)) {
          this.listeners[type] = [];
        }

        this.listeners[type].push({
          callback: callback,
          options: options
        });
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        if (!(type in this.listeners)) {
          return;
        }

        var stack = this.listeners[type];

        for (var i = 0, l = stack.length; i < l; i++) {
          if (stack[i].callback === callback) {
            stack.splice(i, 1);
            return;
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (!(event.type in this.listeners)) {
          return;
        }

        var stack = this.listeners[event.type];
        var stackToCall = stack.slice();

        for (var i = 0, l = stackToCall.length; i < l; i++) {
          var listener = stackToCall[i];

          try {
            listener.callback.call(this, event);
          } catch (e) {
            Promise.resolve().then(function () {
              throw e;
            });
          }

          if (listener.options && listener.options.once) {
            this.removeEventListener(event.type, listener.callback);
          }
        }

        return !event.defaultPrevented;
      }
    }]);

    return Emitter;
  }();

  var AbortSignal = /*#__PURE__*/function (_Emitter) {
    _inherits(AbortSignal, _Emitter);

    var _super = _createSuper(AbortSignal);

    function AbortSignal() {
      var _this;

      _classCallCheck(this, AbortSignal);

      _this = _super.call(this); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent
      // constructor has failed to run, then "this.listeners" will still be undefined and then we call
      // the parent constructor directly instead as a workaround. For general details, see babel bug:
      // https://github.com/babel/babel/issues/3041
      // This hack was added as a fix for the issue described here:
      // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042

      if (!_this.listeners) {
        Emitter.call(_assertThisInitialized(_this));
      } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
      // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl


      Object.defineProperty(_assertThisInitialized(_this), 'aborted', {
        value: false,
        writable: true,
        configurable: true
      });
      Object.defineProperty(_assertThisInitialized(_this), 'onabort', {
        value: null,
        writable: true,
        configurable: true
      });
      return _this;
    }

    _createClass(AbortSignal, [{
      key: "toString",
      value: function toString() {
        return '[object AbortSignal]';
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (event.type === 'abort') {
          this.aborted = true;

          if (typeof this.onabort === 'function') {
            this.onabort.call(this, event);
          }
        }

        _get(_getPrototypeOf(AbortSignal.prototype), "dispatchEvent", this).call(this, event);
      }
    }]);

    return AbortSignal;
  }(Emitter);
  var AbortController = /*#__PURE__*/function () {
    function AbortController() {
      _classCallCheck(this, AbortController);

      // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and
      // we want Object.keys(new AbortController()) to be [] for compat with the native impl
      Object.defineProperty(this, 'signal', {
        value: new AbortSignal(),
        writable: true,
        configurable: true
      });
    }

    _createClass(AbortController, [{
      key: "abort",
      value: function abort() {
        var event;

        try {
          event = new Event('abort');
        } catch (e) {
          if (typeof document !== 'undefined') {
            if (!document.createEvent) {
              // For Internet Explorer 8:
              event = document.createEventObject();
              event.type = 'abort';
            } else {
              // For Internet Explorer 11:
              event = document.createEvent('Event');
              event.initEvent('abort', false, false);
            }
          } else {
            // Fallback where document isn't available:
            event = {
              type: 'abort',
              bubbles: false,
              cancelable: false
            };
          }
        }

        this.signal.dispatchEvent(event);
      }
    }, {
      key: "toString",
      value: function toString() {
        return '[object AbortController]';
      }
    }]);

    return AbortController;
  }();

  if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    // These are necessary to make sure that we get correct output for:
    // Object.prototype.toString.call(new AbortController())
    AbortController.prototype[Symbol.toStringTag] = 'AbortController';
    AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';
  }

  function polyfillNeeded(self) {
    if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');
      return true;
    } // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // so the below feature detection needs the !self.AbortController part.
    // The Request.prototype check is also needed because Safari versions 11.1.2
    // up to and including 12.1.x has a window.AbortController present but still
    // does NOT correctly implement abortable fetch:
    // https://bugs.webkit.org/show_bug.cgi?id=174980#c2


    return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;
  }

  /**
   * Note: the "fetch.Request" default value is available for fetch imported from
   * the "node-fetch" package and not in browsers. This is OK since browsers
   * will be importing umd-polyfill.js from that path "self" is passed the
   * decorator so the default value will not be used (because browsers that define
   * fetch also has Request). One quirky setup where self.fetch exists but
   * self.Request does not is when the "unfetch" minimal fetch polyfill is used
   * on top of IE11; for this case the browser will try to use the fetch.Request
   * default value which in turn will be undefined but then then "if (Request)"
   * will ensure that you get a patched fetch but still no Request (as expected).
   * @param {fetch, Request = fetch.Request}
   * @returns {fetch: abortableFetch, Request: AbortableRequest}
   */

  function abortableFetchDecorator(patchTargets) {
    if ('function' === typeof patchTargets) {
      patchTargets = {
        fetch: patchTargets
      };
    }

    var _patchTargets = patchTargets,
        fetch = _patchTargets.fetch,
        _patchTargets$Request = _patchTargets.Request,
        NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,
        NativeAbortController = _patchTargets.AbortController,
        _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,
        __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;

    if (!polyfillNeeded({
      fetch: fetch,
      Request: NativeRequest,
      AbortController: NativeAbortController,
      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL
    })) {
      return {
        fetch: fetch,
        Request: Request
      };
    }

    var Request = NativeRequest; // Note that the "unfetch" minimal fetch polyfill defines fetch() without
    // defining window.Request, and this polyfill need to work on top of unfetch
    // hence we only patch it if it's available. Also we don't patch it if signal
    // is already available on the Request prototype because in this case support
    // is present and the patching below can cause a crash since it assigns to
    // request.signal which is technically a read-only property. This latter error
    // happens when you run the main5.js node-fetch example in the repo
    // "abortcontroller-polyfill-examples". The exact error is:
    //   request.signal = init.signal;
    //   ^
    // TypeError: Cannot set property signal of #<Request> which has only a getter

    if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
      Request = function Request(input, init) {
        var signal;

        if (init && init.signal) {
          signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.

          delete init.signal;
        }

        var request = new NativeRequest(input, init);

        if (signal) {
          Object.defineProperty(request, 'signal', {
            writable: false,
            enumerable: false,
            configurable: true,
            value: signal
          });
        }

        return request;
      };

      Request.prototype = NativeRequest.prototype;
    }

    var realFetch = fetch;

    var abortableFetch = function abortableFetch(input, init) {
      var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;

      if (signal) {
        var abortError;

        try {
          abortError = new DOMException('Aborted', 'AbortError');
        } catch (err) {
          // IE 11 does not support calling the DOMException constructor, use a
          // regular error object on it instead.
          abortError = new Error('Aborted');
          abortError.name = 'AbortError';
        } // Return early if already aborted, thus avoiding making an HTTP request


        if (signal.aborted) {
          return Promise.reject(abortError);
        } // Turn an event into a promise, reject it once `abort` is dispatched


        var cancellation = new Promise(function (_, reject) {
          signal.addEventListener('abort', function () {
            return reject(abortError);
          }, {
            once: true
          });
        });

        if (init && init.signal) {
          // Never pass .signal to the native implementation when the polyfill has
          // been installed because if we're running on top of a browser with a
          // working native AbortController (i.e. the polyfill was installed due to
          // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our
          // fake AbortSignal to the native fetch will trigger:
          // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.
          delete init.signal;
        } // Return the fastest promise (don't need to wait for request to finish)


        return Promise.race([cancellation, realFetch(input, init)]);
      }

      return realFetch(input, init);
    };

    return {
      fetch: abortableFetch,
      Request: Request
    };
  }

  (function (self) {

    if (!polyfillNeeded(self)) {
      return;
    }

    if (!self.fetch) {
      console.warn('fetch() is not available, cannot install abortcontroller-polyfill');
      return;
    }

    var _abortableFetch = abortableFetchDecorator(self),
        fetch = _abortableFetch.fetch,
        Request = _abortableFetch.Request;

    self.fetch = fetch;
    self.Request = Request;
    Object.defineProperty(self, 'AbortController', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortController
    });
    Object.defineProperty(self, 'AbortSignal', {
      writable: true,
      enumerable: false,
      configurable: true,
      value: AbortSignal
    });
  })(typeof self !== 'undefined' ? self : commonjsGlobal);

})));

// https://bugs.webkit.org/show_bug.cgi?id=174980

try {
  new window.EventTarget();
} catch (error) {
  window.EventTarget = event_target_shim__WEBPACK_IMPORTED_MODULE_0__.EventTarget;
}

class AssertionError extends Error {
}
const assert = (condition, description) => {
    if (!condition) {
        const message = `Assertion failed${description !== undefined ? `: ${description}` : '.'}`;
        throw new AssertionError(message);
    }
};

class UIHandler extends EventTarget {
    constructor(naja) {
        super();
        this.naja = naja;
        this.selector = '.ajax';
        this.allowedOrigins = [window.location.origin];
        this.handler = this.handleUI.bind(this);
        naja.addEventListener('init', this.initialize.bind(this));
    }
    initialize() {
        this.bindUI(window.document.body);
        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {
            const { snippet } = event.detail;
            this.bindUI(snippet);
        });
    }
    bindUI(element) {
        const selectors = [
            `a${this.selector}`,
            `input[type="submit"]${this.selector}`,
            `input[type="image"]${this.selector}`,
            `button[type="submit"]${this.selector}`,
            `form${this.selector} input[type="submit"]`,
            `form${this.selector} input[type="image"]`,
            `form${this.selector} button[type="submit"]`,
        ].join(', ');
        const bindElement = (element) => {
            element.removeEventListener('click', this.handler);
            element.addEventListener('click', this.handler);
        };
        const elements = element.querySelectorAll(selectors);
        for (let i = 0; i < elements.length; i++) {
            bindElement(elements.item(i));
        }
        if (element.matches(selectors)) {
            bindElement(element);
        }
        const bindForm = (form) => {
            form.removeEventListener('submit', this.handler);
            form.addEventListener('submit', this.handler);
        };
        if (element.matches(`form${this.selector}`)) {
            bindForm(element);
        }
        const forms = element.querySelectorAll(`form${this.selector}`);
        for (let i = 0; i < forms.length; i++) {
            bindForm(forms.item(i));
        }
    }
    handleUI(event) {
        const mouseEvent = event;
        if (mouseEvent.altKey || mouseEvent.ctrlKey || mouseEvent.shiftKey || mouseEvent.metaKey || mouseEvent.button) {
            return;
        }
        const element = event.currentTarget;
        const options = {};
        const ignoreErrors = () => {
            // don't reject the promise in case of an error as developers have no way of handling the rejection
            // in this situation; errors should be handled in `naja.addEventListener('error', errorHandler)`
        };
        if (event.type === 'submit') {
            this.submitForm(element, options, event).catch(ignoreErrors);
        }
        else if (event.type === 'click') {
            this.clickElement(element, options, mouseEvent).catch(ignoreErrors);
        }
    }
    async clickElement(element, options = {}, event) {
        var _a, _b, _c, _d, _e, _f;
        let method = 'GET', url = '', data;
        if (!this.dispatchEvent(new CustomEvent('interaction', { cancelable: true, detail: { element, originalEvent: event, options } }))) {
            event === null || event === void 0 ? void 0 : event.preventDefault();
            return {};
        }
        if (element.tagName === 'A') {
            assert(element instanceof HTMLAnchorElement);
            method = 'GET';
            url = element.href;
            data = null;
        }
        else if (element.tagName === 'INPUT' || element.tagName === 'BUTTON') {
            assert(element instanceof HTMLInputElement || element instanceof HTMLButtonElement);
            const { form } = element;
            // eslint-disable-next-line no-nested-ternary,no-extra-parens
            method = (_d = (_b = (_a = element.getAttribute('formmethod')) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : (_c = form === null || form === void 0 ? void 0 : form.getAttribute('method')) === null || _c === void 0 ? void 0 : _c.toUpperCase()) !== null && _d !== void 0 ? _d : 'GET';
            url = (_f = (_e = element.getAttribute('formaction')) !== null && _e !== void 0 ? _e : form === null || form === void 0 ? void 0 : form.getAttribute('action')) !== null && _f !== void 0 ? _f : window.location.pathname + window.location.search;
            data = new FormData(form !== null && form !== void 0 ? form : undefined);
            if (element.type === 'submit' || element.tagName === 'BUTTON') {
                data.append(element.name, element.value || '');
            }
            else if (element.type === 'image') {
                const coords = element.getBoundingClientRect();
                data.append(`${element.name}.x`, Math.max(0, Math.floor(event !== undefined ? event.pageX - coords.left : 0)));
                data.append(`${element.name}.y`, Math.max(0, Math.floor(event !== undefined ? event.pageY - coords.top : 0)));
            }
        }
        if (!this.isUrlAllowed(url)) {
            throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);
        }
        event === null || event === void 0 ? void 0 : event.preventDefault();
        return this.naja.makeRequest(method, url, data, options);
    }
    async submitForm(form, options = {}, event) {
        var _a, _b, _c;
        if (!this.dispatchEvent(new CustomEvent('interaction', { cancelable: true, detail: { element: form, originalEvent: event, options } }))) {
            event === null || event === void 0 ? void 0 : event.preventDefault();
            return {};
        }
        const method = (_b = (_a = form.getAttribute('method')) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== null && _b !== void 0 ? _b : 'GET';
        const url = (_c = form.getAttribute('action')) !== null && _c !== void 0 ? _c : window.location.pathname + window.location.search;
        const data = new FormData(form);
        if (!this.isUrlAllowed(url)) {
            throw new Error(`Cannot dispatch async request, URL is not allowed: ${url}`);
        }
        event === null || event === void 0 ? void 0 : event.preventDefault();
        return this.naja.makeRequest(method, url, data, options);
    }
    isUrlAllowed(url) {
        const urlObject = new URL(url, location.href);
        // ignore non-URL URIs (javascript:, data:, mailto:, ...)
        if (urlObject.origin === 'null') {
            return false;
        }
        return this.allowedOrigins.includes(urlObject.origin);
    }
}

class FormsHandler {
    constructor(naja) {
        this.naja = naja;
        naja.addEventListener('init', this.initialize.bind(this));
        naja.uiHandler.addEventListener('interaction', this.processForm.bind(this));
    }
    initialize() {
        this.initForms(window.document.body);
        this.naja.snippetHandler.addEventListener('afterUpdate', (event) => {
            const { snippet } = event.detail;
            this.initForms(snippet);
        });
    }
    initForms(element) {
        const netteForms = this.netteForms || window.Nette;
        if (netteForms) {
            if (element.tagName === 'form') {
                netteForms.initForm(element);
            }
            const forms = element.querySelectorAll('form');
            for (let i = 0; i < forms.length; i++) {
                netteForms.initForm(forms.item(i));
            }
        }
    }
    processForm(event) {
        const { element, originalEvent } = event.detail;
        const inputElement = element;
        if (inputElement.form !== undefined && inputElement.form !== null) {
            inputElement.form['nette-submittedBy'] = element;
        }
        const netteForms = this.netteForms || window.Nette;
        if ((element.tagName === 'FORM' || element.form) && netteForms && !netteForms.validateForm(element)) {
            if (originalEvent) {
                originalEvent.stopImmediatePropagation();
                originalEvent.preventDefault();
            }
            event.preventDefault();
        }
    }
}

class RedirectHandler extends EventTarget {
    constructor(naja) {
        super();
        this.naja = naja;
        naja.uiHandler.addEventListener('interaction', (event) => {
            var _a, _b, _c;
            const { element, options } = event.detail;
            if (!element) {
                return;
            }
            if (element.hasAttribute('data-naja-force-redirect') || ((_a = element.form) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-naja-force-redirect'))) {
                const value = (_b = element.getAttribute('data-naja-force-redirect')) !== null && _b !== void 0 ? _b : (_c = element.form) === null || _c === void 0 ? void 0 : _c.getAttribute('data-naja-force-redirect');
                options.forceRedirect = value !== 'off';
            }
        });
        naja.addEventListener('success', (event) => {
            var _a;
            const { payload, options } = event.detail;
            if (payload.redirect) {
                this.makeRedirect(payload.redirect, (_a = options.forceRedirect) !== null && _a !== void 0 ? _a : false, options);
                event.stopImmediatePropagation();
            }
        });
        this.locationAdapter = {
            assign: (url) => window.location.assign(url),
        };
    }
    makeRedirect(url, force, options = {}) {
        if (url instanceof URL) {
            url = url.href;
        }
        let isHardRedirect = force || !this.naja.uiHandler.isUrlAllowed(url);
        const canRedirect = this.dispatchEvent(new CustomEvent('redirect', {
            cancelable: true,
            detail: {
                url,
                isHardRedirect,
                setHardRedirect(value) {
                    isHardRedirect = !!value;
                },
                options,
            },
        }));
        if (!canRedirect) {
            return;
        }
        if (isHardRedirect) {
            this.locationAdapter.assign(url);
        }
        else {
            this.naja.makeRequest('GET', url, null, options);
        }
    }
}

class SnippetHandler extends EventTarget {
    constructor(naja) {
        super();
        this.naja = naja;
        this.op = {
            replace: (snippet, content) => {
                snippet.innerHTML = content;
            },
            prepend: (snippet, content) => snippet.insertAdjacentHTML('afterbegin', content),
            append: (snippet, content) => snippet.insertAdjacentHTML('beforeend', content),
        };
        naja.addEventListener('success', (event) => {
            const { options, payload } = event.detail;
            if (payload.snippets) {
                this.updateSnippets(payload.snippets, false, options);
            }
        });
    }
    updateSnippets(snippets, fromCache = false, options = {}) {
        Object.keys(snippets).forEach((id) => {
            const snippet = document.getElementById(id);
            if (snippet) {
                this.updateSnippet(snippet, snippets[id], fromCache, options);
            }
        });
    }
    updateSnippet(snippet, content, fromCache, options) {
        let operation = this.op.replace;
        if ((snippet.hasAttribute('data-naja-snippet-prepend') || snippet.hasAttribute('data-ajax-prepend')) && !fromCache) {
            operation = this.op.prepend;
        }
        else if ((snippet.hasAttribute('data-naja-snippet-append') || snippet.hasAttribute('data-ajax-append')) && !fromCache) {
            operation = this.op.append;
        }
        const canUpdate = this.dispatchEvent(new CustomEvent('beforeUpdate', {
            cancelable: true,
            detail: {
                snippet,
                content,
                fromCache,
                operation,
                changeOperation(value) {
                    operation = value;
                },
                options,
            },
        }));
        if (!canUpdate) {
            return;
        }
        if (snippet.tagName.toLowerCase() === 'title') {
            document.title = content;
        }
        else {
            operation(snippet, content);
        }
        this.dispatchEvent(new CustomEvent('afterUpdate', {
            cancelable: true,
            detail: {
                snippet,
                content,
                fromCache,
                operation,
                options,
            },
        }));
    }
}

class HistoryHandler {
    constructor(naja) {
        this.naja = naja;
        this.href = null;
        this.popStateHandler = this.handlePopState.bind(this);
        this.uiCache = true;
        naja.addEventListener('init', this.initialize.bind(this));
        naja.addEventListener('before', this.saveUrl.bind(this));
        naja.addEventListener('success', this.pushNewState.bind(this));
        naja.uiHandler.addEventListener('interaction', this.configureMode.bind(this));
        this.historyAdapter = {
            replaceState: (data, title, url) => window.history.replaceState(data, title, url),
            pushState: (data, title, url) => window.history.pushState(data, title, url),
        };
    }
    initialize(event) {
        const { defaultOptions } = event.detail;
        if ('historyUiCache' in defaultOptions && defaultOptions.historyUiCache !== undefined) {
            this.uiCache = defaultOptions.historyUiCache;
        }
        window.addEventListener('popstate', this.popStateHandler);
        this.historyAdapter.replaceState(this.buildState(window.location.href, this.uiCache), window.document.title, window.location.href);
    }
    handlePopState(e) {
        if (!e.state) {
            return;
        }
        if (e.state.ui) {
            this.handleSnippets(e.state.ui);
            this.handleTitle(e.state.title);
        }
        else if (e.state.ui === false) {
            this.naja.makeRequest('GET', e.state.href, null, {
                history: false,
                historyUiCache: false,
            });
        }
    }
    saveUrl(event) {
        const { url } = event.detail;
        this.href = url;
    }
    configureMode(event) {
        var _a, _b, _c, _d, _e, _f;
        const { element, options } = event.detail;
        // propagate mode to options
        if (!element) {
            return;
        }
        if (element.hasAttribute('data-naja-history') || ((_a = element.form) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-naja-history'))) {
            const value = (_b = element.getAttribute('data-naja-history')) !== null && _b !== void 0 ? _b : (_c = element.form) === null || _c === void 0 ? void 0 : _c.getAttribute('data-naja-history');
            options.history = HistoryHandler.normalizeMode(value);
        }
        if (element.hasAttribute('data-naja-history-cache') || ((_d = element.form) === null || _d === void 0 ? void 0 : _d.hasAttribute('data-naja-history-nocache'))) {
            const value = (_e = element.getAttribute('data-naja-history-cache')) !== null && _e !== void 0 ? _e : (_f = element.form) === null || _f === void 0 ? void 0 : _f.getAttribute('data-naja-history-cache');
            options.historyUiCache = value !== 'off';
        }
    }
    static normalizeMode(mode) {
        if (mode === 'off' || mode === false) {
            return false;
        }
        else if (mode === 'replace') {
            return 'replace';
        }
        return true;
    }
    pushNewState(event) {
        const { payload, options } = event.detail;
        const mode = HistoryHandler.normalizeMode(options.history);
        if (mode === false) {
            return;
        }
        if (payload.postGet && payload.url) {
            this.href = payload.url;
        }
        const method = mode === 'replace' ? 'replaceState' : 'pushState';
        const uiCache = options.historyUiCache === true || (options.historyUiCache !== false && this.uiCache); // eslint-disable-line no-extra-parens
        this.historyAdapter[method](this.buildState(this.href, uiCache), window.document.title, this.href);
        this.href = null;
    }
    buildState(href, uiCache) {
        const state = {
            href,
        };
        if (uiCache) {
            state.title = window.document.title;
            state.ui = this.findSnippets();
        }
        else {
            state.ui = false;
        }
        return state;
    }
    findSnippets() {
        const result = {};
        const snippets = window.document.querySelectorAll('[id^="snippet-"]');
        for (let i = 0; i < snippets.length; i++) {
            const snippet = snippets.item(i);
            if (!snippet.hasAttribute('data-naja-history-nocache') && !snippet.hasAttribute('data-history-nocache')) {
                result[snippet.id] = snippet.innerHTML;
            }
        }
        return result;
    }
    handleSnippets(snippets) {
        this.naja.snippetHandler.updateSnippets(snippets, true);
        this.naja.scriptLoader.loadScripts(snippets);
    }
    handleTitle(title) {
        window.document.title = title;
    }
}

class ScriptLoader {
    constructor(naja) {
        naja.addEventListener('success', (event) => {
            const { payload } = event.detail;
            if (payload.snippets) {
                this.loadScripts(payload.snippets);
            }
        });
    }
    loadScripts(snippets) {
        Object.keys(snippets).forEach((id) => {
            const content = snippets[id];
            if (!/<script/i.test(content)) {
                return;
            }
            const el = window.document.createElement('div');
            el.innerHTML = content;
            const scripts = el.querySelectorAll('script');
            for (let i = 0; i < scripts.length; i++) {
                const script = scripts.item(i);
                const scriptEl = window.document.createElement('script');
                scriptEl.innerHTML = script.innerHTML;
                if (script.hasAttributes()) {
                    const attrs = script.attributes;
                    for (let j = 0; j < attrs.length; j++) {
                        const attrName = attrs[j].name;
                        scriptEl.setAttribute(attrName, attrs[j].value);
                    }
                }
                window.document.head.appendChild(scriptEl)
                    .parentNode.removeChild(scriptEl);
            }
        });
    }
}

class Naja extends EventTarget {
    constructor(uiHandler, redirectHandler, snippetHandler, formsHandler, historyHandler, scriptLoader) {
        super();
        this.VERSION = 2;
        this.initialized = false;
        this.extensions = [];
        this.defaultOptions = {};
        this.uiHandler = uiHandler ? new uiHandler(this) : new UIHandler(this);
        this.redirectHandler = redirectHandler ? new redirectHandler(this) : new RedirectHandler(this);
        this.snippetHandler = snippetHandler ? new snippetHandler(this) : new SnippetHandler(this);
        this.formsHandler = formsHandler ? new formsHandler(this) : new FormsHandler(this);
        this.historyHandler = historyHandler ? new historyHandler(this) : new HistoryHandler(this);
        this.scriptLoader = scriptLoader ? new scriptLoader(this) : new ScriptLoader(this);
    }
    registerExtension(extension) {
        if (this.initialized) {
            extension.initialize(this);
        }
        this.extensions.push(extension);
    }
    initialize(defaultOptions = {}) {
        if (this.initialized) {
            throw new Error('Cannot initialize Naja, it is already initialized.');
        }
        this.defaultOptions = defaultOptions;
        this.extensions.forEach((extension) => extension.initialize(this));
        this.dispatchEvent(new CustomEvent('init', { detail: { defaultOptions } }));
        this.initialized = true;
    }
    async makeRequest(method, url, data = null, options = {}) {
        // normalize url to instanceof URL
        if (typeof url === 'string') {
            url = new URL(url, location.href);
        }
        options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), { fetch: Object.assign(Object.assign({}, this.defaultOptions.fetch || {}), options.fetch || {}) });
        const headers = new Headers(options.fetch.headers || {});
        const body = this.transformData(url, method, data);
        const abortController = new AbortController();
        const request = new Request(url.toString(), Object.assign(Object.assign({ credentials: 'same-origin' }, options.fetch), { method,
            headers,
            body, signal: abortController.signal }));
        // impersonate XHR so that Nette can detect isAjax()
        request.headers.set('X-Requested-With', 'XMLHttpRequest');
        if (!this.dispatchEvent(new CustomEvent('before', { cancelable: true, detail: { request, method, url: url.toString(), data, options } }))) {
            return {};
        }
        const promise = window.fetch(request);
        this.dispatchEvent(new CustomEvent('start', { detail: { request, promise, abortController, options } }));
        let response, payload;
        try {
            response = await promise;
            if (!response.ok) {
                throw new HttpError(response);
            }
            payload = await response.json();
        }
        catch (error) {
            if (error.name === 'AbortError') {
                this.dispatchEvent(new CustomEvent('abort', { detail: { request, error, options } }));
                this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload: undefined, error, options } }));
                return {};
            }
            this.dispatchEvent(new CustomEvent('error', { detail: { request, response, error, options } }));
            this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload: undefined, error, options } }));
            throw error;
        }
        this.dispatchEvent(new CustomEvent('success', { detail: { request, response, payload, options } }));
        this.dispatchEvent(new CustomEvent('complete', { detail: { request, response, payload, error: undefined, options } }));
        return payload;
    }
    appendToQueryString(searchParams, key, value) {
        if (value === null || value === undefined) {
            return;
        }
        if (Array.isArray(value)) {
            let index = 0;
            for (const subvalue of value) {
                this.appendToQueryString(searchParams, `${key}[${index++}]`, subvalue);
            }
        }
        else if (Object.getPrototypeOf(value) === Object.prototype) {
            for (const [subkey, subvalue] of Object.entries(value)) {
                this.appendToQueryString(searchParams, `${key}[${subkey}]`, subvalue);
            }
        }
        else {
            searchParams.append(key, String(value));
        }
    }
    transformData(url, method, data) {
        const isGet = ['GET', 'HEAD'].includes(method.toUpperCase());
        // sending a form via GET -> serialize FormData into URL and return empty request body
        if (isGet && data instanceof FormData) {
            for (const [key, value] of data) {
                if (value !== null && value !== undefined) {
                    url.searchParams.append(key, String(value));
                }
            }
            return null;
        }
        // sending a POJO -> serialize it recursively into URLSearchParams
        const isDataPojo = data !== null && Object.getPrototypeOf(data) === Object.prototype;
        if (isDataPojo) {
            // for GET requests, append values to URL and return empty request body
            // otherwise build `new URLSearchParams()` to act as the request body
            const transformedData = isGet ? url.searchParams : new URLSearchParams();
            for (const [key, value] of Object.entries(data)) {
                this.appendToQueryString(transformedData, key, value);
            }
            return isGet
                ? null
                : transformedData;
        }
        return data;
    }
}
class HttpError extends Error {
    constructor(response) {
        const message = `HTTP ${response.status}: ${response.statusText}`;
        super(message);
        this.name = this.constructor.name;
        this.stack = new Error(message).stack;
        this.response = response;
    }
}

class AbortExtension {
    constructor() {
        this.abortable = true;
        this.abortController = null;
    }
    initialize(naja) {
        naja.uiHandler.addEventListener('interaction', this.checkAbortable.bind(this));
        naja.addEventListener('init', this.onInitialize.bind(this));
        naja.addEventListener('before', this.checkAbortable.bind(this));
        naja.addEventListener('start', this.saveAbortController.bind(this));
        naja.addEventListener('complete', this.clearAbortController.bind(this));
    }
    onInitialize() {
        document.addEventListener('keydown', (event) => {
            if (this.abortController !== null
                && event.key === 'Escape'
                && !(event.ctrlKey || event.shiftKey || event.altKey || event.metaKey)
                && this.abortable) {
                this.abortController.abort();
                this.abortController = null;
            }
        });
    }
    checkAbortable(event) {
        var _a, _b;
        const { options } = event.detail;
        this.abortable = 'element' in event.detail
            ? ((_a = event.detail.element.getAttribute('data-naja-abort')) !== null && _a !== void 0 ? _a : (_b = event.detail.element.form) === null || _b === void 0 ? void 0 : _b.getAttribute('data-naja-abort')) !== 'off' // eslint-disable-line no-extra-parens
            : options.abort !== false;
        // propagate to options if called in interaction event
        options.abort = this.abortable;
    }
    saveAbortController(event) {
        const { abortController } = event.detail;
        this.abortController = abortController;
    }
    clearAbortController() {
        this.abortController = null;
        this.abortable = true;
    }
}

class UniqueExtension {
    constructor() {
        this.abortControllers = new Map();
    }
    initialize(naja) {
        naja.uiHandler.addEventListener('interaction', this.checkUniqueness.bind(this));
        naja.addEventListener('start', this.abortPreviousRequest.bind(this));
        naja.addEventListener('complete', this.clearRequest.bind(this));
    }
    checkUniqueness(event) {
        var _a, _b;
        const { element, options } = event.detail;
        const unique = (_a = element.getAttribute('data-naja-unique')) !== null && _a !== void 0 ? _a : (_b = element.form) === null || _b === void 0 ? void 0 : _b.getAttribute('data-naja-unique');
        options.unique = unique === 'off' ? false : unique !== null && unique !== void 0 ? unique : 'default';
    }
    abortPreviousRequest(event) {
        var _a, _b, _c;
        const { abortController, options } = event.detail;
        if (options.unique !== false) {
            (_b = this.abortControllers.get((_a = options.unique) !== null && _a !== void 0 ? _a : 'default')) === null || _b === void 0 ? void 0 : _b.abort();
            this.abortControllers.set((_c = options.unique) !== null && _c !== void 0 ? _c : 'default', abortController);
        }
    }
    clearRequest(event) {
        var _a;
        const { request, options } = event.detail;
        if (!request.signal.aborted && options.unique !== false) {
            this.abortControllers.delete((_a = options.unique) !== null && _a !== void 0 ? _a : 'default');
        }
    }
}

const naja = new Naja();
naja.registerExtension(new AbortExtension());
naja.registerExtension(new UniqueExtension());

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (naja);

//# sourceMappingURL=Naja.esm.js.map


/***/ }),

/***/ "./node_modules/event-target-shim/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/event-target-shim/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "EventTarget": () => (/* binding */ EventTarget),
/* harmony export */   "defineCustomEventTarget": () => (/* binding */ defineCustomEventTarget),
/* harmony export */   "defineEventAttribute": () => (/* binding */ defineEventAttribute),
/* harmony export */   "getEventAttributeValue": () => (/* binding */ getEventAttributeValue),
/* harmony export */   "setErrorHandler": () => (/* binding */ setErrorHandler),
/* harmony export */   "setEventAttributeValue": () => (/* binding */ setEventAttributeValue),
/* harmony export */   "setWarningHandler": () => (/* binding */ setWarningHandler)
/* harmony export */ });
/**
 * Assert a condition.
 * @param condition The condition that it should satisfy.
 * @param message The error message.
 * @param args The arguments for replacing placeholders in the message.
 */
function assertType(condition, message, ...args) {
    if (!condition) {
        throw new TypeError(format(message, args));
    }
}
/**
 * Convert a text and arguments to one string.
 * @param message The formating text
 * @param args The arguments.
 */
function format(message, args) {
    let i = 0;
    return message.replace(/%[os]/gu, () => anyToString(args[i++]));
}
/**
 * Convert a value to a string representation.
 * @param x The value to get the string representation.
 */
function anyToString(x) {
    if (typeof x !== "object" || x === null) {
        return String(x);
    }
    return Object.prototype.toString.call(x);
}

let currentErrorHandler;
/**
 * Set the error handler.
 * @param value The error handler to set.
 */
function setErrorHandler(value) {
    assertType(typeof value === "function" || value === undefined, "The error handler must be a function or undefined, but got %o.", value);
    currentErrorHandler = value;
}
/**
 * Print a error message.
 * @param maybeError The error object.
 */
function reportError(maybeError) {
    try {
        const error = maybeError instanceof Error
            ? maybeError
            : new Error(anyToString(maybeError));
        // Call the user-defined error handler if exists.
        if (currentErrorHandler) {
            currentErrorHandler(error);
            return;
        }
        // Dispatch an `error` event if this is on a browser.
        if (typeof dispatchEvent === "function" &&
            typeof ErrorEvent === "function") {
            dispatchEvent(new ErrorEvent("error", { error, message: error.message }));
        }
        // Emit an `uncaughtException` event if this is on Node.js.
        //istanbul ignore else
        else if (typeof process !== "undefined" &&
            typeof process.emit === "function") {
            process.emit("uncaughtException", error);
            return;
        }
        // Otherwise, print the error.
        console.error(error);
    }
    catch (_a) {
        // ignore.
    }
}

/**
 * The global object.
 */
//istanbul ignore next
const Global = typeof window !== "undefined"
    ? window
    : typeof self !== "undefined"
        ? self
        : typeof global !== "undefined"
            ? global
            : typeof globalThis !== "undefined"
                ? globalThis
                : undefined;

let currentWarnHandler;
/**
 * Set the warning handler.
 * @param value The warning handler to set.
 */
function setWarningHandler(value) {
    assertType(typeof value === "function" || value === undefined, "The warning handler must be a function or undefined, but got %o.", value);
    currentWarnHandler = value;
}
/**
 * The warning information.
 */
class Warning {
    constructor(code, message) {
        this.code = code;
        this.message = message;
    }
    /**
     * Report this warning.
     * @param args The arguments of the warning.
     */
    warn(...args) {
        var _a;
        try {
            // Call the user-defined warning handler if exists.
            if (currentWarnHandler) {
                currentWarnHandler({ ...this, args });
                return;
            }
            // Otherwise, print the warning.
            const stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : "").replace(/^(?:.+?\n){2}/gu, "\n");
            console.warn(this.message, ...args, stack);
        }
        catch (_b) {
            // Ignore.
        }
    }
}

const InitEventWasCalledWhileDispatching = new Warning("W01", "Unable to initialize event under dispatching.");
const FalsyWasAssignedToCancelBubble = new Warning("W02", "Assigning any falsy value to 'cancelBubble' property has no effect.");
const TruthyWasAssignedToReturnValue = new Warning("W03", "Assigning any truthy value to 'returnValue' property has no effect.");
const NonCancelableEventWasCanceled = new Warning("W04", "Unable to preventDefault on non-cancelable events.");
const CanceledInPassiveListener = new Warning("W05", "Unable to preventDefault inside passive event listener invocation.");
const EventListenerWasDuplicated = new Warning("W06", "An event listener wasn't added because it has been added already: %o, %o");
const OptionWasIgnored = new Warning("W07", "The %o option value was abandoned because the event listener wasn't added as duplicated.");
const InvalidEventListener = new Warning("W08", "The 'callback' argument must be a function or an object that has 'handleEvent' method: %o");
const InvalidAttributeHandler = new Warning("W09", "Event attribute handler must be a function: %o");

/*eslint-disable class-methods-use-this */
/**
 * An implementation of `Event` interface, that wraps a given event object.
 * `EventTarget` shim can control the internal state of this `Event` objects.
 * @see https://dom.spec.whatwg.org/#event
 */
class Event {
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-none
     */
    static get NONE() {
        return NONE;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase
     */
    static get CAPTURING_PHASE() {
        return CAPTURING_PHASE;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-at_target
     */
    static get AT_TARGET() {
        return AT_TARGET;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase
     */
    static get BUBBLING_PHASE() {
        return BUBBLING_PHASE;
    }
    /**
     * Initialize this event instance.
     * @param type The type of this event.
     * @param eventInitDict Options to initialize.
     * @see https://dom.spec.whatwg.org/#dom-event-event
     */
    constructor(type, eventInitDict) {
        Object.defineProperty(this, "isTrusted", {
            value: false,
            enumerable: true,
        });
        const opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};
        internalDataMap.set(this, {
            type: String(type),
            bubbles: Boolean(opts.bubbles),
            cancelable: Boolean(opts.cancelable),
            composed: Boolean(opts.composed),
            target: null,
            currentTarget: null,
            stopPropagationFlag: false,
            stopImmediatePropagationFlag: false,
            canceledFlag: false,
            inPassiveListenerFlag: false,
            dispatchFlag: false,
            timeStamp: Date.now(),
        });
    }
    /**
     * The type of this event.
     * @see https://dom.spec.whatwg.org/#dom-event-type
     */
    get type() {
        return $(this).type;
    }
    /**
     * The event target of the current dispatching.
     * @see https://dom.spec.whatwg.org/#dom-event-target
     */
    get target() {
        return $(this).target;
    }
    /**
     * The event target of the current dispatching.
     * @deprecated Use the `target` property instead.
     * @see https://dom.spec.whatwg.org/#dom-event-srcelement
     */
    get srcElement() {
        return $(this).target;
    }
    /**
     * The event target of the current dispatching.
     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget
     */
    get currentTarget() {
        return $(this).currentTarget;
    }
    /**
     * The event target of the current dispatching.
     * This doesn't support node tree.
     * @see https://dom.spec.whatwg.org/#dom-event-composedpath
     */
    composedPath() {
        const currentTarget = $(this).currentTarget;
        if (currentTarget) {
            return [currentTarget];
        }
        return [];
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-none
     */
    get NONE() {
        return NONE;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase
     */
    get CAPTURING_PHASE() {
        return CAPTURING_PHASE;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-at_target
     */
    get AT_TARGET() {
        return AT_TARGET;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase
     */
    get BUBBLING_PHASE() {
        return BUBBLING_PHASE;
    }
    /**
     * The current event phase.
     * @see https://dom.spec.whatwg.org/#dom-event-eventphase
     */
    get eventPhase() {
        return $(this).dispatchFlag ? 2 : 0;
    }
    /**
     * Stop event bubbling.
     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.
     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation
     */
    stopPropagation() {
        $(this).stopPropagationFlag = true;
    }
    /**
     * `true` if event bubbling was stopped.
     * @deprecated
     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble
     */
    get cancelBubble() {
        return $(this).stopPropagationFlag;
    }
    /**
     * Stop event bubbling if `true` is set.
     * @deprecated Use the `stopPropagation()` method instead.
     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble
     */
    set cancelBubble(value) {
        if (value) {
            $(this).stopPropagationFlag = true;
        }
        else {
            FalsyWasAssignedToCancelBubble.warn();
        }
    }
    /**
     * Stop event bubbling and subsequent event listener callings.
     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation
     */
    stopImmediatePropagation() {
        const data = $(this);
        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;
    }
    /**
     * `true` if this event will bubble.
     * @see https://dom.spec.whatwg.org/#dom-event-bubbles
     */
    get bubbles() {
        return $(this).bubbles;
    }
    /**
     * `true` if this event can be canceled by the `preventDefault()` method.
     * @see https://dom.spec.whatwg.org/#dom-event-cancelable
     */
    get cancelable() {
        return $(this).cancelable;
    }
    /**
     * `true` if the default behavior will act.
     * @deprecated Use the `defaultPrevented` proeprty instead.
     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue
     */
    get returnValue() {
        return !$(this).canceledFlag;
    }
    /**
     * Cancel the default behavior if `false` is set.
     * @deprecated Use the `preventDefault()` method instead.
     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue
     */
    set returnValue(value) {
        if (!value) {
            setCancelFlag($(this));
        }
        else {
            TruthyWasAssignedToReturnValue.warn();
        }
    }
    /**
     * Cancel the default behavior.
     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault
     */
    preventDefault() {
        setCancelFlag($(this));
    }
    /**
     * `true` if the default behavior was canceled.
     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented
     */
    get defaultPrevented() {
        return $(this).canceledFlag;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-composed
     */
    get composed() {
        return $(this).composed;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-istrusted
     */
    //istanbul ignore next
    get isTrusted() {
        return false;
    }
    /**
     * @see https://dom.spec.whatwg.org/#dom-event-timestamp
     */
    get timeStamp() {
        return $(this).timeStamp;
    }
    /**
     * @deprecated Don't use this method. The constructor did initialization.
     */
    initEvent(type, bubbles = false, cancelable = false) {
        const data = $(this);
        if (data.dispatchFlag) {
            InitEventWasCalledWhileDispatching.warn();
            return;
        }
        internalDataMap.set(this, {
            ...data,
            type: String(type),
            bubbles: Boolean(bubbles),
            cancelable: Boolean(cancelable),
            target: null,
            currentTarget: null,
            stopPropagationFlag: false,
            stopImmediatePropagationFlag: false,
            canceledFlag: false,
        });
    }
}
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
const NONE = 0;
const CAPTURING_PHASE = 1;
const AT_TARGET = 2;
const BUBBLING_PHASE = 3;
/**
 * Private data for event wrappers.
 */
const internalDataMap = new WeakMap();
/**
 * Get private data.
 * @param event The event object to get private data.
 * @param name The variable name to report.
 * @returns The private data of the event.
 */
function $(event, name = "this") {
    const retv = internalDataMap.get(event);
    assertType(retv != null, "'%s' must be an object that Event constructor created, but got another one: %o", name, event);
    return retv;
}
/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data private data.
 */
function setCancelFlag(data) {
    if (data.inPassiveListenerFlag) {
        CanceledInPassiveListener.warn();
        return;
    }
    if (!data.cancelable) {
        NonCancelableEventWasCanceled.warn();
        return;
    }
    data.canceledFlag = true;
}
// Set enumerable
Object.defineProperty(Event, "NONE", { enumerable: true });
Object.defineProperty(Event, "CAPTURING_PHASE", { enumerable: true });
Object.defineProperty(Event, "AT_TARGET", { enumerable: true });
Object.defineProperty(Event, "BUBBLING_PHASE", { enumerable: true });
const keys = Object.getOwnPropertyNames(Event.prototype);
for (let i = 0; i < keys.length; ++i) {
    if (keys[i] === "constructor") {
        continue;
    }
    Object.defineProperty(Event.prototype, keys[i], { enumerable: true });
}
// Ensure `event instanceof window.Event` is `true`.
if (typeof Global !== "undefined" && typeof Global.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, Global.Event.prototype);
}

/**
 * Create a new InvalidStateError instance.
 * @param message The error message.
 */
function createInvalidStateError(message) {
    if (Global.DOMException) {
        return new Global.DOMException(message, "InvalidStateError");
    }
    if (DOMException == null) {
        DOMException = class DOMException extends Error {
            constructor(msg) {
                super(msg);
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, DOMException);
                }
            }
            // eslint-disable-next-line class-methods-use-this
            get code() {
                return 11;
            }
            // eslint-disable-next-line class-methods-use-this
            get name() {
                return "InvalidStateError";
            }
        };
        Object.defineProperties(DOMException.prototype, {
            code: { enumerable: true },
            name: { enumerable: true },
        });
        defineErrorCodeProperties(DOMException);
        defineErrorCodeProperties(DOMException.prototype);
    }
    return new DOMException(message);
}
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
let DOMException;
const ErrorCodeMap = {
    INDEX_SIZE_ERR: 1,
    DOMSTRING_SIZE_ERR: 2,
    HIERARCHY_REQUEST_ERR: 3,
    WRONG_DOCUMENT_ERR: 4,
    INVALID_CHARACTER_ERR: 5,
    NO_DATA_ALLOWED_ERR: 6,
    NO_MODIFICATION_ALLOWED_ERR: 7,
    NOT_FOUND_ERR: 8,
    NOT_SUPPORTED_ERR: 9,
    INUSE_ATTRIBUTE_ERR: 10,
    INVALID_STATE_ERR: 11,
    SYNTAX_ERR: 12,
    INVALID_MODIFICATION_ERR: 13,
    NAMESPACE_ERR: 14,
    INVALID_ACCESS_ERR: 15,
    VALIDATION_ERR: 16,
    TYPE_MISMATCH_ERR: 17,
    SECURITY_ERR: 18,
    NETWORK_ERR: 19,
    ABORT_ERR: 20,
    URL_MISMATCH_ERR: 21,
    QUOTA_EXCEEDED_ERR: 22,
    TIMEOUT_ERR: 23,
    INVALID_NODE_TYPE_ERR: 24,
    DATA_CLONE_ERR: 25,
};
function defineErrorCodeProperties(obj) {
    const keys = Object.keys(ErrorCodeMap);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = ErrorCodeMap[key];
        Object.defineProperty(obj, key, {
            get() {
                return value;
            },
            configurable: true,
            enumerable: true,
        });
    }
}

/**
 * An implementation of `Event` interface, that wraps a given event object.
 * This class controls the internal state of `Event`.
 * @see https://dom.spec.whatwg.org/#interface-event
 */
class EventWrapper extends Event {
    /**
     * Wrap a given event object to control states.
     * @param event The event-like object to wrap.
     */
    static wrap(event) {
        return new (getWrapperClassOf(event))(event);
    }
    constructor(event) {
        super(event.type, {
            bubbles: event.bubbles,
            cancelable: event.cancelable,
            composed: event.composed,
        });
        if (event.cancelBubble) {
            super.stopPropagation();
        }
        if (event.defaultPrevented) {
            super.preventDefault();
        }
        internalDataMap$1.set(this, { original: event });
        // Define accessors
        const keys = Object.keys(event);
        for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];
            if (!(key in this)) {
                Object.defineProperty(this, key, defineRedirectDescriptor(event, key));
            }
        }
    }
    stopPropagation() {
        super.stopPropagation();
        const { original } = $$1(this);
        if ("stopPropagation" in original) {
            original.stopPropagation();
        }
    }
    get cancelBubble() {
        return super.cancelBubble;
    }
    set cancelBubble(value) {
        super.cancelBubble = value;
        const { original } = $$1(this);
        if ("cancelBubble" in original) {
            original.cancelBubble = value;
        }
    }
    stopImmediatePropagation() {
        super.stopImmediatePropagation();
        const { original } = $$1(this);
        if ("stopImmediatePropagation" in original) {
            original.stopImmediatePropagation();
        }
    }
    get returnValue() {
        return super.returnValue;
    }
    set returnValue(value) {
        super.returnValue = value;
        const { original } = $$1(this);
        if ("returnValue" in original) {
            original.returnValue = value;
        }
    }
    preventDefault() {
        super.preventDefault();
        const { original } = $$1(this);
        if ("preventDefault" in original) {
            original.preventDefault();
        }
    }
    get timeStamp() {
        const { original } = $$1(this);
        if ("timeStamp" in original) {
            return original.timeStamp;
        }
        return super.timeStamp;
    }
}
/**
 * Private data for event wrappers.
 */
const internalDataMap$1 = new WeakMap();
/**
 * Get private data.
 * @param event The event object to get private data.
 * @returns The private data of the event.
 */
function $$1(event) {
    const retv = internalDataMap$1.get(event);
    assertType(retv != null, "'this' is expected an Event object, but got", event);
    return retv;
}
/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrapperClassCache = new WeakMap();
// Make association for wrappers.
wrapperClassCache.set(Object.prototype, EventWrapper);
if (typeof Global !== "undefined" && typeof Global.Event !== "undefined") {
    wrapperClassCache.set(Global.Event.prototype, EventWrapper);
}
/**
 * Get the wrapper class of a given prototype.
 * @param originalEvent The event object to wrap.
 */
function getWrapperClassOf(originalEvent) {
    const prototype = Object.getPrototypeOf(originalEvent);
    if (prototype == null) {
        return EventWrapper;
    }
    let wrapper = wrapperClassCache.get(prototype);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);
        wrapperClassCache.set(prototype, wrapper);
    }
    return wrapper;
}
/**
 * Define new wrapper class.
 * @param BaseEventWrapper The base wrapper class.
 * @param originalPrototype The prototype of the original event.
 */
function defineWrapper(BaseEventWrapper, originalPrototype) {
    class CustomEventWrapper extends BaseEventWrapper {
    }
    const keys = Object.keys(originalPrototype);
    for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(CustomEventWrapper.prototype, keys[i], defineRedirectDescriptor(originalPrototype, keys[i]));
    }
    return CustomEventWrapper;
}
/**
 * Get the property descriptor to redirect a given property.
 */
function defineRedirectDescriptor(obj, key) {
    const d = Object.getOwnPropertyDescriptor(obj, key);
    return {
        get() {
            const original = $$1(this).original;
            const value = original[key];
            if (typeof value === "function") {
                return value.bind(original);
            }
            return value;
        },
        set(value) {
            const original = $$1(this).original;
            original[key] = value;
        },
        configurable: d.configurable,
        enumerable: d.enumerable,
    };
}

/**
 * Create a new listener.
 * @param callback The callback function.
 * @param capture The capture flag.
 * @param passive The passive flag.
 * @param once The once flag.
 * @param signal The abort signal.
 * @param signalListener The abort event listener for the abort signal.
 */
function createListener(callback, capture, passive, once, signal, signalListener) {
    return {
        callback,
        flags: (capture ? 1 /* Capture */ : 0) |
            (passive ? 2 /* Passive */ : 0) |
            (once ? 4 /* Once */ : 0),
        signal,
        signalListener,
    };
}
/**
 * Set the `removed` flag to the given listener.
 * @param listener The listener to check.
 */
function setRemoved(listener) {
    listener.flags |= 8 /* Removed */;
}
/**
 * Check if the given listener has the `capture` flag or not.
 * @param listener The listener to check.
 */
function isCapture(listener) {
    return (listener.flags & 1 /* Capture */) === 1 /* Capture */;
}
/**
 * Check if the given listener has the `passive` flag or not.
 * @param listener The listener to check.
 */
function isPassive(listener) {
    return (listener.flags & 2 /* Passive */) === 2 /* Passive */;
}
/**
 * Check if the given listener has the `once` flag or not.
 * @param listener The listener to check.
 */
function isOnce(listener) {
    return (listener.flags & 4 /* Once */) === 4 /* Once */;
}
/**
 * Check if the given listener has the `removed` flag or not.
 * @param listener The listener to check.
 */
function isRemoved(listener) {
    return (listener.flags & 8 /* Removed */) === 8 /* Removed */;
}
/**
 * Call an event listener.
 * @param listener The listener to call.
 * @param target The event target object for `thisArg`.
 * @param event The event object for the first argument.
 * @param attribute `true` if this callback is an event attribute handler.
 */
function invokeCallback({ callback }, target, event) {
    try {
        if (typeof callback === "function") {
            callback.call(target, event);
        }
        else if (typeof callback.handleEvent === "function") {
            callback.handleEvent(event);
        }
    }
    catch (thrownError) {
        reportError(thrownError);
    }
}

/**
 * Find the index of given listener.
 * This returns `-1` if not found.
 * @param list The listener list.
 * @param callback The callback function to find.
 * @param capture The capture flag to find.
 */
function findIndexOfListener({ listeners }, callback, capture) {
    for (let i = 0; i < listeners.length; ++i) {
        if (listeners[i].callback === callback &&
            isCapture(listeners[i]) === capture) {
            return i;
        }
    }
    return -1;
}
/**
 * Add the given listener.
 * Does copy-on-write if needed.
 * @param list The listener list.
 * @param callback The callback function.
 * @param capture The capture flag.
 * @param passive The passive flag.
 * @param once The once flag.
 * @param signal The abort signal.
 */
function addListener(list, callback, capture, passive, once, signal) {
    let signalListener;
    if (signal) {
        signalListener = removeListener.bind(null, list, callback, capture);
        signal.addEventListener("abort", signalListener);
    }
    const listener = createListener(callback, capture, passive, once, signal, signalListener);
    if (list.cow) {
        list.cow = false;
        list.listeners = [...list.listeners, listener];
    }
    else {
        list.listeners.push(listener);
    }
    return listener;
}
/**
 * Remove a listener.
 * @param list The listener list.
 * @param callback The callback function to find.
 * @param capture The capture flag to find.
 * @returns `true` if it mutated the list directly.
 */
function removeListener(list, callback, capture) {
    const index = findIndexOfListener(list, callback, capture);
    if (index !== -1) {
        return removeListenerAt(list, index);
    }
    return false;
}
/**
 * Remove a listener.
 * @param list The listener list.
 * @param index The index of the target listener.
 * @param disableCow Disable copy-on-write if true.
 * @returns `true` if it mutated the `listeners` array directly.
 */
function removeListenerAt(list, index, disableCow = false) {
    const listener = list.listeners[index];
    // Set the removed flag.
    setRemoved(listener);
    // Dispose the abort signal listener if exists.
    if (listener.signal) {
        listener.signal.removeEventListener("abort", listener.signalListener);
    }
    // Remove it from the array.
    if (list.cow && !disableCow) {
        list.cow = false;
        list.listeners = list.listeners.filter((_, i) => i !== index);
        return false;
    }
    list.listeners.splice(index, 1);
    return true;
}

/**
 * Create a new `ListenerListMap` object.
 */
function createListenerListMap() {
    return Object.create(null);
}
/**
 * Get the listener list of the given type.
 * If the listener list has not been initialized, initialize and return it.
 * @param listenerMap The listener list map.
 * @param type The event type to get.
 */
function ensureListenerList(listenerMap, type) {
    var _a;
    return ((_a = listenerMap[type]) !== null && _a !== void 0 ? _a : (listenerMap[type] = {
        attrCallback: undefined,
        attrListener: undefined,
        cow: false,
        listeners: [],
    }));
}

/**
 * An implementation of the `EventTarget` interface.
 * @see https://dom.spec.whatwg.org/#eventtarget
 */
class EventTarget {
    /**
     * Initialize this instance.
     */
    constructor() {
        internalDataMap$2.set(this, createListenerListMap());
    }
    // Implementation
    addEventListener(type0, callback0, options0) {
        const listenerMap = $$2(this);
        const { callback, capture, once, passive, signal, type, } = normalizeAddOptions(type0, callback0, options0);
        if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) {
            return;
        }
        const list = ensureListenerList(listenerMap, type);
        // Find existing listener.
        const i = findIndexOfListener(list, callback, capture);
        if (i !== -1) {
            warnDuplicate(list.listeners[i], passive, once, signal);
            return;
        }
        // Add the new listener.
        addListener(list, callback, capture, passive, once, signal);
    }
    // Implementation
    removeEventListener(type0, callback0, options0) {
        const listenerMap = $$2(this);
        const { callback, capture, type } = normalizeOptions(type0, callback0, options0);
        const list = listenerMap[type];
        if (callback != null && list) {
            removeListener(list, callback, capture);
        }
    }
    // Implementation
    dispatchEvent(e) {
        const list = $$2(this)[String(e.type)];
        if (list == null) {
            return true;
        }
        const event = e instanceof Event ? e : EventWrapper.wrap(e);
        const eventData = $(event, "event");
        if (eventData.dispatchFlag) {
            throw createInvalidStateError("This event has been in dispatching.");
        }
        eventData.dispatchFlag = true;
        eventData.target = eventData.currentTarget = this;
        if (!eventData.stopPropagationFlag) {
            const { cow, listeners } = list;
            // Set copy-on-write flag.
            list.cow = true;
            // Call listeners.
            for (let i = 0; i < listeners.length; ++i) {
                const listener = listeners[i];
                // Skip if removed.
                if (isRemoved(listener)) {
                    continue;
                }
                // Remove this listener if has the `once` flag.
                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {
                    // Because this listener was removed, the next index is the
                    // same as the current value.
                    i -= 1;
                }
                // Call this listener with the `passive` flag.
                eventData.inPassiveListenerFlag = isPassive(listener);
                invokeCallback(listener, this, event);
                eventData.inPassiveListenerFlag = false;
                // Stop if the `event.stopImmediatePropagation()` method was called.
                if (eventData.stopImmediatePropagationFlag) {
                    break;
                }
            }
            // Restore copy-on-write flag.
            if (!cow) {
                list.cow = false;
            }
        }
        eventData.target = null;
        eventData.currentTarget = null;
        eventData.stopImmediatePropagationFlag = false;
        eventData.stopPropagationFlag = false;
        eventData.dispatchFlag = false;
        return !eventData.canceledFlag;
    }
}
/**
 * Internal data.
 */
const internalDataMap$2 = new WeakMap();
/**
 * Get private data.
 * @param target The event target object to get private data.
 * @param name The variable name to report.
 * @returns The private data of the event.
 */
function $$2(target, name = "this") {
    const retv = internalDataMap$2.get(target);
    assertType(retv != null, "'%s' must be an object that EventTarget constructor created, but got another one: %o", name, target);
    return retv;
}
/**
 * Normalize options.
 * @param options The options to normalize.
 */
function normalizeAddOptions(type, callback, options) {
    var _a;
    assertCallback(callback);
    if (typeof options === "object" && options !== null) {
        return {
            type: String(type),
            callback: callback !== null && callback !== void 0 ? callback : undefined,
            capture: Boolean(options.capture),
            passive: Boolean(options.passive),
            once: Boolean(options.once),
            signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined,
        };
    }
    return {
        type: String(type),
        callback: callback !== null && callback !== void 0 ? callback : undefined,
        capture: Boolean(options),
        passive: false,
        once: false,
        signal: undefined,
    };
}
/**
 * Normalize options.
 * @param options The options to normalize.
 */
function normalizeOptions(type, callback, options) {
    assertCallback(callback);
    if (typeof options === "object" && options !== null) {
        return {
            type: String(type),
            callback: callback !== null && callback !== void 0 ? callback : undefined,
            capture: Boolean(options.capture),
        };
    }
    return {
        type: String(type),
        callback: callback !== null && callback !== void 0 ? callback : undefined,
        capture: Boolean(options),
    };
}
/**
 * Assert the type of 'callback' argument.
 * @param callback The callback to check.
 */
function assertCallback(callback) {
    if (typeof callback === "function" ||
        (typeof callback === "object" &&
            callback !== null &&
            typeof callback.handleEvent === "function")) {
        return;
    }
    if (callback == null || typeof callback === "object") {
        InvalidEventListener.warn(callback);
        return;
    }
    throw new TypeError(format(InvalidEventListener.message, [callback]));
}
/**
 * Print warning for duplicated.
 * @param listener The current listener that is duplicated.
 * @param passive The passive flag of the new duplicated listener.
 * @param once The once flag of the new duplicated listener.
 * @param signal The signal object of the new duplicated listener.
 */
function warnDuplicate(listener, passive, once, signal) {
    EventListenerWasDuplicated.warn(isCapture(listener) ? "capture" : "bubble", listener.callback);
    if (isPassive(listener) !== passive) {
        OptionWasIgnored.warn("passive");
    }
    if (isOnce(listener) !== once) {
        OptionWasIgnored.warn("once");
    }
    if (listener.signal !== signal) {
        OptionWasIgnored.warn("signal");
    }
}
// Set enumerable
const keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);
for (let i = 0; i < keys$1.length; ++i) {
    if (keys$1[i] === "constructor") {
        continue;
    }
    Object.defineProperty(EventTarget.prototype, keys$1[i], { enumerable: true });
}
// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (typeof Global !== "undefined" &&
    typeof Global.EventTarget !== "undefined") {
    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);
}

/**
 * Get the current value of a given event attribute.
 * @param target The `EventTarget` object to get.
 * @param type The event type.
 */
function getEventAttributeValue(target, type) {
    var _a, _b;
    const listMap = $$2(target, "target");
    return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;
}
/**
 * Set an event listener to a given event attribute.
 * @param target The `EventTarget` object to set.
 * @param type The event type.
 * @param callback The event listener.
 */
function setEventAttributeValue(target, type, callback) {
    if (callback != null && typeof callback !== "function") {
        InvalidAttributeHandler.warn(callback);
    }
    if (typeof callback === "function" ||
        (typeof callback === "object" && callback !== null)) {
        upsertEventAttributeListener(target, type, callback);
    }
    else {
        removeEventAttributeListener(target, type);
    }
}
//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------
/**
 * Update or insert the given event attribute handler.
 * @param target The `EventTarget` object to set.
 * @param type The event type.
 * @param callback The event listener.
 */
function upsertEventAttributeListener(target, type, callback) {
    const list = ensureListenerList($$2(target, "target"), String(type));
    list.attrCallback = callback;
    if (list.attrListener == null) {
        list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);
    }
}
/**
 * Remove the given event attribute handler.
 * @param target The `EventTarget` object to remove.
 * @param type The event type.
 * @param callback The event listener.
 */
function removeEventAttributeListener(target, type) {
    const listMap = $$2(target, "target");
    const list = listMap[String(type)];
    if (list && list.attrListener) {
        removeListener(list, list.attrListener.callback, false);
        list.attrCallback = list.attrListener = undefined;
    }
}
/**
 * Define the callback function for the given listener list object.
 * It calls `attrCallback` property if the property value is a function.
 * @param list The `ListenerList` object.
 */
function defineEventAttributeCallback(list) {
    return function (event) {
        const callback = list.attrCallback;
        if (typeof callback === "function") {
            callback.call(this, event);
        }
    };
}

/**
 * Define an `EventTarget` class that has event attibutes.
 * @param types The types to define event attributes.
 * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.
 */
function defineCustomEventTarget(...types) {
    class CustomEventTarget extends EventTarget {
    }
    for (let i = 0; i < types.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, types[i]);
    }
    return CustomEventTarget;
}
/**
 * Define an event attribute.
 * @param target The `EventTarget` object to define an event attribute.
 * @param type The event type to define.
 * @param _eventClass Unused, but to infer `Event` class type.
 * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.
 */
function defineEventAttribute(target, type, _eventClass) {
    Object.defineProperty(target, `on${type}`, {
        get() {
            return getEventAttributeValue(this, type);
        },
        set(value) {
            setEventAttributeValue(this, type, value);
        },
        configurable: true,
        enumerable: true,
    });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventTarget);

//# sourceMappingURL=index.mjs.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2Z1bmN0aW9uX2JpbmRfanMtbm9kZV9tb2R1bGVzX2xpdmUtZm9ybS12YWxpZGF0aW9uLWVzLTExMzAyYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGlCQUFpQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBNEI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUEEsZUFBZSxtQkFBTyxDQUFDLDZFQUF3Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNOQSxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDOUQsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZ0M7O0FBRTlELHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsZ0JBQWdCO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDSkEsVUFBVSxtQkFBTyxDQUFDLGlFQUFrQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsMkVBQXVCO0FBQzdDLHFDQUFxQyxtQkFBTyxDQUFDLCtIQUFpRDtBQUM5RiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBcUM7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQSxrQkFBa0IsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMsdUdBQXFDO0FBQ3hFLCtCQUErQixtQkFBTyxDQUFD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QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0Esc0tBQXNLO0FBQ3RLO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0NBQXNDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxX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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RCxrREFBa0Qsa0JBQWtCO0FBQ3BFLDRDQUE0QyxrQkFBa0I7QUFDOUQsaURBQWlELGtCQUFrQjtBQUNuRTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLG9CQUFvQixrQkFBa0I7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtEQUFrRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsOERBQThELGtCQUFrQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxpRUFBZSxXQUFXLEVBQUM7QUFDc0k7QUFDaksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdXNlci1hZ2VudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtY2FsbGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3JkaW5hcnktdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLmJpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdmUtZm9ybS12YWxpZGF0aW9uLWVzNi9saXZlLWZvcm0tdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmFqYS9kaXN0L05hamEuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudC10YXJnZXQtc2hpbS9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciB0cnlUb1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90cnktdG8tc3RyaW5nJyk7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSA8IDQgPyAxIDogbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuIiwiLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICByZWRlZmluZSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghKGFyZ3NMZW5ndGggaW4gZmFjdG9yaWVzKSkge1xuICAgIGZvciAodmFyIGxpc3QgPSBbXSwgaSA9IDA7IGkgPCBhcmdzTGVuZ3RoOyBpKyspIGxpc3RbaV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gd2UgaGF2ZSBubyBwcm9wZXIgYWx0ZXJuYXRpdmVzLCBJRTgtIG9ubHlcbiAgICBmYWN0b3JpZXNbYXJnc0xlbmd0aF0gPSBGdW5jdGlvbignQyxhJywgJ3JldHVybiBuZXcgQygnICsgbGlzdC5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG59O1xuXG4vLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUNhbGxhYmxlKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kRnVuY3Rpb24ucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmRGdW5jdGlvbjtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhcyhGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMgfHwgKERFU0NSSVBUT1JTICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoYXJndW1lbnQpID8gYXJndW1lbnQgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pIDogZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iLCJ2YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuIiwidmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsInZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Lmhhc093biB8fCBmdW5jdGlvbiBoYXNPd24oaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbCh0b09iamVjdChpdCksIGtleSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCJ2YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG4iLCJ2YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgb2JqZWN0SGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzLmNhbGwoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChvYmplY3RIYXMoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuIiwiLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlKGRldGVjdGlvbikgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsInZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIiwidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpbnNwZWN0U291cmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5Jyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwidmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGluc3BlY3RTb3VyY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpLkNPTkZJR1VSQUJMRTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIHZhciBzdGF0ZTtcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSB7XG4gICAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gICAgfVxuICAgIGlmICghaGFzKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIG5hbWUpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gICAgfVxuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG4iLCIvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG4iLCJ2YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgc3RvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4xOC4xJyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIxIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsInZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYFRvSW50ZWdlcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuIiwidmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXN5bWJvbCcpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IFN0cmluZyhrZXkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdPYmplY3QnO1xuICB9XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQnKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kJyk7XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4kKHsgdGFyZ2V0OiAnRnVuY3Rpb24nLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGJpbmQ6IGJpbmRcbn0pO1xuIiwiLyoqXHJcbiAqIExpdmUgRm9ybSBWYWxpZGF0aW9uIGZvciBOZXR0ZSBGb3JtcyAyLjRcclxuICpcclxuICogQGF1dGhvciBSb2JlcnQgUMO2c2VsLCB6YWtyYXZhLCBSYWRlayBKZcW+ZMOtaywgTWFydHlJWCwgRGF2aWQgR3J1ZGxcclxuICogQHZlcnNpb24gMS45LjAtZGV2XHJcbiAqIEB1cmwgaHR0cHM6Ly9naXRodWIuY29tL1JvYnllci9uZXR0ZS1saXZlLWZvcm0tdmFsaWRhdGlvbi9cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeUxpdmVWYWxpZGF0aW9uLCBmYWN0b3J5TmV0dGVGb3JtKSB7XHJcblxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuXHQvLyBBTURcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgTGl2ZUZvcm06IGZhY3RvcnlMaXZlVmFsaWRhdGlvbihnbG9iYWwpLFxyXG4gICAgICAgIE5ldHRlOiBmYWN0b3J5TmV0dGVGb3JtKGdsb2JhbClcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG4gICAgLy8gTm9kZSwgQ29tbW9uSlMtbGlrZVxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0XHRMaXZlRm9ybTogZmFjdG9yeUxpdmVWYWxpZGF0aW9uKGdsb2JhbCksXHJcblx0XHROZXR0ZTogZmFjdG9yeU5ldHRlRm9ybShnbG9iYWwpXHJcblx0fVxyXG4gIH0gZWxzZSB7XHJcbiAgICBnbG9iYWwuTGl2ZUZvcm0gPSBmYWN0b3J5TGl2ZVZhbGlkYXRpb24oZ2xvYmFsKTtcclxuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXHJcblx0dmFyIGluaXQgPSAhZ2xvYmFsLk5ldHRlIHx8ICFnbG9iYWwuTmV0dGUubm9Jbml0O1xyXG5cdGdsb2JhbC5OZXR0ZSA9IGZhY3RvcnlOZXR0ZUZvcm0oZ2xvYmFsKTtcclxuXHRpZiAoaW5pdCkge1xyXG5cdFx0Z2xvYmFsLk5ldHRlLmluaXRPbkxvYWQoKTtcclxuXHR9XHJcbiAgfVxyXG4gIFxyXG4gIFxyXG59KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKHdpbmRvdykge1xyXG4gICd1c2Ugc3RyaWN0J1xyXG4gIFxyXG5cclxuICB2YXIgTGl2ZUZvcm0gPSB7XHJcbiAgICBvcHRpb25zOiB7XHJcblx0XHQvLyBDU1MgY2xhc3Mgb2YgY29udHJvbCdzIHBhcmVudCB3aGVyZSBlcnJvci92YWxpZCBjbGFzcyBzaG91bGQgYmUgYWRkZWQ7IG9yIFwiZmFsc2VcIiB0byB1c2UgY29udHJvbCBkaXJlY3RseVxyXG5cdFx0c2hvd01lc3NhZ2VDbGFzc09uUGFyZW50OiAnZm9ybS1ncm91cCcsXHJcblxyXG5cdFx0Ly8gQ1NTIGNsYXNzIG9mIGNvbnRyb2wncyBwYXJlbnQgd2hlcmUgZXJyb3IvdmFsaWQgbWVzc2FnZSBzaG91bGQgYmUgYWRkZWQgKGZhbGxiYWNrIHRvIGRpcmVjdCBwYXJlbnQgaWYgbm90IGZvdW5kKTsgb3IgXCJmYWxzZVwiIHRvIHVzZSBjb250cm9sJ3MgZGlyZWN0IHBhcmVudFxyXG5cdFx0bWVzc2FnZVBhcmVudENsYXNzOiBmYWxzZSxcclxuXHJcblx0XHQvLyBDU1MgY2xhc3MgZm9yIGFuIGludmFsaWQgY29udHJvbFxyXG5cdFx0Y29udHJvbEVycm9yQ2xhc3M6ICdoYXMtZXJyb3InLFxyXG5cclxuXHRcdC8vIENTUyBjbGFzcyBmb3IgYSB2YWxpZCBjb250cm9sXHJcblx0XHRjb250cm9sVmFsaWRDbGFzczogJ2hhcy1zdWNjZXNzJyxcclxuXHJcblx0XHQvLyBDU1MgY2xhc3MgZm9yIGFuIGVycm9yIG1lc3NhZ2VcclxuXHRcdG1lc3NhZ2VFcnJvckNsYXNzOiAnaGVscC1ibG9jayB0ZXh0LWRhbmdlcicsXHJcblxyXG5cdFx0Ly8gY29udHJvbCB3aXRoIHRoaXMgQ1NTIGNsYXNzIHdpbGwgc2hvdyBlcnJvci92YWxpZCBtZXNzYWdlIGV2ZW4gd2hlbiBjb250cm9sIGl0c2VsZiBpcyBoaWRkZW4gKHVzZWZ1bCBmb3IgY29udHJvbHMgd2hpY2ggYXJlIGhpZGRlbiBhbmQgd3JhcHBlZCBpbnRvIHNwZWNpYWwgY29tcG9uZW50KVxyXG5cdFx0ZW5hYmxlSGlkZGVuTWVzc2FnZUNsYXNzOiAnc2hvdy1oaWRkZW4tZXJyb3InLFxyXG5cclxuXHRcdC8vIGNvbnRyb2wgd2l0aCB0aGlzIENTUyBjbGFzcyB3aWxsIGhhdmUgZGlzYWJsZWQgbGl2ZSB2YWxpZGF0aW9uXHJcblx0XHRkaXNhYmxlTGl2ZVZhbGlkYXRpb25DbGFzczogJ25vLWxpdmUtdmFsaWRhdGlvbicsXHJcblxyXG5cdFx0Ly8gY29udHJvbCB3aXRoIHRoaXMgQ1NTIGNsYXNzIHdpbGwgbm90IHNob3cgdmFsaWQgbWVzc2FnZVxyXG5cdFx0ZGlzYWJsZVNob3dWYWxpZENsYXNzOiAnbm8tc2hvdy12YWxpZCcsXHJcblxyXG5cdFx0Ly8gdGFnIHRoYXQgd2lsbCBob2xkIHRoZSBlcnJvci92YWxpZCBtZXNzYWdlXHJcblx0XHRtZXNzYWdlVGFnOiAnc3BhbicsXHJcblxyXG5cdFx0Ly8gbWVzc2FnZSBlbGVtZW50IGlkID0gY29udHJvbCBpZCArIHRoaXMgcG9zdGZpeFxyXG5cdFx0bWVzc2FnZUlkUG9zdGZpeDogJ19tZXNzYWdlJyxcclxuXHJcblx0XHQvLyBzaG93IHRoaXMgaHRtbCBiZWZvcmUgZXJyb3IgbWVzc2FnZSBpdHNlbGZcclxuXHRcdG1lc3NhZ2VFcnJvclByZWZpeDogJyZuYnNwOzxpIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi1leGNsYW1hdGlvbi1zaWduXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPiZuYnNwOycsXHJcblxyXG5cdFx0Ly8gc2hvdyBhbGwgZXJyb3JzIHdoZW4gc3VibWl0dGluZyBmb3JtOyBvciB1c2UgXCJmYWxzZVwiIHRvIHNob3cgb25seSBmaXJzdCBlcnJvclxyXG5cdFx0c2hvd0FsbEVycm9yczogdHJ1ZSxcclxuXHJcblx0XHQvLyBzaG93IG1lc3NhZ2Ugd2hlbiB2YWxpZFxyXG5cdFx0c2hvd1ZhbGlkOiBmYWxzZSxcclxuXHJcblx0XHQvLyBkZWxheSBpbiBtcyBiZWZvcmUgdmFsaWRhdGluZyBvbiBrZXl1cC9rZXlkb3duOyBvciB1c2UgXCJmYWxzZVwiIHRvIGRpc2FibGUgaXRcclxuXHRcdHdhaXQ6IGZhbHNlLFxyXG5cclxuXHRcdC8vIHZlcnRpY2FsIHNjcmVlbiBvZmZzZXQgaW4gcHggdG8gc2Nyb2xsIGFmdGVyIGZvY3VzaW5nIGVsZW1lbnQgd2l0aCBlcnJvciAodXNlZnVsIHdoZW4gdXNpbmcgZml4ZWQgbmF2YmFyIG1lbnUgd2hpY2ggbWF5IG90aGVyd2lzZSBvYnNjdXJlIHRoZSBlbGVtZW50IGluIGZvY3VzKTsgb3IgdXNlIFwiZmFsc2VcIiBmb3IgZGVmYXVsdCBiZWhhdmlvclxyXG5cdFx0Zm9jdXNTY3JlZW5PZmZzZXRZOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGZvcm1zOiB7IH1cclxufTtcclxuXHJcbkxpdmVGb3JtLnNldE9wdGlvbnMgPSBmdW5jdGlvbih1c2VyT3B0aW9ucykge1xyXG5cdGZvciAodmFyIHByb3AgaW4gdXNlck9wdGlvbnMpIHtcclxuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcHRpb25zLCBwcm9wKSkge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnNbcHJvcF0gPSB1c2VyT3B0aW9uc1twcm9wXTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIEFsbG93IHNldHRpbmcgb3B0aW9ucyBiZWZvcmUgbG9hZGluZyB0aGUgc2NyaXB0IGp1c3QgYnkgY3JlYXRpbmcgZ2xvYmFsIExpdmVGb3JtT3B0aW9ucyBvYmplY3Qgd2l0aCBvcHRpb25zLlxyXG5pZiAodHlwZW9mIHdpbmRvdy5MaXZlRm9ybU9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0TGl2ZUZvcm0uc2V0T3B0aW9ucyh3aW5kb3cuTGl2ZUZvcm1PcHRpb25zKTtcclxufVxyXG5cclxuTGl2ZUZvcm0uaXNTcGVjaWFsS2V5ID0gZnVuY3Rpb24oaykge1xyXG5cdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzc3MDU2MS9qcXVlcnktamF2YXNjcmlwdC1yZWplY3QtY29udHJvbC1rZXlzLW9uLWtleWRvd24tZXZlbnRcclxuXHRyZXR1cm4gKGsgPT0gMjAgLyogQ2FwcyBsb2NrICovXHJcblx0XHR8fCBrID09IDE2IC8qIFNoaWZ0ICovXHJcblx0XHR8fCBrID09IDkgLyogVGFiICovXHJcblx0XHR8fCBrID09IDI3IC8qIEVzY2FwZSBLZXkgKi9cclxuXHRcdHx8IGsgPT0gMTcgLyogQ29udHJvbCBLZXkgKi9cclxuXHRcdHx8IGsgPT0gOTEgLyogV2luZG93cyBDb21tYW5kIEtleSAqL1xyXG5cdFx0fHwgayA9PSAxOSAvKiBQYXVzZSBCcmVhayAqL1xyXG5cdFx0fHwgayA9PSAxOCAvKiBBbHQgS2V5ICovXHJcblx0XHR8fCBrID09IDkzIC8qIFJpZ2h0IENsaWNrIFBvaW50IEtleSAqL1xyXG5cdFx0fHwgKGsgPj0gMzUgJiYgayA8PSA0MCkgLyogSG9tZSwgRW5kLCBBcnJvdyBLZXlzICovXHJcblx0XHR8fCBrID09IDQ1IC8qIEluc2VydCBLZXkgKi9cclxuXHRcdHx8IChrID49IDMzICYmIGsgPD0gMzQpIC8qUGFnZSBEb3duLCBQYWdlIFVwICovXHJcblx0XHR8fCAoayA+PSAxMTIgJiYgayA8PSAxMjMpIC8qIEYxIC0gRjEyICovXHJcblx0XHR8fCAoayA+PSAxNDQgJiYgayA8PSAxNDUpKTsgLyogTnVtIExvY2ssIFNjcm9sbCBMb2NrICovXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVycyBmb3IgYWxsIHRoZSBldmVudHMgdGhhdCB0cmlnZ2VyIHZhbGlkYXRpb25cclxuICogWU9VIENBTiBDSEFOR0UgdGhlc2UgaGFuZGxlcnMgKGllLiB0byB1c2UgalF1ZXJ5IGV2ZW50cyBpbnN0ZWFkKVxyXG4gKi9cclxuTGl2ZUZvcm0uc2V0dXBIYW5kbGVycyA9IGZ1bmN0aW9uKGVsKSB7XHJcblx0aWYgKHRoaXMuaGFzQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5kaXNhYmxlTGl2ZVZhbGlkYXRpb25DbGFzcykpXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdC8vIENoZWNrIGlmIGVsZW1lbnQgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWRcclxuXHRpZiAoZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1sZnYtaW5pdGlhbGl6ZWRcIikpXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdC8vIFJlbWVtYmVyIHdlIGluaXRpYWxpemVkIHRoaXMgZWxlbWVudCBzbyB3ZSB3b24ndCBkbyBpdCBhZ2FpblxyXG5cdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1sZnYtaW5pdGlhbGl6ZWQnLCAndHJ1ZScpO1xyXG5cclxuXHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdE5ldHRlLnZhbGlkYXRlQ29udHJvbChldmVudC50YXJnZXQgPyBldmVudC50YXJnZXQgOiBldmVudC5zcmNFbGVtZW50KTtcclxuXHR9O1xyXG5cclxuXHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdE5ldHRlLmFkZEV2ZW50KGVsLCBcImNoYW5nZVwiLCBoYW5kbGVyKTtcclxuXHROZXR0ZS5hZGRFdmVudChlbCwgXCJibHVyXCIsIGhhbmRsZXIpO1xyXG5cdE5ldHRlLmFkZEV2ZW50KGVsLCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRpZiAoIXNlbGYuaXNTcGVjaWFsS2V5KGV2ZW50LndoaWNoKSAmJiAoc2VsZi5vcHRpb25zLndhaXQgPT09IGZhbHNlIHx8IHNlbGYub3B0aW9ucy53YWl0ID49IDIwMCkpIHtcclxuXHRcdFx0Ly8gSGlkZSB2YWxpZGF0aW9uIHNwYW4gdGFnLlxyXG5cdFx0XHRzZWxmLnJlbW92ZUNsYXNzKHNlbGYuZ2V0R3JvdXBFbGVtZW50KHRoaXMpLCBzZWxmLm9wdGlvbnMuY29udHJvbEVycm9yQ2xhc3MpO1xyXG5cdFx0XHRzZWxmLnJlbW92ZUNsYXNzKHNlbGYuZ2V0R3JvdXBFbGVtZW50KHRoaXMpLCBzZWxmLm9wdGlvbnMuY29udHJvbFZhbGlkQ2xhc3MpO1xyXG5cclxuXHRcdFx0dmFyIG1lc3NhZ2VFbCA9IHNlbGYuZ2V0TWVzc2FnZUVsZW1lbnQodGhpcyk7XHJcblx0XHRcdG1lc3NhZ2VFbC5pbm5lckhUTUwgPSAnJztcclxuXHRcdFx0bWVzc2FnZUVsLmNsYXNzTmFtZSA9ICcnO1xyXG5cclxuXHRcdFx0Ly8gQ2FuY2VsIHRpbWVvdXQgdG8gcnVuIHZhbGlkYXRpb24gaGFuZGxlclxyXG5cdFx0XHRpZiAoc2VsZi50aW1lb3V0KSB7XHJcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHNlbGYudGltZW91dCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHROZXR0ZS5hZGRFdmVudChlbCwgXCJrZXl1cFwiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdFx0aWYgKHNlbGYub3B0aW9ucy53YWl0ICE9PSBmYWxzZSkge1xyXG5cdFx0XHRldmVudCA9IGV2ZW50IHx8IHdpbmRvdy5ldmVudDtcclxuXHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgIT09IDkpIHtcclxuXHRcdFx0XHRpZiAoc2VsZi50aW1lb3V0KSBjbGVhclRpbWVvdXQoc2VsZi50aW1lb3V0KTtcclxuXHRcdFx0XHRcdHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRoYW5kbGVyKGV2ZW50KTtcclxuXHRcdFx0XHR9LCBzZWxmLm9wdGlvbnMud2FpdCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuXHJcbkxpdmVGb3JtLnByb2Nlc3NTZXJ2ZXJFcnJvcnMgPSBmdW5jdGlvbihlbCkge1xyXG5cdHZhciBtZXNzYWdlRWwgPSB0aGlzLmdldE1lc3NhZ2VFbGVtZW50KGVsKTtcclxuXHR2YXIgcGFyZW50RWwgPSB0aGlzLmdldE1lc3NhZ2VQYXJlbnQoZWwpOyAvLyBUaGlzIGlzIHBhcmVudCBlbGVtZW50IHdoaWNoIGNvbnRhaW4gdGhlIGVycm9yIGVsZW1lbnRzXHJcblxyXG5cdHZhciBlcnJvcnMgPSBbXTtcclxuXHJcblx0Ly8gRmluZCBleGlzdGluZyBlcnJvciBlbGVtZW50cyBieSBjbGFzcyAoZnJvbSBzZXJ2ZXItdmFsaWRhdGlvbilcclxuXHR2YXIgZXJyb3JFbHMgPSBwYXJlbnRFbC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHRoaXMub3B0aW9ucy5tZXNzYWdlRXJyb3JDbGFzcyk7XHJcblx0Zm9yICh2YXIgaSA9IGVycm9yRWxzLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XHJcblx0XHQvLyBEb24ndCB0b3VjaCBvdXIgbWFpbiBtZXNzYWdlIGVsZW1lbnRcclxuXHRcdGlmIChlcnJvckVsc1tpXSA9PSBtZXNzYWdlRWwpXHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdC8vIFJlbW92ZSBvbmx5IGRpcmVjdCBjaGlsZHJlblxyXG5cdFx0dmFyIGVycm9yUGFyZW50ID0gZXJyb3JFbHNbaV0ucGFyZW50Tm9kZTtcclxuXHRcdGlmIChlcnJvclBhcmVudCA9PSBwYXJlbnRFbCkge1xyXG5cdFx0XHRlcnJvcnMucHVzaChlcnJvckVsc1tpXS5vdXRlckhUTUwpO1xyXG5cdFx0XHRlcnJvclBhcmVudC5yZW1vdmVDaGlsZChlcnJvckVsc1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBXcmFwIGFsbCBzZXJ2ZXIgZXJyb3JzIGludG8gb25lIGVsZW1lbnRcclxuXHRpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcclxuXHRcdG1lc3NhZ2VFbC5pbm5lckhUTUwgPSBlcnJvcnMuam9pbihcIlwiKTtcclxuXHR9XHJcbn07XHJcblxyXG5MaXZlRm9ybS5hZGRFcnJvciA9IGZ1bmN0aW9uKGVsLCBtZXNzYWdlKSB7XHJcblx0Ly8gSWdub3JlIGVsZW1lbnRzIHdpdGggZGlzYWJsZWQgbGl2ZSB2YWxpZGF0aW9uXHJcblx0aWYgKHRoaXMuaGFzQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5kaXNhYmxlTGl2ZVZhbGlkYXRpb25DbGFzcykpXHJcblx0XHRyZXR1cm47XHJcblxyXG5cdHZhciBncm91cEVsID0gdGhpcy5nZXRHcm91cEVsZW1lbnQoZWwpO1xyXG5cdHRoaXMuc2V0Rm9ybVByb3BlcnR5KGVsLmZvcm0sIFwiaGFzRXJyb3JcIiwgdHJ1ZSk7XHJcblx0dGhpcy5hZGRDbGFzcyhncm91cEVsLCB0aGlzLm9wdGlvbnMuY29udHJvbEVycm9yQ2xhc3MpO1xyXG5cclxuXHRpZiAodGhpcy5vcHRpb25zLnNob3dWYWxpZCkge1xyXG5cdFx0dGhpcy5yZW1vdmVDbGFzcyhncm91cEVsLCB0aGlzLm9wdGlvbnMuY29udHJvbFZhbGlkQ2xhc3MpO1xyXG5cdH1cclxuXHJcblx0aWYgKCFtZXNzYWdlKSB7XHJcblx0XHRtZXNzYWdlID0gJyZuYnNwOyc7XHJcblx0fSBlbHNlIHtcclxuXHRcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZUVycm9yUHJlZml4ICsgbWVzc2FnZTtcclxuXHR9XHJcblxyXG5cdHZhciBtZXNzYWdlRWwgPSB0aGlzLmdldE1lc3NhZ2VFbGVtZW50KGVsKTtcclxuXHRtZXNzYWdlRWwuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuXHRtZXNzYWdlRWwuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLm1lc3NhZ2VFcnJvckNsYXNzO1xyXG59O1xyXG5cclxuTGl2ZUZvcm0ucmVtb3ZlRXJyb3IgPSBmdW5jdGlvbihlbCkge1xyXG5cdC8vIFdlIGRvbid0IHdhbnQgdG8gcmVtb3ZlIGFueSBlcnJvcnMgZHVyaW5nIG9uTG9hZFZhbGlkYXRpb25cclxuXHRpZiAodGhpcy5nZXRGb3JtUHJvcGVydHkoZWwuZm9ybSwgXCJvbkxvYWRWYWxpZGF0aW9uXCIpKVxyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHR2YXIgZ3JvdXBFbCA9IHRoaXMuZ2V0R3JvdXBFbGVtZW50KGVsKTtcclxuXHR0aGlzLnJlbW92ZUNsYXNzKGdyb3VwRWwsIHRoaXMub3B0aW9ucy5jb250cm9sRXJyb3JDbGFzcyk7XHJcblxyXG5cdHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1sZnYtbWVzc2FnZS1pZCcpO1xyXG5cdGlmIChpZCkge1xyXG5cdFx0dmFyIG1lc3NhZ2VFbCA9IHRoaXMuZ2V0TWVzc2FnZUVsZW1lbnQoZWwpO1xyXG5cdFx0bWVzc2FnZUVsLmlubmVySFRNTCA9ICcnO1xyXG5cdFx0bWVzc2FnZUVsLmNsYXNzTmFtZSA9ICcnO1xyXG5cdH1cclxuXHJcblx0aWYgKHRoaXMub3B0aW9ucy5zaG93VmFsaWQpIHtcclxuXHRcdGlmICh0aGlzLnNob3dWYWxpZChlbCkpXHJcblx0XHRcdHRoaXMuYWRkQ2xhc3MoZ3JvdXBFbCwgdGhpcy5vcHRpb25zLmNvbnRyb2xWYWxpZENsYXNzKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5yZW1vdmVDbGFzcyhncm91cEVsLCB0aGlzLm9wdGlvbnMuY29udHJvbFZhbGlkQ2xhc3MpO1xyXG5cdH1cclxufTtcclxuXHJcbkxpdmVGb3JtLnNob3dWYWxpZCA9IGZ1bmN0aW9uKGVsKSB7XHJcblx0aWYgKGVsLnR5cGUpIHtcclxuXHRcdHZhciB0eXBlID0gZWwudHlwZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0aWYgKHR5cGUgPT0gJ2NoZWNrYm94JyB8fCB0eXBlID09ICdyYWRpbycpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIHJ1bGVzID0gTmV0dGUucGFyc2VKU09OKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXR0ZS1ydWxlcycpKTtcclxuXHRpZiAocnVsZXMubGVuZ3RoID09IDApIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbiAgXHJcblx0aWYgKE5ldHRlLmdldEVmZmVjdGl2ZVZhbHVlKGVsKSA9PSAnJykge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0aWYgKHRoaXMuaGFzQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5kaXNhYmxlU2hvd1ZhbGlkQ2xhc3MpKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkxpdmVGb3JtLmdldEdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uKGVsKSB7XHJcblx0aWYgKHRoaXMub3B0aW9ucy5zaG93TWVzc2FnZUNsYXNzT25QYXJlbnQgPT09IGZhbHNlKVxyXG5cdFx0cmV0dXJuIGVsO1xyXG5cclxuXHR2YXIgZ3JvdXBFbCA9IGVsO1xyXG5cclxuXHR3aGlsZSAoIXRoaXMuaGFzQ2xhc3MoZ3JvdXBFbCwgdGhpcy5vcHRpb25zLnNob3dNZXNzYWdlQ2xhc3NPblBhcmVudCkpIHtcclxuXHRcdGdyb3VwRWwgPSBncm91cEVsLnBhcmVudE5vZGU7XHJcblxyXG5cdFx0aWYgKGdyb3VwRWwgPT09IG51bGwpIHtcclxuXHRcdFx0cmV0dXJuIGVsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGdyb3VwRWw7XHJcbn1cclxuXHJcbkxpdmVGb3JtLmdldE1lc3NhZ2VJZCA9IGZ1bmN0aW9uKGVsKSB7XHJcblx0dmFyIHRtcCA9IGVsLmlkICsgdGhpcy5vcHRpb25zLm1lc3NhZ2VJZFBvc3RmaXg7XHJcblx0XHJcblx0Ly8gRm9yIGVsZW1lbnRzIHdpdGhvdXQgSUQsIG9yIG11bHRpIGVsZW1lbnRzICh3aXRoIHNhbWUgbmFtZSksIHdlIG11c3QgZ2VuZXJhdGUgd2hvbGUgSUQgb3Vyc2VsdmVzXHJcblx0aWYgKGVsLm5hbWUgJiYgKCFlbC5pZCB8fCAhZWwuZm9ybS5lbGVtZW50c1tlbC5uYW1lXS50YWdOYW1lKSkge1xyXG5cdFx0Ly8gU3RyaXAgcG9zc2libGUgW10gZnJvbSBuYW1lXHJcblx0XHR2YXIgbmFtZSA9IGVsLm5hbWUubWF0Y2goL1xcW1xcXSQvKSA/IGVsLm5hbWUubWF0Y2goLyguKilcXFtcXF0kLylbMV0gOiBlbC5uYW1lO1xyXG5cdFx0Ly8gR2VuZXJhdGUgbmV3IElEIGJhc2VkIG9uIGZvcm0gSUQsIGVsZW1lbnQgbmFtZSBhbmQgbWVzc2FnZUlkUG9zdGZpeCBmcm9tIG9wdGlvbnNcclxuXHRcdHRtcCA9IChlbC5mb3JtLmlkID8gZWwuZm9ybS5pZCA6ICdmcm0nKSArICctJyArIG5hbWUgKyB0aGlzLm9wdGlvbnMubWVzc2FnZUlkUG9zdGZpeDtcclxuXHR9XHJcblx0XHJcblx0Ly8gV2Ugd2FudCB1bmlxdWUgSUQgd2hpY2ggZG9lc24ndCBleGlzdCB5ZXRcclxuXHR2YXIgaWQgPSB0bXAsXHJcblx0ICAgIGkgPSAwO1xyXG5cdHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpIHtcclxuXHRcdGlkID0gaWQgKyAnXycgKyArK2k7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaWQ7XHJcbn1cclxuXHJcbkxpdmVGb3JtLmdldE1lc3NhZ2VFbGVtZW50ID0gZnVuY3Rpb24oZWwpIHtcclxuXHQvLyBGb3IgbXVsdGkgZWxlbWVudHMgKHdpdGggc2FtZSBuYW1lKSB3b3JrIG9ubHkgd2l0aCBmaXJzdCBlbGVtZW50IGF0dHJpYnV0ZXNcclxuXHRpZiAoZWwubmFtZSAmJiBlbC5uYW1lLm1hdGNoKC9cXFtcXF0kLykpIHtcclxuXHRcdGVsID0gZWwuZm9ybS5lbGVtZW50c1tlbC5uYW1lXS50YWdOYW1lID8gZWwgOiBlbC5mb3JtLmVsZW1lbnRzW2VsLm5hbWVdWzBdO1xyXG5cdH1cclxuXHJcblx0dmFyIGlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWxmdi1tZXNzYWdlLWlkJyk7XHJcblx0aWYgKCFpZCkge1xyXG5cdFx0Ly8gSUQgaXMgbm90IHNwZWNpZmllZCB5ZXQsIGxldCdzIGNyZWF0ZSBhIG5ldyBvbmVcclxuXHRcdGlkID0gdGhpcy5nZXRNZXNzYWdlSWQoZWwpO1xyXG5cclxuXHRcdC8vIFJlbWVtYmVyIHRoaXMgaWQgZm9yIG5leHQgdXNlXHJcblx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGZ2LW1lc3NhZ2UtaWQnLCBpZCk7XHJcblx0fVxyXG5cclxuXHR2YXIgbWVzc2FnZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG5cdGlmICghbWVzc2FnZUVsKSB7XHJcblx0XHQvLyBNZXNzYWdlIGVsZW1lbnQgZG9lc24ndCBleGlzdCwgbGV0cyBjcmVhdGUgYSBuZXcgb25lXHJcblx0XHRtZXNzYWdlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5tZXNzYWdlVGFnKTtcclxuXHRcdG1lc3NhZ2VFbC5pZCA9IGlkO1xyXG5cdFx0aWYgKGVsLnN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnICYmICF0aGlzLmhhc0NsYXNzKGVsLCB0aGlzLm9wdGlvbnMuZW5hYmxlSGlkZGVuTWVzc2FnZUNsYXNzKSkge1xyXG5cdFx0XHRtZXNzYWdlRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFyZW50RWwgPSB0aGlzLmdldE1lc3NhZ2VQYXJlbnQoZWwpO1xyXG5cdFx0aWYgKHBhcmVudEVsID09PSBlbC5wYXJlbnROb2RlKSB7XHJcblx0XHRcdHBhcmVudEVsLmluc2VydEJlZm9yZShtZXNzYWdlRWwsIGVsLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSBpZihwYXJlbnRFbCkge1xyXG5cdFx0XHRwYXJlbnRFbC5hcHBlbmQobWVzc2FnZUVsKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBtZXNzYWdlRWw7XHJcbn07XHJcblxyXG5MaXZlRm9ybS5nZXRNZXNzYWdlUGFyZW50ID0gZnVuY3Rpb24oZWwpIHtcclxuXHR2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdHZhciBwYXJlbnRGb3VuZCA9IGZhbHNlO1xyXG5cdFxyXG5cdGlmICh0aGlzLm9wdGlvbnMubWVzc2FnZVBhcmVudENsYXNzICE9PSBmYWxzZSkge1xyXG5cdFx0cGFyZW50Rm91bmQgPSB0cnVlO1xyXG5cdFx0d2hpbGUgKCF0aGlzLmhhc0NsYXNzKHBhcmVudEVsLCB0aGlzLm9wdGlvbnMubWVzc2FnZVBhcmVudENsYXNzKSkge1xyXG5cdFx0XHRwYXJlbnRFbCA9IHBhcmVudEVsLnBhcmVudE5vZGU7XHJcblxyXG5cdFx0XHRpZiAocGFyZW50RWwgPT09IG51bGwpIHtcclxuXHRcdFx0XHQvLyBXZSBkaWRuJ3QgZm91bmQgd2FudGVkIHBhcmVudCwgc28gdXNlIGVsZW1lbnQncyBkaXJlY3QgcGFyZW50XHJcblx0XHRcdFx0cGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdHBhcmVudEZvdW5kID0gZmFsc2U7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIERvbid0IGFwcGVuZCBlcnJvciBtZXNzYWdlIHRvIHJhZGlvL2NoZWNrYm94IGlucHV0J3MgbGFiZWwsIGJ1dCBhbG9uZyBsYWJlbFxyXG5cdGlmIChlbC50eXBlKSB7XHJcblx0XHR2YXIgdHlwZSA9IGVsLnR5cGUudG9Mb3dlckNhc2UoKTtcclxuXHRcdGlmICgodHlwZSA9PSAnY2hlY2tib3gnIHx8IHR5cGUgPT0gJ3JhZGlvJykgJiYgcGFyZW50RWwudGFnTmFtZSA9PSAnTEFCRUwnKSB7XHJcblx0XHRcdHBhcmVudEVsID0gcGFyZW50RWwucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEZvciBtdWx0aSBlbGVtZW50cyAod2l0aCBzYW1lIG5hbWUpIHVzZSBwYXJlbnQncyBwYXJlbnQgYXMgcGFyZW50IChpZiB3YW50ZWQgb25lIGlzIG5vdCBmb3VuZClcclxuXHRpZiAoIXBhcmVudEZvdW5kICYmIGVsLm5hbWUgJiYgIWVsLmZvcm0uZWxlbWVudHNbZWwubmFtZV0udGFnTmFtZSkge1xyXG5cdFx0cGFyZW50RWwgPSBwYXJlbnRFbC5wYXJlbnROb2RlOyBcclxuXHR9XHJcblxyXG5cdHJldHVybiBwYXJlbnRFbDtcclxufVxyXG5cclxuTGl2ZUZvcm0uYWRkQ2xhc3MgPSBmdW5jdGlvbihlbCwgY2xhc3NOYW1lKSB7XHJcblx0aWYgKCFlbC5jbGFzc05hbWUpIHtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuXHR9IGVsc2UgaWYgKCF0aGlzLmhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XHJcblx0XHRlbC5jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lO1xyXG5cdH1cclxufTtcclxuXHJcbkxpdmVGb3JtLmhhc0NsYXNzID0gZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xyXG5cdGlmIChlbC5jbGFzc05hbWUpXHJcblx0XHRyZXR1cm4gZWwuY2xhc3NOYW1lLm1hdGNoKG5ldyBSZWdFeHAoJyhcXFxcc3xeKScgKyBjbGFzc05hbWUgKyAnKFxcXFxzfCQpJykpO1xyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkxpdmVGb3JtLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWwsIGNsYXNzTmFtZSkge1xyXG5cdGlmICh0aGlzLmhhc0NsYXNzKGVsLCBjbGFzc05hbWUpKSB7XHJcblx0XHR2YXIgcmVnID0gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJysgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpO1xyXG5cdFx0dmFyIG0gPSBlbC5jbGFzc05hbWUubWF0Y2gocmVnKTtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZywgKG1bMV0gPT0gJyAnICYmIG1bMl0gPT0gJyAnKSA/ICcgJyA6ICcnKTtcclxuXHR9XHJcbn07XHJcblxyXG5MaXZlRm9ybS5nZXRGb3JtUHJvcGVydHkgPSBmdW5jdGlvbihmb3JtLCBwcm9wZXJ0eU5hbWUpIHtcclxuXHRpZiAoZm9ybSA9PSBudWxsIHx8IHRoaXMuZm9ybXNbZm9ybS5pZF0gPT0gbnVsbClcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0cmV0dXJuIHRoaXMuZm9ybXNbZm9ybS5pZF1bcHJvcGVydHlOYW1lXTtcclxufTtcclxuXHJcbkxpdmVGb3JtLnNldEZvcm1Qcm9wZXJ0eSA9IGZ1bmN0aW9uKGZvcm0sIHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcclxuXHRpZiAoZm9ybSA9PSBudWxsKVxyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHRpZiAodGhpcy5mb3Jtc1tmb3JtLmlkXSA9PSBudWxsKVxyXG5cdFx0dGhpcy5mb3Jtc1tmb3JtLmlkXSA9IHt9O1xyXG5cclxuXHR0aGlzLmZvcm1zW2Zvcm0uaWRdW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcclxufTtcclxuXHJcbnJldHVybiBMaXZlRm9ybTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICBtb2RpZmllZCBuZXR0ZUZvcm1zLmpzICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbi8qKlxyXG4gKiBOZXR0ZUZvcm1zIC0gc2ltcGxlIGZvcm0gdmFsaWRhdGlvbi5cclxuICpcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIE5ldHRlIEZyYW1ld29yayAoaHR0cHM6Ly9uZXR0ZS5vcmcpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwNCBEYXZpZCBHcnVkbCAoaHR0cHM6Ly9kYXZpZGdydWRsLmNvbSlcclxuICovXHJcblxyXG4vLyBMaXZlRm9ybTogb3JpZ2luYWwgbmV0dGVGb3Jtcy5qcyBjb2RlXHJcbi8qXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHRpZiAoIWdsb2JhbC5KU09OKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBmYWN0b3J5KGdsb2JhbCk7XHJcblx0XHR9KTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgaW5pdCA9ICFnbG9iYWwuTmV0dGUgfHwgIWdsb2JhbC5OZXR0ZS5ub0luaXQ7XHJcblx0XHRnbG9iYWwuTmV0dGUgPSBmYWN0b3J5KGdsb2JhbCk7XHJcblx0XHRpZiAoaW5pdCkge1xyXG5cdFx0XHRnbG9iYWwuTmV0dGUuaW5pdE9uTG9hZCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcbn0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbih3aW5kb3cpIHtcclxuKi9cclxuXHJcbi8vIExpdmVGb3JtOiBhZGRpdGlvblxyXG59LCBmdW5jdGlvbiAod2luZG93KSB7XHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBOZXR0ZSA9IHt9O1xyXG5cclxuLy8gTGl2ZUZvcm06IG9yaWdpbmFsIG5ldHRlRm9ybXMuanMgY29kZVxyXG4vLyBOZXR0ZS5mb3JtRXJyb3JzID0gW107XHJcbk5ldHRlLnZlcnNpb24gPSAnMi40JztcclxuXHJcblxyXG4vKipcclxuICogQXR0YWNoZXMgYSBoYW5kbGVyIHRvIGFuIGV2ZW50IGZvciB0aGUgZWxlbWVudC5cclxuICovXHJcbk5ldHRlLmFkZEV2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgb24sIGNhbGxiYWNrKSB7XHJcblx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG5cdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKG9uLCBjYWxsYmFjayk7XHJcblx0fSBlbHNlIGlmIChvbiA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnKSB7XHJcblx0XHRlbGVtZW50LmF0dGFjaEV2ZW50KCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKGVsZW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBvbiwgZ2V0SGFuZGxlcihjYWxsYmFjaykpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBnZXRIYW5kbGVyKGNhbGxiYWNrKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKGUpIHtcclxuXHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGUpO1xyXG5cdH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgZm9ybSBlbGVtZW50LlxyXG4gKi9cclxuTmV0dGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihlbGVtKSB7XHJcblx0dmFyIGk7XHJcblx0aWYgKCFlbGVtKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0fSBlbHNlIGlmICghZWxlbS50YWdOYW1lKSB7IC8vIFJhZGlvTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uLCBhcnJheVxyXG5cdFx0cmV0dXJuIGVsZW1bMF0gPyBOZXR0ZS5nZXRWYWx1ZShlbGVtWzBdKSA6IG51bGw7XHJcblxyXG5cdH0gZWxzZSBpZiAoZWxlbS50eXBlID09PSAncmFkaW8nKSB7XHJcblx0XHR2YXIgZWxlbWVudHMgPSBlbGVtLmZvcm0uZWxlbWVudHM7IC8vIHByZXZlbnRzIHByb2JsZW0gd2l0aCBuYW1lICdpdGVtJyBvciAnbmFtZWRJdGVtJ1xyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChlbGVtZW50c1tpXS5uYW1lID09PSBlbGVtLm5hbWUgJiYgZWxlbWVudHNbaV0uY2hlY2tlZCkge1xyXG5cdFx0XHRcdHJldHVybiBlbGVtZW50c1tpXS52YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdH0gZWxzZSBpZiAoZWxlbS50eXBlID09PSAnZmlsZScpIHtcclxuXHRcdHJldHVybiBlbGVtLmZpbGVzIHx8IGVsZW0udmFsdWU7XHJcblxyXG5cdH0gZWxzZSBpZiAoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XHJcblx0XHR2YXIgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXHJcblx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcblx0XHRcdHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdGlmIChlbGVtLnR5cGUgPT09ICdzZWxlY3Qtb25lJykge1xyXG5cdFx0XHRyZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG9wdGlvbnNbaW5kZXhdLnZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChvcHRpb25zW2ldLnNlbGVjdGVkKSB7XHJcblx0XHRcdFx0dmFsdWVzLnB1c2gob3B0aW9uc1tpXS52YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblxyXG5cdH0gZWxzZSBpZiAoZWxlbS5uYW1lICYmIGVsZW0ubmFtZS5tYXRjaCgvXFxbXFxdJC8pKSB7IC8vIG11bHRpcGxlIGVsZW1lbnRzIFtdXHJcblx0XHR2YXIgZWxlbWVudHMgPSBlbGVtLmZvcm0uZWxlbWVudHNbZWxlbS5uYW1lXS50YWdOYW1lID8gW2VsZW1dIDogZWxlbS5mb3JtLmVsZW1lbnRzW2VsZW0ubmFtZV0sXHJcblx0XHRcdHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHQvLyBMaXZlRm9ybTogb3JpZ2luYWwgbmV0dGVGb3Jtcy5qcyBjb2RlXHJcblx0XHRcdC8qaWYgKGVsZW1lbnRzW2ldLnR5cGUgIT09ICdjaGVja2JveCcgfHwgZWxlbWVudHNbaV0uY2hlY2tlZCkge1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKGVsZW1lbnRzW2ldLnZhbHVlKTtcclxuXHRcdFx0fSovXHJcblx0XHRcdC8vIExpdmVGb3JtOiBhZGRpdGlvblxyXG5cdFx0XHR2YXIgdmFsdWUgPSBlbGVtZW50c1tpXS52YWx1ZTtcclxuXHRcdFx0aWYgKGVsZW1lbnRzW2ldLnR5cGUgPT09ICdjaGVja2JveCcgJiYgZWxlbWVudHNbaV0uY2hlY2tlZCkge1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIGlmIChlbGVtZW50c1tpXS50eXBlICE9PSAnY2hlY2tib3gnICYmIHZhbHVlICE9PSAnJykge1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKHZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHJcblx0fSBlbHNlIGlmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuXHRcdHJldHVybiBlbGVtLmNoZWNrZWQ7XHJcblxyXG5cdH0gZWxzZSBpZiAoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScpIHtcclxuXHRcdHJldHVybiBlbGVtLnZhbHVlLnJlcGxhY2UoXCJcXHJcIiwgJycpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGVsZW0udmFsdWUucmVwbGFjZShcIlxcclwiLCAnJykucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIHZhbHVlIG9mIGZvcm0gZWxlbWVudC5cclxuICovXHJcbk5ldHRlLmdldEVmZmVjdGl2ZVZhbHVlID0gZnVuY3Rpb24oZWxlbSkge1xyXG5cdHZhciB2YWwgPSBOZXR0ZS5nZXRWYWx1ZShlbGVtKTtcclxuXHRpZiAoZWxlbS5nZXRBdHRyaWJ1dGUpIHtcclxuXHRcdGlmICh2YWwgPT09IGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLW5ldHRlLWVtcHR5LXZhbHVlJykpIHtcclxuXHRcdFx0dmFsID0gJyc7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiB2YWw7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBmb3JtIGVsZW1lbnQgYWdhaW5zdCBnaXZlbiBydWxlcy5cclxuICovXHJcbk5ldHRlLnZhbGlkYXRlQ29udHJvbCA9IGZ1bmN0aW9uKGVsZW0sIHJ1bGVzLCBvbmx5Q2hlY2ssIHZhbHVlLCBlbXB0eU9wdGlvbmFsKSB7XHJcblx0Ly8gTGl2ZUZvcm06IGFkZGl0aW9uXHJcblx0Ly8gRml4IGZvciBDaGVja2JveExpc3QgLSB2YWxpZGF0aW9uIHJ1bGVzIGFyZSBwcmVzZW50IGFsd2F5cyBvbmx5IG9uIGZpcnN0IGlucHV0XHJcblx0aWYgKGVsZW0ubmFtZSAmJiBlbGVtLm5hbWUubWF0Y2goL1xcW1xcXSQvKSAmJiBlbGVtLnR5cGUudG9Mb3dlckNhc2UoKSA9PSAnY2hlY2tib3gnKSB7XHJcblx0XHRlbGVtID0gZWxlbS5mb3JtLmVsZW1lbnRzW2VsZW0ubmFtZV0udGFnTmFtZSA/IGVsZW0gOiBlbGVtLmZvcm0uZWxlbWVudHNbZWxlbS5uYW1lXVswXTtcclxuXHR9XHJcblx0XHJcblx0ZWxlbSA9IGVsZW0udGFnTmFtZSA/IGVsZW0gOiBlbGVtWzBdOyAvLyBSYWRpb05vZGVMaXN0XHJcblx0cnVsZXMgPSBydWxlcyB8fCBOZXR0ZS5wYXJzZUpTT04oZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV0dGUtcnVsZXMnKSk7XHJcblx0dmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8ge3ZhbHVlOiBOZXR0ZS5nZXRFZmZlY3RpdmVWYWx1ZShlbGVtKX0gOiB2YWx1ZTtcclxuXHJcblx0Zm9yICh2YXIgaWQgPSAwLCBsZW4gPSBydWxlcy5sZW5ndGg7IGlkIDwgbGVuOyBpZCsrKSB7XHJcblx0XHR2YXIgcnVsZSA9IHJ1bGVzW2lkXSxcclxuXHRcdFx0b3AgPSBydWxlLm9wLm1hdGNoKC8ofik/KFteP10rKS8pLFxyXG5cdFx0XHRjdXJFbGVtID0gcnVsZS5jb250cm9sID8gZWxlbS5mb3JtLmVsZW1lbnRzLm5hbWVkSXRlbShydWxlLmNvbnRyb2wpIDogZWxlbTtcclxuXHJcblx0XHRydWxlLm5lZyA9IG9wWzFdO1xyXG5cdFx0cnVsZS5vcCA9IG9wWzJdO1xyXG5cdFx0cnVsZS5jb25kaXRpb24gPSAhIXJ1bGUucnVsZXM7XHJcblxyXG5cdFx0aWYgKCFjdXJFbGVtKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fSBlbHNlIGlmIChydWxlLm9wID09PSAnb3B0aW9uYWwnKSB7XHJcblx0XHRcdGVtcHR5T3B0aW9uYWwgPSAhTmV0dGUudmFsaWRhdGVSdWxlKGVsZW0sICc6ZmlsbGVkJywgbnVsbCwgdmFsdWUpO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH0gZWxzZSBpZiAoZW1wdHlPcHRpb25hbCAmJiAhcnVsZS5jb25kaXRpb24gJiYgcnVsZS5vcCAhPT0gJzpmaWxsZWQnKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGN1ckVsZW0gPSBjdXJFbGVtLnRhZ05hbWUgPyBjdXJFbGVtIDogY3VyRWxlbVswXTsgLy8gUmFkaW9Ob2RlTGlzdFxyXG5cdFx0dmFyIGN1clZhbHVlID0gZWxlbSA9PT0gY3VyRWxlbSA/IHZhbHVlIDoge3ZhbHVlOiBOZXR0ZS5nZXRFZmZlY3RpdmVWYWx1ZShjdXJFbGVtKX0sXHJcblx0XHRcdHN1Y2Nlc3MgPSBOZXR0ZS52YWxpZGF0ZVJ1bGUoY3VyRWxlbSwgcnVsZS5vcCwgcnVsZS5hcmcsIGN1clZhbHVlKTtcclxuXHJcblx0XHRpZiAoc3VjY2VzcyA9PT0gbnVsbCkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH0gZWxzZSBpZiAocnVsZS5uZWcpIHtcclxuXHRcdFx0c3VjY2VzcyA9ICFzdWNjZXNzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChydWxlLmNvbmRpdGlvbiAmJiBzdWNjZXNzKSB7XHJcblx0XHRcdGlmICghTmV0dGUudmFsaWRhdGVDb250cm9sKGVsZW0sIHJ1bGUucnVsZXMsIG9ubHlDaGVjaywgdmFsdWUsIHJ1bGUub3AgPT09ICc6YmxhbmsnID8gZmFsc2UgOiBlbXB0eU9wdGlvbmFsKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICghcnVsZS5jb25kaXRpb24gJiYgIXN1Y2Nlc3MpIHtcclxuXHRcdFx0aWYgKE5ldHRlLmlzRGlzYWJsZWQoY3VyRWxlbSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIW9ubHlDaGVjaykge1xyXG5cdFx0XHRcdHZhciBhcnIgPSBOZXR0ZS5pc0FycmF5KHJ1bGUuYXJnKSA/IHJ1bGUuYXJnIDogW3J1bGUuYXJnXSxcclxuXHRcdFx0XHRcdG1lc3NhZ2UgPSBydWxlLm1zZy5yZXBsYWNlKC8lKHZhbHVlfFxcZCspL2csIGZ1bmN0aW9uKGZvbywgbSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gTmV0dGUuZ2V0VmFsdWUobSA9PT0gJ3ZhbHVlJyA/IGN1ckVsZW0gOiBlbGVtLmZvcm0uZWxlbWVudHMubmFtZWRJdGVtKGFyclttXS5jb250cm9sKSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHROZXR0ZS5hZGRFcnJvcihjdXJFbGVtLCBtZXNzYWdlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJyAmJiAhZWxlbS52YWxpZGl0eS52YWxpZCkge1xyXG5cdFx0aWYgKCFvbmx5Q2hlY2spIHtcclxuXHRcdFx0TmV0dGUuYWRkRXJyb3IoZWxlbSwgJ1BsZWFzZSBlbnRlciBhIHZhbGlkIHZhbHVlLicpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gTGl2ZUZvcm06IGFkZGl0aW9uXHJcblx0aWYgKCFvbmx5Q2hlY2spIHtcclxuXHRcdExpdmVGb3JtLnJlbW92ZUVycm9yKGVsZW0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB3aG9sZSBmb3JtLlxyXG4gKi9cclxuTmV0dGUudmFsaWRhdGVGb3JtID0gZnVuY3Rpb24oc2VuZGVyLCBvbmx5Q2hlY2spIHtcclxuXHR2YXIgZm9ybSA9IHNlbmRlci5mb3JtIHx8IHNlbmRlcixcclxuXHRcdHNjb3BlID0gZmFsc2U7XHJcblxyXG5cdC8vIExpdmVGb3JtOiBhZGRpdGlvblxyXG5cdExpdmVGb3JtLnNldEZvcm1Qcm9wZXJ0eShmb3JtLCBcImhhc0Vycm9yXCIsIGZhbHNlKTtcclxuXHJcblx0Ly8gTGl2ZUZvcm06IG9yaWdpbmFsIG5ldHRlRm9ybXMuanMgY29kZVxyXG5cdC8vIE5ldHRlLmZvcm1FcnJvcnMgPSBbXTtcclxuXHJcblx0aWYgKGZvcm1bJ25ldHRlLXN1Ym1pdHRlZEJ5J10gJiYgZm9ybVsnbmV0dGUtc3VibWl0dGVkQnknXS5nZXRBdHRyaWJ1dGUoJ2Zvcm1ub3ZhbGlkYXRlJykgIT09IG51bGwpIHtcclxuXHRcdHZhciBzY29wZUFyciA9IE5ldHRlLnBhcnNlSlNPTihmb3JtWyduZXR0ZS1zdWJtaXR0ZWRCeSddLmdldEF0dHJpYnV0ZSgnZGF0YS1uZXR0ZS12YWxpZGF0aW9uLXNjb3BlJykpO1xyXG5cdFx0aWYgKHNjb3BlQXJyLmxlbmd0aCkge1xyXG5cdFx0XHRzY29wZSA9IG5ldyBSZWdFeHAoJ14oJyArIHNjb3BlQXJyLmpvaW4oJy18JykgKyAnLSknKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGVcclxuXHRcdFx0Ly8gTmV0dGUuc2hvd0Zvcm1FcnJvcnMoZm9ybSwgW10pO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHZhciByYWRpb3MgPSB7fSwgaSwgZWxlbTtcclxuXHQvLyBMaXZlRm9ybTogYWRkaXRpb25cclxuXHR2YXIgc3VjY2VzcyA9IHRydWU7XHJcblxyXG5cdGZvciAoaSA9IDA7IGkgPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRlbGVtID0gZm9ybS5lbGVtZW50c1tpXTtcclxuXHJcblx0XHRpZiAoZWxlbS50YWdOYW1lICYmICEoZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgaW4ge2lucHV0OiAxLCBzZWxlY3Q6IDEsIHRleHRhcmVhOiAxLCBidXR0b246IDF9KSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKGVsZW0udHlwZSA9PT0gJ3JhZGlvJykge1xyXG5cdFx0XHRpZiAocmFkaW9zW2VsZW0ubmFtZV0pIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyYWRpb3NbZWxlbS5uYW1lXSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKChzY29wZSAmJiAhZWxlbS5uYW1lLnJlcGxhY2UoL11cXFt8XFxbfF18JC9nLCAnLScpLm1hdGNoKHNjb3BlKSkgfHwgTmV0dGUuaXNEaXNhYmxlZChlbGVtKSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBMaXZlRm9ybTogYWRkaXRpb25cclxuXHRcdHN1Y2Nlc3MgPSBOZXR0ZS52YWxpZGF0ZUNvbnRyb2woZWxlbSkgJiYgc3VjY2VzcztcclxuXHRcdGlmICghc3VjY2VzcyAmJiAhTGl2ZUZvcm0ub3B0aW9ucy5zaG93QWxsRXJyb3JzKSB7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0Ly8gTGl2ZUZvcm06IG9yaWdpbmFsIG5ldHRlRm9ybXMuanMgY29kZVxyXG5cdFx0LyppZiAoIU5ldHRlLnZhbGlkYXRlQ29udHJvbChlbGVtLCBudWxsLCBvbmx5Q2hlY2spICYmICFOZXR0ZS5mb3JtRXJyb3JzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9Ki9cclxuXHR9XHJcblx0Ly8gTGl2ZUZvcm06IGNoYW5nZVxyXG5cdHJldHVybiBzdWNjZXNzO1xyXG5cclxuXHQvLyBMaXZlRm9ybTogb3JpZ2luYWwgbmV0dGVGb3Jtcy5qcyBjb2RlXHJcblx0Lyp2YXIgc3VjY2VzcyA9ICFOZXR0ZS5mb3JtRXJyb3JzLmxlbmd0aDtcclxuXHROZXR0ZS5zaG93Rm9ybUVycm9ycyhmb3JtLCBOZXR0ZS5mb3JtRXJyb3JzKTtcclxuXHRyZXR1cm4gc3VjY2VzczsqL1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBpbnB1dCBpcyBkaXNhYmxlZC5cclxuICovXHJcbk5ldHRlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbihlbGVtKSB7XHJcblx0aWYgKGVsZW0udHlwZSA9PT0gJ3JhZGlvJykge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGVsZW1lbnRzID0gZWxlbS5mb3JtLmVsZW1lbnRzOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKGVsZW1lbnRzW2ldLm5hbWUgPT09IGVsZW0ubmFtZSAmJiAhZWxlbWVudHNbaV0uZGlzYWJsZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZWxlbS5kaXNhYmxlZDtcclxufTtcclxuXHJcbi8vIExpdmVGb3JtOiBjaGFuZ2VcclxuLyoqXHJcbiAqIERpc3BsYXkgZXJyb3IgbWVzc2FnZS5cclxuICovXHJcbk5ldHRlLmFkZEVycm9yID0gZnVuY3Rpb24oZWxlbSwgbWVzc2FnZSkge1xyXG5cdC8vIExpdmVGb3JtOiBhZGRpdGlvblxyXG5cdHZhciBub0xpdmVWYWxpZGF0aW9uID0gTGl2ZUZvcm0uaGFzQ2xhc3MoZWxlbSwgTGl2ZUZvcm0ub3B0aW9ucy5kaXNhYmxlTGl2ZVZhbGlkYXRpb25DbGFzcyk7XHJcblx0Ly8gVXNlciBleHBsaWNpdGx5IGRpc2FibGVkIGxpdmUtdmFsaWRhdGlvbiBzbyB3ZSB3YW50IHRvIHNob3cgc2ltcGxlIGFsZXJ0c1xyXG5cdGlmIChub0xpdmVWYWxpZGF0aW9uKSB7XHJcblx0XHQvLyBub3RpZnkgZXJyb3JzIGZvciBlbGVtZW50cyB3aXRoIGRpc2FibGVkIGxpdmUgdmFsaWRhdGlvbiAoYnV0IG9ubHkgZXJyb3JzIGFuZCBub3QgZHVyaW5nIG9uTG9hZFZhbGlkYXRpb24pXHJcblx0XHRpZiAobWVzc2FnZSAmJiAhTGl2ZUZvcm0uZ2V0Rm9ybVByb3BlcnR5KGVsZW0uZm9ybSwgXCJoYXNFcnJvclwiKSAmJiAhTGl2ZUZvcm0uZ2V0Rm9ybVByb3BlcnR5KGVsZW0uZm9ybSwgXCJvbkxvYWRWYWxpZGF0aW9uXCIpKSB7XHJcblx0XHRcdGFsZXJ0KG1lc3NhZ2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoZWxlbS5mb2N1cyAmJiAhTGl2ZUZvcm0uZ2V0Rm9ybVByb3BlcnR5KGVsZW0uZm9ybSwgXCJoYXNFcnJvclwiKSkge1xyXG5cdFx0aWYgKCFMaXZlRm9ybS5mb2N1c2luZykge1xyXG5cdFx0XHRMaXZlRm9ybS5mb2N1c2luZyA9IHRydWU7XHJcblx0XHRcdGVsZW0uZm9jdXMoKTtcclxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRMaXZlRm9ybS5mb2N1c2luZyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHQvLyBTY3JvbGwgYnkgZGVmaW5lZCBvZmZzZXQgKGlmIGVuYWJsZWQpXHJcblx0XHRcdFx0Ly8gTk9URTogV2UgdXNlIGl0IHdpdGggc2V0VGltZXRvdXQgYmVjYXVzZSBJRTkgZG9lc24ndCBhbHdheXMgY2F0Y2ggaW5zdGFudCBzY3JvbGxUbyByZXF1ZXN0XHJcblx0XHRcdFx0dmFyIGZvY3VzT2Zmc2V0WSA9IExpdmVGb3JtLm9wdGlvbnMuZm9jdXNTY3JlZW5PZmZzZXRZO1xyXG5cdFx0XHRcdGlmIChmb2N1c09mZnNldFkgIT09IGZhbHNlICYmIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDwgZm9jdXNPZmZzZXRZKSB7XHJcblx0XHRcdFx0XHR3aW5kb3cuc2Nyb2xsQnkoMCwgZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBmb2N1c09mZnNldFkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMTApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIW5vTGl2ZVZhbGlkYXRpb24pIHtcclxuXHRcdExpdmVGb3JtLmFkZEVycm9yKGVsZW0sIG1lc3NhZ2UpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vLyBMaXZlRm9ybTogb3JpZ2luYWwgbmV0dGVGb3Jtcy5qcyBjb2RlXHJcbi8qKlxyXG4gKiBBZGRzIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHF1ZXVlLlxyXG4gKi9cclxuLypOZXR0ZS5hZGRFcnJvciA9IGZ1bmN0aW9uKGVsZW0sIG1lc3NhZ2UpIHtcclxuXHROZXR0ZS5mb3JtRXJyb3JzLnB1c2goe1xyXG5cdFx0ZWxlbWVudDogZWxlbSxcclxuXHRcdG1lc3NhZ2U6IG1lc3NhZ2VcclxuXHR9KTtcclxufTsqL1xyXG5cclxuXHJcbi8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGVcclxuLyoqXHJcbiAqIERpc3BsYXkgZXJyb3IgbWVzc2FnZXMuXHJcbiAqL1xyXG4vKk5ldHRlLnNob3dGb3JtRXJyb3JzID0gZnVuY3Rpb24oZm9ybSwgZXJyb3JzKSB7XHJcblx0dmFyIG1lc3NhZ2VzID0gW10sXHJcblx0XHRmb2N1c0VsZW07XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgZWxlbSA9IGVycm9yc1tpXS5lbGVtZW50LFxyXG5cdFx0XHRtZXNzYWdlID0gZXJyb3JzW2ldLm1lc3NhZ2U7XHJcblxyXG5cdFx0aWYgKCFOZXR0ZS5pbkFycmF5KG1lc3NhZ2VzLCBtZXNzYWdlKSkge1xyXG5cdFx0XHRtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xyXG5cclxuXHRcdFx0aWYgKCFmb2N1c0VsZW0gJiYgZWxlbS5mb2N1cykge1xyXG5cdFx0XHRcdGZvY3VzRWxlbSA9IGVsZW07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChtZXNzYWdlcy5sZW5ndGgpIHtcclxuXHRcdGFsZXJ0KG1lc3NhZ2VzLmpvaW4oJ1xcbicpKTtcclxuXHJcblx0XHRpZiAoZm9jdXNFbGVtKSB7XHJcblx0XHRcdGZvY3VzRWxlbS5mb2N1cygpO1xyXG5cdFx0fVxyXG5cdH1cclxufTsqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBFeHBhbmQgcnVsZSBhcmd1bWVudC5cclxuICovXHJcbk5ldHRlLmV4cGFuZFJ1bGVBcmd1bWVudCA9IGZ1bmN0aW9uKGZvcm0sIGFyZykge1xyXG5cdGlmIChhcmcgJiYgYXJnLmNvbnRyb2wpIHtcclxuXHRcdHZhciBjb250cm9sID0gZm9ybS5lbGVtZW50cy5uYW1lZEl0ZW0oYXJnLmNvbnRyb2wpLFxyXG5cdFx0XHR2YWx1ZSA9IHt2YWx1ZTogTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUoY29udHJvbCl9O1xyXG5cdFx0TmV0dGUudmFsaWRhdGVDb250cm9sKGNvbnRyb2wsIG51bGwsIHRydWUsIHZhbHVlKTtcclxuXHRcdGFyZyA9IHZhbHVlLnZhbHVlO1xyXG5cdH1cclxuXHRyZXR1cm4gYXJnO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgc2luZ2xlIHJ1bGUuXHJcbiAqL1xyXG5OZXR0ZS52YWxpZGF0ZVJ1bGUgPSBmdW5jdGlvbihlbGVtLCBvcCwgYXJnLCB2YWx1ZSkge1xyXG5cdHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHt2YWx1ZTogTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUoZWxlbSl9IDogdmFsdWU7XHJcblxyXG5cdGlmIChvcC5jaGFyQXQoMCkgPT09ICc6Jykge1xyXG5cdFx0b3AgPSBvcC5zdWJzdHIoMSk7XHJcblx0fVxyXG5cdG9wID0gb3AucmVwbGFjZSgnOjonLCAnXycpO1xyXG5cdG9wID0gb3AucmVwbGFjZSgvXFxcXC9nLCAnJyk7XHJcblxyXG5cdHZhciBhcnIgPSBOZXR0ZS5pc0FycmF5KGFyZykgPyBhcmcuc2xpY2UoMCkgOiBbYXJnXTtcclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRhcnJbaV0gPSBOZXR0ZS5leHBhbmRSdWxlQXJndW1lbnQoZWxlbS5mb3JtLCBhcnJbaV0pO1xyXG5cdH1cclxuXHRyZXR1cm4gTmV0dGUudmFsaWRhdG9yc1tvcF1cclxuXHRcdD8gTmV0dGUudmFsaWRhdG9yc1tvcF0oZWxlbSwgTmV0dGUuaXNBcnJheShhcmcpID8gYXJyIDogYXJyWzBdLCB2YWx1ZS52YWx1ZSwgdmFsdWUpXHJcblx0XHQ6IG51bGw7XHJcbn07XHJcblxyXG5cclxuTmV0dGUudmFsaWRhdG9ycyA9IHtcclxuXHRmaWxsZWQ6IGZ1bmN0aW9uKGVsZW0sIGFyZywgdmFsKSB7XHJcblx0XHRpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJyAmJiBlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbCAhPT0gJycgJiYgdmFsICE9PSBmYWxzZSAmJiB2YWwgIT09IG51bGxcclxuXHRcdFx0JiYgKCFOZXR0ZS5pc0FycmF5KHZhbCkgfHwgISF2YWwubGVuZ3RoKVxyXG5cdFx0XHQmJiAoIXdpbmRvdy5GaWxlTGlzdCB8fCAhKHZhbCBpbnN0YW5jZW9mIHdpbmRvdy5GaWxlTGlzdCkgfHwgdmFsLmxlbmd0aCk7XHJcblx0fSxcclxuXHJcblx0Ymxhbms6IGZ1bmN0aW9uKGVsZW0sIGFyZywgdmFsKSB7XHJcblx0XHRyZXR1cm4gIU5ldHRlLnZhbGlkYXRvcnMuZmlsbGVkKGVsZW0sIGFyZywgdmFsKTtcclxuXHR9LFxyXG5cclxuXHR2YWxpZDogZnVuY3Rpb24oZWxlbSwgYXJnLCB2YWwpIHtcclxuXHRcdHJldHVybiBOZXR0ZS52YWxpZGF0ZUNvbnRyb2woZWxlbSwgbnVsbCwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0ZXF1YWw6IGZ1bmN0aW9uKGVsZW0sIGFyZywgdmFsKSB7XHJcblx0XHRpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdHJldHVybiAnJyArIHZhbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gdmFsID09PSB0cnVlID8gJzEnIDogJyc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YWwgPSBOZXR0ZS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXTtcclxuXHRcdGFyZyA9IE5ldHRlLmlzQXJyYXkoYXJnKSA/IGFyZyA6IFthcmddO1xyXG5cdFx0bG9vcDpcclxuXHRcdGZvciAodmFyIGkxID0gMCwgbGVuMSA9IHZhbC5sZW5ndGg7IGkxIDwgbGVuMTsgaTErKykge1xyXG5cdFx0XHRmb3IgKHZhciBpMiA9IDAsIGxlbjIgPSBhcmcubGVuZ3RoOyBpMiA8IGxlbjI7IGkyKyspIHtcclxuXHRcdFx0XHRpZiAodG9TdHJpbmcodmFsW2kxXSkgPT09IHRvU3RyaW5nKGFyZ1tpMl0pKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZSBsb29wO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRub3RFcXVhbDogZnVuY3Rpb24oZWxlbSwgYXJnLCB2YWwpIHtcclxuXHRcdHJldHVybiBhcmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAhTmV0dGUudmFsaWRhdG9ycy5lcXVhbChlbGVtLCBhcmcsIHZhbCk7XHJcblx0fSxcclxuXHJcblx0bWluTGVuZ3RoOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0aWYgKGVsZW0udmFsaWRpdHkudG9vU2hvcnQpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdFx0fSBlbHNlIGlmIChlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWwubGVuZ3RoID49IGFyZztcclxuXHR9LFxyXG5cclxuXHRtYXhMZW5ndGg6IGZ1bmN0aW9uKGVsZW0sIGFyZywgdmFsKSB7XHJcblx0XHRpZiAoZWxlbS50eXBlID09PSAnbnVtYmVyJykge1xyXG5cdFx0XHRpZiAoZWxlbS52YWxpZGl0eS50b29Mb25nKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdH0gZWxzZSBpZiAoZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsLmxlbmd0aCA8PSBhcmc7XHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0aWYgKGVsZW0udmFsaWRpdHkudG9vU2hvcnQgfHwgZWxlbS52YWxpZGl0eS50b29Mb25nKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdH0gZWxzZSBpZiAoZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRhcmcgPSBOZXR0ZS5pc0FycmF5KGFyZykgPyBhcmcgOiBbYXJnLCBhcmddO1xyXG5cdFx0cmV0dXJuIChhcmdbMF0gPT09IG51bGwgfHwgdmFsLmxlbmd0aCA+PSBhcmdbMF0pICYmIChhcmdbMV0gPT09IG51bGwgfHwgdmFsLmxlbmd0aCA8PSBhcmdbMV0pO1xyXG5cdH0sXHJcblxyXG5cdGVtYWlsOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0cmV0dXJuICgvXihcIihbICEjLVtcXF0tfl18XFxcXFsgLX5dKStcInxbLWEtejAtOSEjJCUmJyorXFwvPT9eX2B7fH1+XSsoXFwuWy1hLXowLTkhIyQlJicqK1xcLz0/Xl9ge3x9fl0rKSopQChbMC05YS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXShbLTAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl17MCw2MX1bMC05YS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXSk/XFwuKStbYS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXShbLTAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl17MCwxN31bYS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXSk/JC9pKS50ZXN0KHZhbCk7XHJcblx0fSxcclxuXHJcblx0dXJsOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCwgdmFsdWUpIHtcclxuXHRcdGlmICghKC9eW2EtelxcZCsuLV0rOi8pLnRlc3QodmFsKSkge1xyXG5cdFx0XHR2YWwgPSAnaHR0cDovLycgKyB2YWw7XHJcblx0XHR9XHJcblx0XHRpZiAoKC9eaHR0cHM/OlxcL1xcLygoKFstXzAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl0rXFwuKSpbMC05YS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXShbLTAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl17MCw2MX1bMC05YS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXSk/XFwuKT9bYS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXShbLTAtOWEtelxcdTAwQzAtXFx1MDJGRlxcdTAzNzAtXFx1MUVGRl17MCwxN31bYS16XFx1MDBDMC1cXHUwMkZGXFx1MDM3MC1cXHUxRUZGXSk/fFxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9fFxcW1swLTlhLWY6XXszLDM5fVxcXSkoOlxcZHsxLDV9KT8oXFwvXFxTKik/JC9pKS50ZXN0KHZhbCkpIHtcclxuXHRcdFx0dmFsdWUudmFsdWUgPSB2YWw7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2V4cDogZnVuY3Rpb24oZWxlbSwgYXJnLCB2YWwpIHtcclxuXHRcdHZhciBwYXJ0cyA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYXJnLm1hdGNoKC9eXFwvKC4qKVxcLyhbaW11XSopJC8pIDogZmFsc2U7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRyZXR1cm4gcGFydHMgJiYgKG5ldyBSZWdFeHAocGFydHNbMV0sIHBhcnRzWzJdLnJlcGxhY2UoJ3UnLCAnJykpKS50ZXN0KHZhbCk7XHJcblx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdH0sXHJcblxyXG4gICAgcGF0dGVybjogZnVuY3Rpb24oZWxlbSwgYXJnLCB2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuZXcgUmVnRXhwKCdeKD86JyArIGFyZyArICcpJCcpKS50ZXN0KHZhbFtpXS5uYW1lKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBSZWdFeHAoJ14oPzonICsgYXJnICsgJykkJykpLnRlc3QodmFsKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuXHRpbnRlZ2VyOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicgJiYgZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKC9eLT9bMC05XSskLykudGVzdCh2YWwpO1xyXG5cdH0sXHJcblxyXG5cdCdmbG9hdCc6IGZ1bmN0aW9uKGVsZW0sIGFyZywgdmFsLCB2YWx1ZSkge1xyXG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicgJiYgZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR2YWwgPSB2YWwucmVwbGFjZSgnICcsICcnKS5yZXBsYWNlKCcsJywgJy4nKTtcclxuXHRcdGlmICgoL14tP1swLTldKlsuLF0/WzAtOV0rJC8pLnRlc3QodmFsKSkge1xyXG5cdFx0XHR2YWx1ZS52YWx1ZSA9IHZhbDtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0aWYgKGVsZW0udmFsaWRpdHkucmFuZ2VVbmRlcmZsb3cpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdFx0fSBlbHNlIGlmIChlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBOZXR0ZS52YWxpZGF0b3JzLnJhbmdlKGVsZW0sIFthcmcsIG51bGxdLCB2YWwpO1xyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24oZWxlbSwgYXJnLCB2YWwpIHtcclxuXHRcdGlmIChlbGVtLnR5cGUgPT09ICdudW1iZXInKSB7XHJcblx0XHRcdGlmIChlbGVtLnZhbGlkaXR5LnJhbmdlT3ZlcmZsb3cpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdFx0fSBlbHNlIGlmIChlbGVtLnZhbGlkaXR5LmJhZElucHV0KSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBOZXR0ZS52YWxpZGF0b3JzLnJhbmdlKGVsZW0sIFtudWxsLCBhcmddLCB2YWwpO1xyXG5cdH0sXHJcblxyXG5cdHJhbmdlOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0aWYgKGVsZW0udHlwZSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0aWYgKChlbGVtLnZhbGlkaXR5LnJhbmdlVW5kZXJmbG93ICYmIGFyZ1swXSAhPT0gbnVsbCkgfHwgKGVsZW0udmFsaWRpdHkucmFuZ2VPdmVyZmxvdyAmJiBhcmdbMV0gIT09IG51bGwpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlXHJcblx0XHRcdH0gZWxzZSBpZiAoZWxlbS52YWxpZGl0eS5iYWRJbnB1dCkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdGlmIChlbGVtLnR5cGUgPT09ICdkYXRlJykge1xyXG5cdFx0XHRhcmdbMF0gPSAoYXJnWzBdID09PSBudWxsID8gbnVsbCA6IG5ldyBEYXRlKGFyZ1swXSkuZ2V0VGltZSgpKTtcclxuXHRcdFx0YXJnWzFdID0gKGFyZ1sxXSA9PT0gbnVsbCA/IG51bGwgOiBuZXcgRGF0ZShhcmdbMV0pLmdldFRpbWUoKSk7XHJcblx0XHRcdHZhbCA9IG5ldyBEYXRlKHZhbCkuZ2V0VGltZSgpXHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHJldHVybiBOZXR0ZS5pc0FycmF5KGFyZykgP1xyXG5cdFx0XHQoKGFyZ1swXSA9PT0gbnVsbCB8fCBwYXJzZUZsb2F0KHZhbCkgPj0gYXJnWzBdKSAmJiAoYXJnWzFdID09PSBudWxsIHx8IHBhcnNlRmxvYXQodmFsKSA8PSBhcmdbMV0pKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0c3VibWl0dGVkOiBmdW5jdGlvbihlbGVtLCBhcmcsIHZhbCkge1xyXG5cdFx0cmV0dXJuIGVsZW0uZm9ybVsnbmV0dGUtc3VibWl0dGVkQnknXSA9PT0gZWxlbTtcclxuXHR9LFxyXG5cclxuXHRmaWxlU2l6ZTogZnVuY3Rpb24oZWxlbSwgYXJnLCB2YWwpIHtcclxuXHRcdGlmICh3aW5kb3cuRmlsZUxpc3QpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodmFsW2ldLnNpemUgPiBhcmcpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdGltYWdlOiBmdW5jdGlvbiAoZWxlbSwgYXJnLCB2YWwpIHtcclxuXHRcdGlmICh3aW5kb3cuRmlsZUxpc3QgJiYgdmFsIGluc3RhbmNlb2Ygd2luZG93LkZpbGVMaXN0KSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHR5cGUgPSB2YWxbaV0udHlwZTtcclxuXHRcdFx0XHRpZiAodHlwZSAmJiB0eXBlICE9PSAnaW1hZ2UvZ2lmJyAmJiB0eXBlICE9PSAnaW1hZ2UvcG5nJyAmJiB0eXBlICE9PSAnaW1hZ2UvanBlZycpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUHJvY2VzcyBhbGwgdG9nZ2xlcyBpbiBmb3JtLlxyXG4gKi9cclxuTmV0dGUudG9nZ2xlRm9ybSA9IGZ1bmN0aW9uKGZvcm0sIGVsZW0pIHtcclxuXHR2YXIgaTtcclxuXHROZXR0ZS50b2dnbGVzID0ge307XHJcblx0Zm9yIChpID0gMDsgaSA8IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChmb3JtLmVsZW1lbnRzW2ldLnRhZ05hbWUudG9Mb3dlckNhc2UoKSBpbiB7aW5wdXQ6IDEsIHNlbGVjdDogMSwgdGV4dGFyZWE6IDEsIGJ1dHRvbjogMX0pIHtcclxuXHRcdFx0TmV0dGUudG9nZ2xlQ29udHJvbChmb3JtLmVsZW1lbnRzW2ldLCBudWxsLCBudWxsLCAhZWxlbSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmb3IgKGkgaW4gTmV0dGUudG9nZ2xlcykge1xyXG5cdFx0TmV0dGUudG9nZ2xlKGksIE5ldHRlLnRvZ2dsZXNbaV0sIGVsZW0pO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUHJvY2VzcyB0b2dnbGVzIG9uIGZvcm0gZWxlbWVudC5cclxuICovXHJcbk5ldHRlLnRvZ2dsZUNvbnRyb2wgPSBmdW5jdGlvbihlbGVtLCBydWxlcywgc3VjY2VzcywgZmlyc3R0aW1lLCB2YWx1ZSkge1xyXG5cdHJ1bGVzID0gcnVsZXMgfHwgTmV0dGUucGFyc2VKU09OKGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLW5ldHRlLXJ1bGVzJykpO1xyXG5cdHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHt2YWx1ZTogTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUoZWxlbSl9IDogdmFsdWU7XHJcblxyXG5cdHZhciBoYXMgPSBmYWxzZSxcclxuXHRcdGhhbmRsZWQgPSBbXSxcclxuXHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdE5ldHRlLnRvZ2dsZUZvcm0oZWxlbS5mb3JtLCBlbGVtKTtcclxuXHRcdH0sXHJcblx0XHRjdXJTdWNjZXNzO1xyXG5cclxuXHRmb3IgKHZhciBpZCA9IDAsIGxlbiA9IHJ1bGVzLmxlbmd0aDsgaWQgPCBsZW47IGlkKyspIHtcclxuXHRcdHZhciBydWxlID0gcnVsZXNbaWRdLFxyXG5cdFx0XHRvcCA9IHJ1bGUub3AubWF0Y2goLyh+KT8oW14/XSspLyksXHJcblx0XHRcdGN1ckVsZW0gPSBydWxlLmNvbnRyb2wgPyBlbGVtLmZvcm0uZWxlbWVudHMubmFtZWRJdGVtKHJ1bGUuY29udHJvbCkgOiBlbGVtO1xyXG5cclxuXHRcdGlmICghY3VyRWxlbSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHRjdXJTdWNjZXNzID0gc3VjY2VzcztcclxuXHRcdGlmIChzdWNjZXNzICE9PSBmYWxzZSkge1xyXG5cdFx0XHRydWxlLm5lZyA9IG9wWzFdO1xyXG5cdFx0XHRydWxlLm9wID0gb3BbMl07XHJcblx0XHRcdHZhciBjdXJWYWx1ZSA9IGVsZW0gPT09IGN1ckVsZW0gPyB2YWx1ZSA6IHt2YWx1ZTogTmV0dGUuZ2V0RWZmZWN0aXZlVmFsdWUoY3VyRWxlbSl9O1xyXG5cdFx0XHRjdXJTdWNjZXNzID0gTmV0dGUudmFsaWRhdGVSdWxlKGN1ckVsZW0sIHJ1bGUub3AsIHJ1bGUuYXJnLCBjdXJWYWx1ZSk7XHJcblx0XHRcdGlmIChjdXJTdWNjZXNzID09PSBudWxsKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKHJ1bGUubmVnKSB7XHJcblx0XHRcdFx0Y3VyU3VjY2VzcyA9ICFjdXJTdWNjZXNzO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghcnVsZS5ydWxlcykge1xyXG5cdFx0XHRcdHN1Y2Nlc3MgPSBjdXJTdWNjZXNzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKChydWxlLnJ1bGVzICYmIE5ldHRlLnRvZ2dsZUNvbnRyb2woZWxlbSwgcnVsZS5ydWxlcywgY3VyU3VjY2VzcywgZmlyc3R0aW1lLCB2YWx1ZSkpIHx8IHJ1bGUudG9nZ2xlKSB7XHJcblx0XHRcdGhhcyA9IHRydWU7XHJcblx0XHRcdGlmIChmaXJzdHRpbWUpIHtcclxuXHRcdFx0XHR2YXIgb2xkSUUgPSAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciwgLy8gSUUgPCA5XHJcblx0XHRcdFx0XHRuYW1lID0gY3VyRWxlbS50YWdOYW1lID8gY3VyRWxlbS5uYW1lIDogY3VyRWxlbVswXS5uYW1lLFxyXG5cdFx0XHRcdFx0ZWxzID0gY3VyRWxlbS50YWdOYW1lID8gY3VyRWxlbS5mb3JtLmVsZW1lbnRzIDogY3VyRWxlbTtcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChlbHNbaV0ubmFtZSA9PT0gbmFtZSAmJiAhTmV0dGUuaW5BcnJheShoYW5kbGVkLCBlbHNbaV0pKSB7XHJcblx0XHRcdFx0XHRcdE5ldHRlLmFkZEV2ZW50KGVsc1tpXSwgb2xkSUUgJiYgZWxzW2ldLnR5cGUgaW4ge2NoZWNrYm94OiAxLCByYWRpbzogMX0gPyAnY2xpY2snIDogJ2NoYW5nZScsIGhhbmRsZXIpO1xyXG5cdFx0XHRcdFx0XHRoYW5kbGVkLnB1c2goZWxzW2ldKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yICh2YXIgaWQyIGluIHJ1bGUudG9nZ2xlIHx8IFtdKSB7XHJcblx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChydWxlLnRvZ2dsZSwgaWQyKSkge1xyXG5cdFx0XHRcdFx0TmV0dGUudG9nZ2xlc1tpZDJdID0gTmV0dGUudG9nZ2xlc1tpZDJdIHx8IChydWxlLnRvZ2dsZVtpZDJdID8gY3VyU3VjY2VzcyA6ICFjdXJTdWNjZXNzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGhhcztcclxufTtcclxuXHJcblxyXG5OZXR0ZS5wYXJzZUpTT04gPSBmdW5jdGlvbihzKSB7XHJcblx0cmV0dXJuIChzIHx8ICcnKS5zdWJzdHIoMCwgMykgPT09ICd7b3AnXHJcblx0XHQ/IGV2YWwoJ1snICsgcyArICddJykgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIE5ldHRlIDIuMC54XHJcblx0XHQ6IEpTT04ucGFyc2UocyB8fCAnW10nKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGlzcGxheXMgb3IgaGlkZXMgSFRNTCBlbGVtZW50LlxyXG4gKi9cclxuTmV0dGUudG9nZ2xlID0gZnVuY3Rpb24oaWQsIHZpc2libGUsIHNyY0VsZW1lbnQpIHtcclxuXHR2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcclxuXHRpZiAoZWxlbSkge1xyXG5cdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gdmlzaWJsZSA/ICcnIDogJ25vbmUnO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2V0dXAgaGFuZGxlcnMuXHJcbiAqL1xyXG5OZXR0ZS5pbml0Rm9ybSA9IGZ1bmN0aW9uKGZvcm0pIHtcclxuXHRpZiAoZm9ybS5ub1ZhbGlkYXRlKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRmb3JtLm5vVmFsaWRhdGUgPSAnbm92YWxpZGF0ZSc7XHJcblxyXG5cdC8vIExpdmVGb3JtOiBhZGRpdGlvblxyXG5cdExpdmVGb3JtLmZvcm1zW2Zvcm0uaWRdID0ge1xyXG5cdFx0aGFzRXJyb3I6IGZhbHNlLFxyXG5cdFx0b25Mb2FkVmFsaWRhdGlvbjogZmFsc2VcclxuXHR9O1xyXG5cclxuXHROZXR0ZS5hZGRFdmVudChmb3JtLCAnc3VibWl0JywgZnVuY3Rpb24oZSkge1xyXG5cdFx0aWYgKCFOZXR0ZS52YWxpZGF0ZUZvcm0oZm9ybSkpIHtcclxuXHRcdFx0aWYgKGUgJiYgZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cuZXZlbnQpIHtcclxuXHRcdFx0XHRldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG5cdFx0XHRcdGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0TmV0dGUudG9nZ2xlRm9ybShmb3JtKTtcclxuXHJcblx0Ly8gTGl2ZUZvcm06IGFkZGl0aW9uXHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRMaXZlRm9ybS5zZXR1cEhhbmRsZXJzKGZvcm0uZWxlbWVudHNbaV0pO1xyXG5cdFx0TGl2ZUZvcm0ucHJvY2Vzc1NlcnZlckVycm9ycyhmb3JtLmVsZW1lbnRzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5OZXR0ZS5pbml0T25Mb2FkID0gZnVuY3Rpb24oKSB7XHJcblx0TmV0dGUuYWRkRXZlbnQoZG9jdW1lbnQsICdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XHJcbi8vIExpdmVGb3JtOiBvcmlnaW5hbCBuZXR0ZUZvcm1zLmpzIGNvZGUgXHJcbi8qICBcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGZvcm0gPSBkb2N1bWVudC5mb3Jtc1tpXTtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBmb3JtLmVsZW1lbnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGZvcm0uZWxlbWVudHNbal0uZ2V0QXR0cmlidXRlKCdkYXRhLW5ldHRlLXJ1bGVzJykpIHtcclxuXHRcdFx0XHRcdE5ldHRlLmluaXRGb3JtKGZvcm0pO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0TmV0dGUuYWRkRXZlbnQoZG9jdW1lbnQuYm9keSwgJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xyXG5cdFx0XHR2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xyXG5cdFx0XHRpZiAodGFyZ2V0LmZvcm0gJiYgdGFyZ2V0LnR5cGUgaW4ge3N1Ym1pdDogMSwgaW1hZ2U6IDF9KSB7XHJcblx0XHRcdFx0dGFyZ2V0LmZvcm1bJ25ldHRlLXN1Ym1pdHRlZEJ5J10gPSB0YXJnZXQ7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG4qL1xyXG4gICAgLy8gTGl2ZUZvcm06IGFkZGl0aW9uXHJcbiAgICBOZXR0ZS5pbml0KCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG4vLyBMaXZlRm9ybTogYWRkaXRpb25cclxuLyoqXHJcbiAqIEluaXQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIGNhc2UgdXNhZ2UgYXMgbW9kdWxlXHJcbiAqIFxyXG4gKiBAcHVibGljIFxyXG4gKi9cclxuTmV0dGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBmb3JtID0gZG9jdW1lbnQuZm9ybXNbaV07XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGZvcm0uZWxlbWVudHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0aWYgKGZvcm0uZWxlbWVudHNbal0uZ2V0QXR0cmlidXRlKCdkYXRhLW5ldHRlLXJ1bGVzJykpIHtcclxuXHRcdFx0XHRcdE5ldHRlLmluaXRGb3JtKGZvcm0pO1xyXG5cclxuXHRcdFx0XHRpZiAoTGl2ZUZvcm0uaGFzQ2xhc3MoZm9ybSwgJ3ZhbGlkYXRlLW9uLWxvYWQnKSkge1xyXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBub3Qgc28gbmljZSB3YXksIGJ1dCBJIGRvbid0IHdhbnQgdG8gc3BvaWwgdmFsaWRhdGVGb3JtLCB2YWxpZGF0ZUNvbnRyb2wgYW5kIG90aGVyIG1ldGhvZHMgd2l0aCBhbm90aGVyIHBhcmFtZXRlclxyXG5cdFx0XHRcdFx0TGl2ZUZvcm0uc2V0Rm9ybVByb3BlcnR5KGZvcm0sIFwib25Mb2FkVmFsaWRhdGlvblwiLCB0cnVlKTtcclxuXHRcdFx0XHRcdE5ldHRlLnZhbGlkYXRlRm9ybShmb3JtKTtcclxuXHRcdFx0XHRcdExpdmVGb3JtLnNldEZvcm1Qcm9wZXJ0eShmb3JtLCBcIm9uTG9hZFZhbGlkYXRpb25cIiwgZmFsc2UpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdE5ldHRlLmFkZEV2ZW50KGRvY3VtZW50LmJvZHksICdjbGljaycsIGZ1bmN0aW9uKGUpIHtcclxuXHRcdHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XHJcblx0XHRpZiAodGFyZ2V0LmZvcm0gJiYgdGFyZ2V0LnR5cGUgaW4ge3N1Ym1pdDogMSwgaW1hZ2U6IDF9KSB7XHJcblx0XHRcdHRhcmdldC5mb3JtWyduZXR0ZS1zdWJtaXR0ZWRCeSddID0gdGFyZ2V0O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LlxyXG4gKi9cclxuTmV0dGUuaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xyXG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogU2VhcmNoIGZvciBhIHNwZWNpZmllZCB2YWx1ZSB3aXRoaW4gYW4gYXJyYXkuXHJcbiAqL1xyXG5OZXR0ZS5pbkFycmF5ID0gZnVuY3Rpb24oYXJyLCB2YWwpIHtcclxuXHRpZiAoW10uaW5kZXhPZikge1xyXG5cdFx0cmV0dXJuIGFyci5pbmRleE9mKHZhbCkgPiAtMTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PT0gdmFsKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHN0cmluZyB0byB3ZWIgc2FmZSBjaGFyYWN0ZXJzIFthLXowLTktXSB0ZXh0LlxyXG4gKi9cclxuTmV0dGUud2ViYWxpemUgPSBmdW5jdGlvbihzKSB7XHJcblx0cyA9IHMudG9Mb3dlckNhc2UoKTtcclxuXHR2YXIgcmVzID0gJycsIGksIGNoO1xyXG5cdGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRjaCA9IE5ldHRlLndlYmFsaXplVGFibGVbcy5jaGFyQXQoaSldO1xyXG5cdFx0cmVzICs9IGNoID8gY2ggOiBzLmNoYXJBdChpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlcy5yZXBsYWNlKC9bXmEtejAtOV0rL2csICctJykucmVwbGFjZSgvXi18LSQvZywgJycpO1xyXG59O1xyXG5cclxuTmV0dGUud2ViYWxpemVUYWJsZSA9IHtcXHUwMGUxOiAnYScsIFxcdTAwZTQ6ICdhJywgXFx1MDEwZDogJ2MnLCBcXHUwMTBmOiAnZCcsIFxcdTAwZTk6ICdlJywgXFx1MDExYjogJ2UnLCBcXHUwMGVkOiAnaScsIFxcdTAxM2U6ICdsJywgXFx1MDE0ODogJ24nLCBcXHUwMGYzOiAnbycsIFxcdTAwZjQ6ICdvJywgXFx1MDE1OTogJ3InLCBcXHUwMTYxOiAncycsIFxcdTAxNjU6ICd0JywgXFx1MDBmYTogJ3UnLCBcXHUwMTZmOiAndScsIFxcdTAwZmQ6ICd5JywgXFx1MDE3ZTogJ3onfTtcclxuXHJcbnJldHVybiBOZXR0ZTtcclxufSkpO1xyXG4iLCIvKlxuICogTmFqYS5qc1xuICogMi4xLjVcbiAqXG4gKiBieSBKacWZw60gUHVkaWwgPGh0dHBzOi8vamlyaXB1ZGlsLmN6PlxuICovXG5pbXBvcnQgeyBFdmVudFRhcmdldCBhcyBFdmVudFRhcmdldCQxIH0gZnJvbSAnZXZlbnQtdGFyZ2V0LXNoaW0nO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIGZhY3RvcnkoKTtcbn0oKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgICB9O1xuICAgIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgby5fX3Byb3RvX18gPSBwO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gICAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG4gIH1cblxuICB2YXIgRW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWl0dGVyKTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsaXN0ZW5lcnMnLCB7XG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEVtaXR0ZXIsIFt7XG4gICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmxpc3RlbmVycykpIHtcbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaCh7XG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbdHlwZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFjay5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoc3RhY2tbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRpc3BhdGNoRXZlbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmICghKGV2ZW50LnR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5saXN0ZW5lcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHZhciBzdGFja1RvQ2FsbCA9IHN0YWNrLnNsaWNlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGFja1RvQ2FsbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBzdGFja1RvQ2FsbFtpXTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaXN0ZW5lci5vcHRpb25zICYmIGxpc3RlbmVyLm9wdGlvbnMub25jZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEVtaXR0ZXI7XG4gIH0oKTtcblxuICB2YXIgQWJvcnRTaWduYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKEFib3J0U2lnbmFsLCBfRW1pdHRlcik7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEFib3J0U2lnbmFsKTtcblxuICAgIGZ1bmN0aW9uIEFib3J0U2lnbmFsKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRTaWduYWwpO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpOyAvLyBTb21lIHZlcnNpb25zIG9mIGJhYmVsIGRvZXMgbm90IHRyYW5zcGlsZSBzdXBlcigpIGNvcnJlY3RseSBmb3IgSUUgPD0gMTAsIGlmIHRoZSBwYXJlbnRcbiAgICAgIC8vIGNvbnN0cnVjdG9yIGhhcyBmYWlsZWQgdG8gcnVuLCB0aGVuIFwidGhpcy5saXN0ZW5lcnNcIiB3aWxsIHN0aWxsIGJlIHVuZGVmaW5lZCBhbmQgdGhlbiB3ZSBjYWxsXG4gICAgICAvLyB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGRpcmVjdGx5IGluc3RlYWQgYXMgYSB3b3JrYXJvdW5kLiBGb3IgZ2VuZXJhbCBkZXRhaWxzLCBzZWUgYmFiZWwgYnVnOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy8zMDQxXG4gICAgICAvLyBUaGlzIGhhY2sgd2FzIGFkZGVkIGFzIGEgZml4IGZvciB0aGUgaXNzdWUgZGVzY3JpYmVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLWxpYnJhcnkvcHVsbC81OSNpc3N1ZWNvbW1lbnQtNDc3NTU4MDQyXG5cbiAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgIEVtaXR0ZXIuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICB9IC8vIENvbXBhcmVkIHRvIGFzc2lnbm1lbnQsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBtYWtlcyBwcm9wZXJ0aWVzIG5vbi1lbnVtZXJhYmxlIGJ5IGRlZmF1bHQgYW5kXG4gICAgICAvLyB3ZSB3YW50IE9iamVjdC5rZXlzKG5ldyBBYm9ydENvbnRyb2xsZXIoKS5zaWduYWwpIHRvIGJlIFtdIGZvciBjb21wYXQgd2l0aCB0aGUgbmF0aXZlIGltcGxcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICdhYm9ydGVkJywge1xuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCAnb25hYm9ydCcsIHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBYm9ydFNpZ25hbCwgW3tcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRTaWduYWxdJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25hYm9ydC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihBYm9ydFNpZ25hbC5wcm90b3R5cGUpLCBcImRpc3BhdGNoRXZlbnRcIiwgdGhpcykuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFib3J0U2lnbmFsO1xuICB9KEVtaXR0ZXIpO1xuICB2YXIgQWJvcnRDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYm9ydENvbnRyb2xsZXIoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRDb250cm9sbGVyKTtcblxuICAgICAgLy8gQ29tcGFyZWQgdG8gYXNzaWdubWVudCwgT2JqZWN0LmRlZmluZVByb3BlcnR5IG1ha2VzIHByb3BlcnRpZXMgbm9uLWVudW1lcmFibGUgYnkgZGVmYXVsdCBhbmRcbiAgICAgIC8vIHdlIHdhbnQgT2JqZWN0LmtleXMobmV3IEFib3J0Q29udHJvbGxlcigpKSB0byBiZSBbXSBmb3IgY29tcGF0IHdpdGggdGhlIG5hdGl2ZSBpbXBsXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NpZ25hbCcsIHtcbiAgICAgICAgdmFsdWU6IG5ldyBBYm9ydFNpZ25hbCgpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQWJvcnRDb250cm9sbGVyLCBbe1xuICAgICAga2V5OiBcImFib3J0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgICAgIHZhciBldmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2ZW50ID0gbmV3IEV2ZW50KCdhYm9ydCcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIEludGVybmV0IEV4cGxvcmVyIDg6XG4gICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgICAgZXZlbnQudHlwZSA9ICdhYm9ydCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTE6XG4gICAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICAgIGV2ZW50LmluaXRFdmVudCgnYWJvcnQnLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB3aGVyZSBkb2N1bWVudCBpc24ndCBhdmFpbGFibGU6XG4gICAgICAgICAgICBldmVudCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Fib3J0JyxcbiAgICAgICAgICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICAgICAgICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ1tvYmplY3QgQWJvcnRDb250cm9sbGVyXSc7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFib3J0Q29udHJvbGxlcjtcbiAgfSgpO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiAgICAvLyBUaGVzZSBhcmUgbmVjZXNzYXJ5IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGdldCBjb3JyZWN0IG91dHB1dCBmb3I6XG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ldyBBYm9ydENvbnRyb2xsZXIoKSlcbiAgICBBYm9ydENvbnRyb2xsZXIucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnQWJvcnRDb250cm9sbGVyJztcbiAgICBBYm9ydFNpZ25hbC5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdBYm9ydFNpZ25hbCc7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5ZmlsbE5lZWRlZChzZWxmKSB7XG4gICAgaWYgKHNlbGYuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCkge1xuICAgICAgY29uc29sZS5sb2coJ19fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw9dHJ1ZSBpcyBzZXQsIHdpbGwgZm9yY2UgaW5zdGFsbCBwb2x5ZmlsbCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3RlIHRoYXQgdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgZGVmaW5lcyBmZXRjaCgpIHdpdGhvdXRcbiAgICAvLyBkZWZpbmluZyB3aW5kb3cuUmVxdWVzdCwgYW5kIHRoaXMgcG9seWZpbGwgbmVlZCB0byB3b3JrIG9uIHRvcCBvZiB1bmZldGNoXG4gICAgLy8gc28gdGhlIGJlbG93IGZlYXR1cmUgZGV0ZWN0aW9uIG5lZWRzIHRoZSAhc2VsZi5BYm9ydENvbnRyb2xsZXIgcGFydC5cbiAgICAvLyBUaGUgUmVxdWVzdC5wcm90b3R5cGUgY2hlY2sgaXMgYWxzbyBuZWVkZWQgYmVjYXVzZSBTYWZhcmkgdmVyc2lvbnMgMTEuMS4yXG4gICAgLy8gdXAgdG8gYW5kIGluY2x1ZGluZyAxMi4xLnggaGFzIGEgd2luZG93LkFib3J0Q29udHJvbGxlciBwcmVzZW50IGJ1dCBzdGlsbFxuICAgIC8vIGRvZXMgTk9UIGNvcnJlY3RseSBpbXBsZW1lbnQgYWJvcnRhYmxlIGZldGNoOlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzQ5ODAjYzJcblxuXG4gICAgcmV0dXJuIHR5cGVvZiBzZWxmLlJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgIXNlbGYuUmVxdWVzdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NpZ25hbCcpIHx8ICFzZWxmLkFib3J0Q29udHJvbGxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlOiB0aGUgXCJmZXRjaC5SZXF1ZXN0XCIgZGVmYXVsdCB2YWx1ZSBpcyBhdmFpbGFibGUgZm9yIGZldGNoIGltcG9ydGVkIGZyb21cbiAgICogdGhlIFwibm9kZS1mZXRjaFwiIHBhY2thZ2UgYW5kIG5vdCBpbiBicm93c2Vycy4gVGhpcyBpcyBPSyBzaW5jZSBicm93c2Vyc1xuICAgKiB3aWxsIGJlIGltcG9ydGluZyB1bWQtcG9seWZpbGwuanMgZnJvbSB0aGF0IHBhdGggXCJzZWxmXCIgaXMgcGFzc2VkIHRoZVxuICAgKiBkZWNvcmF0b3Igc28gdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBub3QgYmUgdXNlZCAoYmVjYXVzZSBicm93c2VycyB0aGF0IGRlZmluZVxuICAgKiBmZXRjaCBhbHNvIGhhcyBSZXF1ZXN0KS4gT25lIHF1aXJreSBzZXR1cCB3aGVyZSBzZWxmLmZldGNoIGV4aXN0cyBidXRcbiAgICogc2VsZi5SZXF1ZXN0IGRvZXMgbm90IGlzIHdoZW4gdGhlIFwidW5mZXRjaFwiIG1pbmltYWwgZmV0Y2ggcG9seWZpbGwgaXMgdXNlZFxuICAgKiBvbiB0b3Agb2YgSUUxMTsgZm9yIHRoaXMgY2FzZSB0aGUgYnJvd3NlciB3aWxsIHRyeSB0byB1c2UgdGhlIGZldGNoLlJlcXVlc3RcbiAgICogZGVmYXVsdCB2YWx1ZSB3aGljaCBpbiB0dXJuIHdpbGwgYmUgdW5kZWZpbmVkIGJ1dCB0aGVuIHRoZW4gXCJpZiAoUmVxdWVzdClcIlxuICAgKiB3aWxsIGVuc3VyZSB0aGF0IHlvdSBnZXQgYSBwYXRjaGVkIGZldGNoIGJ1dCBzdGlsbCBubyBSZXF1ZXN0IChhcyBleHBlY3RlZCkuXG4gICAqIEBwYXJhbSB7ZmV0Y2gsIFJlcXVlc3QgPSBmZXRjaC5SZXF1ZXN0fVxuICAgKiBAcmV0dXJucyB7ZmV0Y2g6IGFib3J0YWJsZUZldGNoLCBSZXF1ZXN0OiBBYm9ydGFibGVSZXF1ZXN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaERlY29yYXRvcihwYXRjaFRhcmdldHMpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHBhdGNoVGFyZ2V0cykge1xuICAgICAgcGF0Y2hUYXJnZXRzID0ge1xuICAgICAgICBmZXRjaDogcGF0Y2hUYXJnZXRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfcGF0Y2hUYXJnZXRzID0gcGF0Y2hUYXJnZXRzLFxuICAgICAgICBmZXRjaCA9IF9wYXRjaFRhcmdldHMuZmV0Y2gsXG4gICAgICAgIF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMuUmVxdWVzdCxcbiAgICAgICAgTmF0aXZlUmVxdWVzdCA9IF9wYXRjaFRhcmdldHMkUmVxdWVzdCA9PT0gdm9pZCAwID8gZmV0Y2guUmVxdWVzdCA6IF9wYXRjaFRhcmdldHMkUmVxdWVzdCxcbiAgICAgICAgTmF0aXZlQWJvcnRDb250cm9sbGVyID0gX3BhdGNoVGFyZ2V0cy5BYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIF9wYXRjaFRhcmdldHMkX19GT1JDRSA9IF9wYXRjaFRhcmdldHMuX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCxcbiAgICAgICAgX19GT1JDRV9JTlNUQUxMX0FCT1JUQ09OVFJPTExFUl9QT0xZRklMTCA9IF9wYXRjaFRhcmdldHMkX19GT1JDRSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcGF0Y2hUYXJnZXRzJF9fRk9SQ0U7XG5cbiAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHtcbiAgICAgIGZldGNoOiBmZXRjaCxcbiAgICAgIFJlcXVlc3Q6IE5hdGl2ZVJlcXVlc3QsXG4gICAgICBBYm9ydENvbnRyb2xsZXI6IE5hdGl2ZUFib3J0Q29udHJvbGxlcixcbiAgICAgIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEw6IF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTExcbiAgICB9KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmV0Y2g6IGZldGNoLFxuICAgICAgICBSZXF1ZXN0OiBSZXF1ZXN0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBSZXF1ZXN0ID0gTmF0aXZlUmVxdWVzdDsgLy8gTm90ZSB0aGF0IHRoZSBcInVuZmV0Y2hcIiBtaW5pbWFsIGZldGNoIHBvbHlmaWxsIGRlZmluZXMgZmV0Y2goKSB3aXRob3V0XG4gICAgLy8gZGVmaW5pbmcgd2luZG93LlJlcXVlc3QsIGFuZCB0aGlzIHBvbHlmaWxsIG5lZWQgdG8gd29yayBvbiB0b3Agb2YgdW5mZXRjaFxuICAgIC8vIGhlbmNlIHdlIG9ubHkgcGF0Y2ggaXQgaWYgaXQncyBhdmFpbGFibGUuIEFsc28gd2UgZG9uJ3QgcGF0Y2ggaXQgaWYgc2lnbmFsXG4gICAgLy8gaXMgYWxyZWFkeSBhdmFpbGFibGUgb24gdGhlIFJlcXVlc3QgcHJvdG90eXBlIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHN1cHBvcnRcbiAgICAvLyBpcyBwcmVzZW50IGFuZCB0aGUgcGF0Y2hpbmcgYmVsb3cgY2FuIGNhdXNlIGEgY3Jhc2ggc2luY2UgaXQgYXNzaWducyB0b1xuICAgIC8vIHJlcXVlc3Quc2lnbmFsIHdoaWNoIGlzIHRlY2huaWNhbGx5IGEgcmVhZC1vbmx5IHByb3BlcnR5LiBUaGlzIGxhdHRlciBlcnJvclxuICAgIC8vIGhhcHBlbnMgd2hlbiB5b3UgcnVuIHRoZSBtYWluNS5qcyBub2RlLWZldGNoIGV4YW1wbGUgaW4gdGhlIHJlcG9cbiAgICAvLyBcImFib3J0Y29udHJvbGxlci1wb2x5ZmlsbC1leGFtcGxlc1wiLiBUaGUgZXhhY3QgZXJyb3IgaXM6XG4gICAgLy8gICByZXF1ZXN0LnNpZ25hbCA9IGluaXQuc2lnbmFsO1xuICAgIC8vICAgXlxuICAgIC8vIFR5cGVFcnJvcjogQ2Fubm90IHNldCBwcm9wZXJ0eSBzaWduYWwgb2YgIzxSZXF1ZXN0PiB3aGljaCBoYXMgb25seSBhIGdldHRlclxuXG4gICAgaWYgKFJlcXVlc3QgJiYgIVJlcXVlc3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzaWduYWwnKSB8fCBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMKSB7XG4gICAgICBSZXF1ZXN0ID0gZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgaW5pdCkge1xuICAgICAgICB2YXIgc2lnbmFsO1xuXG4gICAgICAgIGlmIChpbml0ICYmIGluaXQuc2lnbmFsKSB7XG4gICAgICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWw7IC8vIE5ldmVyIHBhc3MgaW5pdC5zaWduYWwgdG8gdGhlIG5hdGl2ZSBSZXF1ZXN0IGltcGxlbWVudGF0aW9uIHdoZW4gdGhlIHBvbHlmaWxsIGhhc1xuICAgICAgICAgIC8vIGJlZW4gaW5zdGFsbGVkIGJlY2F1c2UgaWYgd2UncmUgcnVubmluZyBvbiB0b3Agb2YgYSBicm93c2VyIHdpdGggYVxuICAgICAgICAgIC8vIHdvcmtpbmcgbmF0aXZlIEFib3J0Q29udHJvbGxlciAoaS5lLiB0aGUgcG9seWZpbGwgd2FzIGluc3RhbGxlZCBkdWUgdG9cbiAgICAgICAgICAvLyBfX0ZPUkNFX0lOU1RBTExfQUJPUlRDT05UUk9MTEVSX1BPTFlGSUxMIGJlaW5nIHNldCksIHRoZW4gcGFzc2luZyBvdXJcbiAgICAgICAgICAvLyBmYWtlIEFib3J0U2lnbmFsIHRvIHRoZSBuYXRpdmUgZmV0Y2ggd2lsbCB0cmlnZ2VyOlxuICAgICAgICAgIC8vIFR5cGVFcnJvcjogRmFpbGVkIHRvIGNvbnN0cnVjdCAnUmVxdWVzdCc6IG1lbWJlciBzaWduYWwgaXMgbm90IG9mIHR5cGUgQWJvcnRTaWduYWwuXG5cbiAgICAgICAgICBkZWxldGUgaW5pdC5zaWduYWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxdWVzdCA9IG5ldyBOYXRpdmVSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVlc3QsICdzaWduYWwnLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgfTtcblxuICAgICAgUmVxdWVzdC5wcm90b3R5cGUgPSBOYXRpdmVSZXF1ZXN0LnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgcmVhbEZldGNoID0gZmV0Y2g7XG5cbiAgICB2YXIgYWJvcnRhYmxlRmV0Y2ggPSBmdW5jdGlvbiBhYm9ydGFibGVGZXRjaChpbnB1dCwgaW5pdCkge1xuICAgICAgdmFyIHNpZ25hbCA9IFJlcXVlc3QgJiYgUmVxdWVzdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBpbml0ID8gaW5pdC5zaWduYWwgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgdmFyIGFib3J0RXJyb3I7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhYm9ydEVycm9yID0gbmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIElFIDExIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyB0aGUgRE9NRXhjZXB0aW9uIGNvbnN0cnVjdG9yLCB1c2UgYVxuICAgICAgICAgIC8vIHJlZ3VsYXIgZXJyb3Igb2JqZWN0IG9uIGl0IGluc3RlYWQuXG4gICAgICAgICAgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgfSAvLyBSZXR1cm4gZWFybHkgaWYgYWxyZWFkeSBhYm9ydGVkLCB0aHVzIGF2b2lkaW5nIG1ha2luZyBhbiBIVFRQIHJlcXVlc3RcblxuXG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChhYm9ydEVycm9yKTtcbiAgICAgICAgfSAvLyBUdXJuIGFuIGV2ZW50IGludG8gYSBwcm9taXNlLCByZWplY3QgaXQgb25jZSBgYWJvcnRgIGlzIGRpc3BhdGNoZWRcblxuXG4gICAgICAgIHZhciBjYW5jZWxsYXRpb24gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhYm9ydEVycm9yKTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbml0ICYmIGluaXQuc2lnbmFsKSB7XG4gICAgICAgICAgLy8gTmV2ZXIgcGFzcyAuc2lnbmFsIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gd2hlbiB0aGUgcG9seWZpbGwgaGFzXG4gICAgICAgICAgLy8gYmVlbiBpbnN0YWxsZWQgYmVjYXVzZSBpZiB3ZSdyZSBydW5uaW5nIG9uIHRvcCBvZiBhIGJyb3dzZXIgd2l0aCBhXG4gICAgICAgICAgLy8gd29ya2luZyBuYXRpdmUgQWJvcnRDb250cm9sbGVyIChpLmUuIHRoZSBwb2x5ZmlsbCB3YXMgaW5zdGFsbGVkIGR1ZSB0b1xuICAgICAgICAgIC8vIF9fRk9SQ0VfSU5TVEFMTF9BQk9SVENPTlRST0xMRVJfUE9MWUZJTEwgYmVpbmcgc2V0KSwgdGhlbiBwYXNzaW5nIG91clxuICAgICAgICAgIC8vIGZha2UgQWJvcnRTaWduYWwgdG8gdGhlIG5hdGl2ZSBmZXRjaCB3aWxsIHRyaWdnZXI6XG4gICAgICAgICAgLy8gVHlwZUVycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSAnZmV0Y2gnIG9uICdXaW5kb3cnOiBtZW1iZXIgc2lnbmFsIGlzIG5vdCBvZiB0eXBlIEFib3J0U2lnbmFsLlxuICAgICAgICAgIGRlbGV0ZSBpbml0LnNpZ25hbDtcbiAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGZhc3Rlc3QgcHJvbWlzZSAoZG9uJ3QgbmVlZCB0byB3YWl0IGZvciByZXF1ZXN0IHRvIGZpbmlzaClcblxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2NhbmNlbGxhdGlvbiwgcmVhbEZldGNoKGlucHV0LCBpbml0KV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhbEZldGNoKGlucHV0LCBpbml0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZldGNoOiBhYm9ydGFibGVGZXRjaCxcbiAgICAgIFJlcXVlc3Q6IFJlcXVlc3RcbiAgICB9O1xuICB9XG5cbiAgKGZ1bmN0aW9uIChzZWxmKSB7XG5cbiAgICBpZiAoIXBvbHlmaWxsTmVlZGVkKHNlbGYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmZldGNoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2ZldGNoKCkgaXMgbm90IGF2YWlsYWJsZSwgY2Fubm90IGluc3RhbGwgYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9hYm9ydGFibGVGZXRjaCA9IGFib3J0YWJsZUZldGNoRGVjb3JhdG9yKHNlbGYpLFxuICAgICAgICBmZXRjaCA9IF9hYm9ydGFibGVGZXRjaC5mZXRjaCxcbiAgICAgICAgUmVxdWVzdCA9IF9hYm9ydGFibGVGZXRjaC5SZXF1ZXN0O1xuXG4gICAgc2VsZi5mZXRjaCA9IGZldGNoO1xuICAgIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICdBYm9ydENvbnRyb2xsZXInLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEFib3J0Q29udHJvbGxlclxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCAnQWJvcnRTaWduYWwnLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IEFib3J0U2lnbmFsXG4gICAgfSk7XG4gIH0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiBjb21tb25qc0dsb2JhbCk7XG5cbn0pKSk7XG5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzQ5ODBcblxudHJ5IHtcbiAgbmV3IHdpbmRvdy5FdmVudFRhcmdldCgpO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgd2luZG93LkV2ZW50VGFyZ2V0ID0gRXZlbnRUYXJnZXQkMTtcbn1cblxuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5jb25zdCBhc3NlcnQgPSAoY29uZGl0aW9uLCBkZXNjcmlwdGlvbikgPT4ge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQXNzZXJ0aW9uIGZhaWxlZCR7ZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCA/IGA6ICR7ZGVzY3JpcHRpb259YCA6ICcuJ31gO1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcblxuY2xhc3MgVUlIYW5kbGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKG5hamEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYWphID0gbmFqYTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9ICcuYWpheCc7XG4gICAgICAgIHRoaXMuYWxsb3dlZE9yaWdpbnMgPSBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl07XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IHRoaXMuaGFuZGxlVUkuYmluZCh0aGlzKTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdpbml0JywgdGhpcy5pbml0aWFsaXplLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLmJpbmRVSSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIHRoaXMubmFqYS5zbmlwcGV0SGFuZGxlci5hZGRFdmVudExpc3RlbmVyKCdhZnRlclVwZGF0ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzbmlwcGV0IH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICB0aGlzLmJpbmRVSShzbmlwcGV0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRVSShlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IFtcbiAgICAgICAgICAgIGBhJHt0aGlzLnNlbGVjdG9yfWAsXG4gICAgICAgICAgICBgaW5wdXRbdHlwZT1cInN1Ym1pdFwiXSR7dGhpcy5zZWxlY3Rvcn1gLFxuICAgICAgICAgICAgYGlucHV0W3R5cGU9XCJpbWFnZVwiXSR7dGhpcy5zZWxlY3Rvcn1gLFxuICAgICAgICAgICAgYGJ1dHRvblt0eXBlPVwic3VibWl0XCJdJHt0aGlzLnNlbGVjdG9yfWAsXG4gICAgICAgICAgICBgZm9ybSR7dGhpcy5zZWxlY3Rvcn0gaW5wdXRbdHlwZT1cInN1Ym1pdFwiXWAsXG4gICAgICAgICAgICBgZm9ybSR7dGhpcy5zZWxlY3Rvcn0gaW5wdXRbdHlwZT1cImltYWdlXCJdYCxcbiAgICAgICAgICAgIGBmb3JtJHt0aGlzLnNlbGVjdG9yfSBidXR0b25bdHlwZT1cInN1Ym1pdFwiXWAsXG4gICAgICAgIF0uam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgYmluZEVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlcik7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmluZEVsZW1lbnQoZWxlbWVudHMuaXRlbShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQubWF0Y2hlcyhzZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICBiaW5kRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5kRm9ybSA9IChmb3JtKSA9PiB7XG4gICAgICAgICAgICBmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuaGFuZGxlcik7XG4gICAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChlbGVtZW50Lm1hdGNoZXMoYGZvcm0ke3RoaXMuc2VsZWN0b3J9YCkpIHtcbiAgICAgICAgICAgIGJpbmRGb3JtKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1zID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGBmb3JtJHt0aGlzLnNlbGVjdG9yfWApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiaW5kRm9ybShmb3Jtcy5pdGVtKGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVVSShldmVudCkge1xuICAgICAgICBjb25zdCBtb3VzZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGlmIChtb3VzZUV2ZW50LmFsdEtleSB8fCBtb3VzZUV2ZW50LmN0cmxLZXkgfHwgbW91c2VFdmVudC5zaGlmdEtleSB8fCBtb3VzZUV2ZW50Lm1ldGFLZXkgfHwgbW91c2VFdmVudC5idXR0b24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCBpZ25vcmVFcnJvcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBkb24ndCByZWplY3QgdGhlIHByb21pc2UgaW4gY2FzZSBvZiBhbiBlcnJvciBhcyBkZXZlbG9wZXJzIGhhdmUgbm8gd2F5IG9mIGhhbmRsaW5nIHRoZSByZWplY3Rpb25cbiAgICAgICAgICAgIC8vIGluIHRoaXMgc2l0dWF0aW9uOyBlcnJvcnMgc2hvdWxkIGJlIGhhbmRsZWQgaW4gYG5hamEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckhhbmRsZXIpYFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0Rm9ybShlbGVtZW50LCBvcHRpb25zLCBldmVudCkuY2F0Y2goaWdub3JlRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrRWxlbWVudChlbGVtZW50LCBvcHRpb25zLCBtb3VzZUV2ZW50KS5jYXRjaChpZ25vcmVFcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNsaWNrRWxlbWVudChlbGVtZW50LCBvcHRpb25zID0ge30sIGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ0dFVCcsIHVybCA9ICcnLCBkYXRhO1xuICAgICAgICBpZiAoIXRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2ludGVyYWN0aW9uJywgeyBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IHsgZWxlbWVudCwgb3JpZ2luYWxFdmVudDogZXZlbnQsIG9wdGlvbnMgfSB9KSkpIHtcbiAgICAgICAgICAgIGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgYXNzZXJ0KGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHVybCA9IGVsZW1lbnQuaHJlZjtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICAgICAgICBhc3NlcnQoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybSB9ID0gZWxlbWVudDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeSxuby1leHRyYS1wYXJlbnNcbiAgICAgICAgICAgIG1ldGhvZCA9IChfZCA9IChfYiA9IChfYSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb3JtbWV0aG9kJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1VwcGVyQ2FzZSgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoX2MgPSBmb3JtID09PSBudWxsIHx8IGZvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm0uZ2V0QXR0cmlidXRlKCdtZXRob2QnKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvVXBwZXJDYXNlKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICdHRVQnO1xuICAgICAgICAgICAgdXJsID0gKF9mID0gKF9lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Zvcm1hY3Rpb24nKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZm9ybSA9PT0gbnVsbCB8fCBmb3JtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtLmdldEF0dHJpYnV0ZSgnYWN0aW9uJykpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICAgICAgICBkYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0gIT09IG51bGwgJiYgZm9ybSAhPT0gdm9pZCAwID8gZm9ybSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnc3VibWl0JyB8fCBlbGVtZW50LnRhZ05hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoZWxlbWVudC5uYW1lLCBlbGVtZW50LnZhbHVlIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoYCR7ZWxlbWVudC5uYW1lfS54YCwgTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihldmVudCAhPT0gdW5kZWZpbmVkID8gZXZlbnQucGFnZVggLSBjb29yZHMubGVmdCA6IDApKSk7XG4gICAgICAgICAgICAgICAgZGF0YS5hcHBlbmQoYCR7ZWxlbWVudC5uYW1lfS55YCwgTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihldmVudCAhPT0gdW5kZWZpbmVkID8gZXZlbnQucGFnZVkgLSBjb29yZHMudG9wIDogMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNVcmxBbGxvd2VkKHVybCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRpc3BhdGNoIGFzeW5jIHJlcXVlc3QsIFVSTCBpcyBub3QgYWxsb3dlZDogJHt1cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5hamEubWFrZVJlcXVlc3QobWV0aG9kLCB1cmwsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdWJtaXRGb3JtKGZvcm0sIG9wdGlvbnMgPSB7fSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICghdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW50ZXJhY3Rpb24nLCB7IGNhbmNlbGFibGU6IHRydWUsIGRldGFpbDogeyBlbGVtZW50OiBmb3JtLCBvcmlnaW5hbEV2ZW50OiBldmVudCwgb3B0aW9ucyB9IH0pKSkge1xuICAgICAgICAgICAgZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9iID0gKF9hID0gZm9ybS5nZXRBdHRyaWJ1dGUoJ21ldGhvZCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9VcHBlckNhc2UoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHVybCA9IChfYyA9IGZvcm0uZ2V0QXR0cmlidXRlKCdhY3Rpb24nKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXJsQWxsb3dlZCh1cmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkaXNwYXRjaCBhc3luYyByZXF1ZXN0LCBVUkwgaXMgbm90IGFsbG93ZWQ6ICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uYWphLm1ha2VSZXF1ZXN0KG1ldGhvZCwgdXJsLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaXNVcmxBbGxvd2VkKHVybCkge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIC8vIGlnbm9yZSBub24tVVJMIFVSSXMgKGphdmFzY3JpcHQ6LCBkYXRhOiwgbWFpbHRvOiwgLi4uKVxuICAgICAgICBpZiAodXJsT2JqZWN0Lm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb3dlZE9yaWdpbnMuaW5jbHVkZXModXJsT2JqZWN0Lm9yaWdpbik7XG4gICAgfVxufVxuXG5jbGFzcyBGb3Jtc0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hamEpIHtcbiAgICAgICAgdGhpcy5uYWphID0gbmFqYTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdpbml0JywgdGhpcy5pbml0aWFsaXplLmJpbmQodGhpcykpO1xuICAgICAgICBuYWphLnVpSGFuZGxlci5hZGRFdmVudExpc3RlbmVyKCdpbnRlcmFjdGlvbicsIHRoaXMucHJvY2Vzc0Zvcm0uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuaW5pdEZvcm1zKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcbiAgICAgICAgdGhpcy5uYWphLnNuaXBwZXRIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2FmdGVyVXBkYXRlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNuaXBwZXQgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHRoaXMuaW5pdEZvcm1zKHNuaXBwZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdEZvcm1zKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgbmV0dGVGb3JtcyA9IHRoaXMubmV0dGVGb3JtcyB8fCB3aW5kb3cuTmV0dGU7XG4gICAgICAgIGlmIChuZXR0ZUZvcm1zKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnZm9ybScpIHtcbiAgICAgICAgICAgICAgICBuZXR0ZUZvcm1zLmluaXRGb3JtKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm9ybXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXR0ZUZvcm1zLmluaXRGb3JtKGZvcm1zLml0ZW0oaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NGb3JtKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgb3JpZ2luYWxFdmVudCB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBpZiAoaW5wdXRFbGVtZW50LmZvcm0gIT09IHVuZGVmaW5lZCAmJiBpbnB1dEVsZW1lbnQuZm9ybSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXRFbGVtZW50LmZvcm1bJ25ldHRlLXN1Ym1pdHRlZEJ5J10gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHRlRm9ybXMgPSB0aGlzLm5ldHRlRm9ybXMgfHwgd2luZG93Lk5ldHRlO1xuICAgICAgICBpZiAoKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0ZPUk0nIHx8IGVsZW1lbnQuZm9ybSkgJiYgbmV0dGVGb3JtcyAmJiAhbmV0dGVGb3Jtcy52YWxpZGF0ZUZvcm0oZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSZWRpcmVjdEhhbmRsZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IobmFqYSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hamEgPSBuYWphO1xuICAgICAgICBuYWphLnVpSGFuZGxlci5hZGRFdmVudExpc3RlbmVyKCdpbnRlcmFjdGlvbicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1uYWphLWZvcmNlLXJlZGlyZWN0JykgfHwgKChfYSA9IGVsZW1lbnQuZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc0F0dHJpYnV0ZSgnZGF0YS1uYWphLWZvcmNlLXJlZGlyZWN0JykpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoX2IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uYWphLWZvcmNlLXJlZGlyZWN0JykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IGVsZW1lbnQuZm9ybSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldEF0dHJpYnV0ZSgnZGF0YS1uYWphLWZvcmNlLXJlZGlyZWN0Jyk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mb3JjZVJlZGlyZWN0ID0gdmFsdWUgIT09ICdvZmYnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQsIG9wdGlvbnMgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWtlUmVkaXJlY3QocGF5bG9hZC5yZWRpcmVjdCwgKF9hID0gb3B0aW9ucy5mb3JjZVJlZGlyZWN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxvY2F0aW9uQWRhcHRlciA9IHtcbiAgICAgICAgICAgIGFzc2lnbjogKHVybCkgPT4gd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtYWtlUmVkaXJlY3QodXJsLCBmb3JjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc0hhcmRSZWRpcmVjdCA9IGZvcmNlIHx8ICF0aGlzLm5hamEudWlIYW5kbGVyLmlzVXJsQWxsb3dlZCh1cmwpO1xuICAgICAgICBjb25zdCBjYW5SZWRpcmVjdCA9IHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3JlZGlyZWN0Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBpc0hhcmRSZWRpcmVjdCxcbiAgICAgICAgICAgICAgICBzZXRIYXJkUmVkaXJlY3QodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNIYXJkUmVkaXJlY3QgPSAhIXZhbHVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCFjYW5SZWRpcmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0hhcmRSZWRpcmVjdCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhdGlvbkFkYXB0ZXIuYXNzaWduKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5hamEubWFrZVJlcXVlc3QoJ0dFVCcsIHVybCwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNuaXBwZXRIYW5kbGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKG5hamEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYWphID0gbmFqYTtcbiAgICAgICAgdGhpcy5vcCA9IHtcbiAgICAgICAgICAgIHJlcGxhY2U6IChzbmlwcGV0LCBjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc25pcHBldC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZXBlbmQ6IChzbmlwcGV0LCBjb250ZW50KSA9PiBzbmlwcGV0Lmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIGNvbnRlbnQpLFxuICAgICAgICAgICAgYXBwZW5kOiAoc25pcHBldCwgY29udGVudCkgPT4gc25pcHBldC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGNvbnRlbnQpLFxuICAgICAgICB9O1xuICAgICAgICBuYWphLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcGF5bG9hZCB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuc25pcHBldHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNuaXBwZXRzKHBheWxvYWQuc25pcHBldHMsIGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNuaXBwZXRzKHNuaXBwZXRzLCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNuaXBwZXRzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc25pcHBldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTbmlwcGV0KHNuaXBwZXQsIHNuaXBwZXRzW2lkXSwgZnJvbUNhY2hlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNuaXBwZXQoc25pcHBldCwgY29udGVudCwgZnJvbUNhY2hlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBvcGVyYXRpb24gPSB0aGlzLm9wLnJlcGxhY2U7XG4gICAgICAgIGlmICgoc25pcHBldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbmFqYS1zbmlwcGV0LXByZXBlbmQnKSB8fCBzbmlwcGV0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1hamF4LXByZXBlbmQnKSkgJiYgIWZyb21DYWNoZSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gdGhpcy5vcC5wcmVwZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzbmlwcGV0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1uYWphLXNuaXBwZXQtYXBwZW5kJykgfHwgc25pcHBldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWpheC1hcHBlbmQnKSkgJiYgIWZyb21DYWNoZSkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gdGhpcy5vcC5hcHBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuVXBkYXRlID0gdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYmVmb3JlVXBkYXRlJywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHNuaXBwZXQsXG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICBmcm9tQ2FjaGUsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGNoYW5nZU9wZXJhdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICghY2FuVXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuaXBwZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICBkb2N1bWVudC50aXRsZSA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcGVyYXRpb24oc25pcHBldCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYWZ0ZXJVcGRhdGUnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgc25pcHBldCxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgIGZyb21DYWNoZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cbmNsYXNzIEhpc3RvcnlIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYWphKSB7XG4gICAgICAgIHRoaXMubmFqYSA9IG5hamE7XG4gICAgICAgIHRoaXMuaHJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMucG9wU3RhdGVIYW5kbGVyID0gdGhpcy5oYW5kbGVQb3BTdGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnVpQ2FjaGUgPSB0cnVlO1xuICAgICAgICBuYWphLmFkZEV2ZW50TGlzdGVuZXIoJ2luaXQnLCB0aGlzLmluaXRpYWxpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIG5hamEuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlJywgdGhpcy5zYXZlVXJsLmJpbmQodGhpcykpO1xuICAgICAgICBuYWphLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCB0aGlzLnB1c2hOZXdTdGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbmFqYS51aUhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcignaW50ZXJhY3Rpb24nLCB0aGlzLmNvbmZpZ3VyZU1vZGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUFkYXB0ZXIgPSB7XG4gICAgICAgICAgICByZXBsYWNlU3RhdGU6IChkYXRhLCB0aXRsZSwgdXJsKSA9PiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoZGF0YSwgdGl0bGUsIHVybCksXG4gICAgICAgICAgICBwdXNoU3RhdGU6IChkYXRhLCB0aXRsZSwgdXJsKSA9PiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoZGF0YSwgdGl0bGUsIHVybCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRpYWxpemUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0T3B0aW9ucyB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAoJ2hpc3RvcnlVaUNhY2hlJyBpbiBkZWZhdWx0T3B0aW9ucyAmJiBkZWZhdWx0T3B0aW9ucy5oaXN0b3J5VWlDYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVpQ2FjaGUgPSBkZWZhdWx0T3B0aW9ucy5oaXN0b3J5VWlDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLnBvcFN0YXRlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGlzdG9yeUFkYXB0ZXIucmVwbGFjZVN0YXRlKHRoaXMuYnVpbGRTdGF0ZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgdGhpcy51aUNhY2hlKSwgd2luZG93LmRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgfVxuICAgIGhhbmRsZVBvcFN0YXRlKGUpIHtcbiAgICAgICAgaWYgKCFlLnN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3RhdGUudWkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU25pcHBldHMoZS5zdGF0ZS51aSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRpdGxlKGUuc3RhdGUudGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUuc3RhdGUudWkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLm5hamEubWFrZVJlcXVlc3QoJ0dFVCcsIGUuc3RhdGUuaHJlZiwgbnVsbCwge1xuICAgICAgICAgICAgICAgIGhpc3Rvcnk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhpc3RvcnlVaUNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhdmVVcmwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB1cmwgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgdGhpcy5ocmVmID0gdXJsO1xuICAgIH1cbiAgICBjb25maWd1cmVNb2RlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIG9wdGlvbnMgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgLy8gcHJvcGFnYXRlIG1vZGUgdG8gb3B0aW9uc1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbmFqYS1oaXN0b3J5JykgfHwgKChfYSA9IGVsZW1lbnQuZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc0F0dHJpYnV0ZSgnZGF0YS1uYWphLWhpc3RvcnknKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKF9iID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFqYS1oaXN0b3J5JykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IGVsZW1lbnQuZm9ybSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldEF0dHJpYnV0ZSgnZGF0YS1uYWphLWhpc3RvcnknKTtcbiAgICAgICAgICAgIG9wdGlvbnMuaGlzdG9yeSA9IEhpc3RvcnlIYW5kbGVyLm5vcm1hbGl6ZU1vZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1uYWphLWhpc3RvcnktY2FjaGUnKSB8fCAoKF9kID0gZWxlbWVudC5mb3JtKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGFzQXR0cmlidXRlKCdkYXRhLW5hamEtaGlzdG9yeS1ub2NhY2hlJykpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChfZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5hamEtaGlzdG9yeS1jYWNoZScpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAoX2YgPSBlbGVtZW50LmZvcm0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFqYS1oaXN0b3J5LWNhY2hlJyk7XG4gICAgICAgICAgICBvcHRpb25zLmhpc3RvcnlVaUNhY2hlID0gdmFsdWUgIT09ICdvZmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpemVNb2RlKG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdvZmYnIHx8IG1vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JlcGxhY2UnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwdXNoTmV3U3RhdGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBwYXlsb2FkLCBvcHRpb25zIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBIaXN0b3J5SGFuZGxlci5ub3JtYWxpemVNb2RlKG9wdGlvbnMuaGlzdG9yeSk7XG4gICAgICAgIGlmIChtb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkLnBvc3RHZXQgJiYgcGF5bG9hZC51cmwpIHtcbiAgICAgICAgICAgIHRoaXMuaHJlZiA9IHBheWxvYWQudXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IG1vZGUgPT09ICdyZXBsYWNlJyA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSc7XG4gICAgICAgIGNvbnN0IHVpQ2FjaGUgPSBvcHRpb25zLmhpc3RvcnlVaUNhY2hlID09PSB0cnVlIHx8IChvcHRpb25zLmhpc3RvcnlVaUNhY2hlICE9PSBmYWxzZSAmJiB0aGlzLnVpQ2FjaGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICB0aGlzLmhpc3RvcnlBZGFwdGVyW21ldGhvZF0odGhpcy5idWlsZFN0YXRlKHRoaXMuaHJlZiwgdWlDYWNoZSksIHdpbmRvdy5kb2N1bWVudC50aXRsZSwgdGhpcy5ocmVmKTtcbiAgICAgICAgdGhpcy5ocmVmID0gbnVsbDtcbiAgICB9XG4gICAgYnVpbGRTdGF0ZShocmVmLCB1aUNhY2hlKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHVpQ2FjaGUpIHtcbiAgICAgICAgICAgIHN0YXRlLnRpdGxlID0gd2luZG93LmRvY3VtZW50LnRpdGxlO1xuICAgICAgICAgICAgc3RhdGUudWkgPSB0aGlzLmZpbmRTbmlwcGV0cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudWkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGZpbmRTbmlwcGV0cygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGNvbnN0IHNuaXBwZXRzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF49XCJzbmlwcGV0LVwiXScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNuaXBwZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzbmlwcGV0ID0gc25pcHBldHMuaXRlbShpKTtcbiAgICAgICAgICAgIGlmICghc25pcHBldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbmFqYS1oaXN0b3J5LW5vY2FjaGUnKSAmJiAhc25pcHBldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtaGlzdG9yeS1ub2NhY2hlJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbc25pcHBldC5pZF0gPSBzbmlwcGV0LmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoYW5kbGVTbmlwcGV0cyhzbmlwcGV0cykge1xuICAgICAgICB0aGlzLm5hamEuc25pcHBldEhhbmRsZXIudXBkYXRlU25pcHBldHMoc25pcHBldHMsIHRydWUpO1xuICAgICAgICB0aGlzLm5hamEuc2NyaXB0TG9hZGVyLmxvYWRTY3JpcHRzKHNuaXBwZXRzKTtcbiAgICB9XG4gICAgaGFuZGxlVGl0bGUodGl0bGUpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gICAgfVxufVxuXG5jbGFzcyBTY3JpcHRMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hamEpIHtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLnNuaXBwZXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkU2NyaXB0cyhwYXlsb2FkLnNuaXBwZXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRTY3JpcHRzKHNuaXBwZXRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNuaXBwZXRzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHNuaXBwZXRzW2lkXTtcbiAgICAgICAgICAgIGlmICghLzxzY3JpcHQvaS50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWwgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gc2NyaXB0cy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgIHNjcmlwdEVsLmlubmVySFRNTCA9IHNjcmlwdC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzY3JpcHQuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSBhdHRyc1tqXS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0RWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1tqXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpXG4gICAgICAgICAgICAgICAgICAgIC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBOYWphIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHVpSGFuZGxlciwgcmVkaXJlY3RIYW5kbGVyLCBzbmlwcGV0SGFuZGxlciwgZm9ybXNIYW5kbGVyLCBoaXN0b3J5SGFuZGxlciwgc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuVkVSU0lPTiA9IDI7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gW107XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy51aUhhbmRsZXIgPSB1aUhhbmRsZXIgPyBuZXcgdWlIYW5kbGVyKHRoaXMpIDogbmV3IFVJSGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdEhhbmRsZXIgPSByZWRpcmVjdEhhbmRsZXIgPyBuZXcgcmVkaXJlY3RIYW5kbGVyKHRoaXMpIDogbmV3IFJlZGlyZWN0SGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zbmlwcGV0SGFuZGxlciA9IHNuaXBwZXRIYW5kbGVyID8gbmV3IHNuaXBwZXRIYW5kbGVyKHRoaXMpIDogbmV3IFNuaXBwZXRIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmZvcm1zSGFuZGxlciA9IGZvcm1zSGFuZGxlciA/IG5ldyBmb3Jtc0hhbmRsZXIodGhpcykgOiBuZXcgRm9ybXNIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmhpc3RvcnlIYW5kbGVyID0gaGlzdG9yeUhhbmRsZXIgPyBuZXcgaGlzdG9yeUhhbmRsZXIodGhpcykgOiBuZXcgSGlzdG9yeUhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2NyaXB0TG9hZGVyID0gc2NyaXB0TG9hZGVyID8gbmV3IHNjcmlwdExvYWRlcih0aGlzKSA6IG5ldyBTY3JpcHRMb2FkZXIodGhpcyk7XG4gICAgfVxuICAgIHJlZ2lzdGVyRXh0ZW5zaW9uKGV4dGVuc2lvbikge1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHRlbnNpb25zLnB1c2goZXh0ZW5zaW9uKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbml0aWFsaXplIE5hamEsIGl0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24uaW5pdGlhbGl6ZSh0aGlzKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2luaXQnLCB7IGRldGFpbDogeyBkZWZhdWx0T3B0aW9ucyB9IH0pKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIG1ha2VSZXF1ZXN0KG1ldGhvZCwgdXJsLCBkYXRhID0gbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB1cmwgdG8gaW5zdGFuY2VvZiBVUkxcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyksIHsgZmV0Y2g6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucy5mZXRjaCB8fCB7fSksIG9wdGlvbnMuZmV0Y2ggfHwge30pIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5mZXRjaC5oZWFkZXJzIHx8IHt9KTtcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMudHJhbnNmb3JtRGF0YSh1cmwsIG1ldGhvZCwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybC50b1N0cmluZygpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9LCBvcHRpb25zLmZldGNoKSwgeyBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keSwgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH0pKTtcbiAgICAgICAgLy8gaW1wZXJzb25hdGUgWEhSIHNvIHRoYXQgTmV0dGUgY2FuIGRldGVjdCBpc0FqYXgoKVxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuc2V0KCdYLVJlcXVlc3RlZC1XaXRoJywgJ1hNTEh0dHBSZXF1ZXN0Jyk7XG4gICAgICAgIGlmICghdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYmVmb3JlJywgeyBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IHsgcmVxdWVzdCwgbWV0aG9kLCB1cmw6IHVybC50b1N0cmluZygpLCBkYXRhLCBvcHRpb25zIH0gfSkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHdpbmRvdy5mZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc3RhcnQnLCB7IGRldGFpbDogeyByZXF1ZXN0LCBwcm9taXNlLCBhYm9ydENvbnRyb2xsZXIsIG9wdGlvbnMgfSB9KSk7XG4gICAgICAgIGxldCByZXNwb25zZSwgcGF5bG9hZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBheWxvYWQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYWJvcnQnLCB7IGRldGFpbDogeyByZXF1ZXN0LCBlcnJvciwgb3B0aW9ucyB9IH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjb21wbGV0ZScsIHsgZGV0YWlsOiB7IHJlcXVlc3QsIHJlc3BvbnNlLCBwYXlsb2FkOiB1bmRlZmluZWQsIGVycm9yLCBvcHRpb25zIH0gfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2Vycm9yJywgeyBkZXRhaWw6IHsgcmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yLCBvcHRpb25zIH0gfSkpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY29tcGxldGUnLCB7IGRldGFpbDogeyByZXF1ZXN0LCByZXNwb25zZSwgcGF5bG9hZDogdW5kZWZpbmVkLCBlcnJvciwgb3B0aW9ucyB9IH0pKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3N1Y2Nlc3MnLCB7IGRldGFpbDogeyByZXF1ZXN0LCByZXNwb25zZSwgcGF5bG9hZCwgb3B0aW9ucyB9IH0pKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnY29tcGxldGUnLCB7IGRldGFpbDogeyByZXF1ZXN0LCByZXNwb25zZSwgcGF5bG9hZCwgZXJyb3I6IHVuZGVmaW5lZCwgb3B0aW9ucyB9IH0pKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIGFwcGVuZFRvUXVlcnlTdHJpbmcoc2VhcmNoUGFyYW1zLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJ2YWx1ZSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9RdWVyeVN0cmluZyhzZWFyY2hQYXJhbXMsIGAke2tleX1bJHtpbmRleCsrfV1gLCBzdWJ2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbc3Via2V5LCBzdWJ2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb1F1ZXJ5U3RyaW5nKHNlYXJjaFBhcmFtcywgYCR7a2V5fVske3N1YmtleX1dYCwgc3VidmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybURhdGEodXJsLCBtZXRob2QsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgaXNHZXQgPSBbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXMobWV0aG9kLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAvLyBzZW5kaW5nIGEgZm9ybSB2aWEgR0VUIC0+IHNlcmlhbGl6ZSBGb3JtRGF0YSBpbnRvIFVSTCBhbmQgcmV0dXJuIGVtcHR5IHJlcXVlc3QgYm9keVxuICAgICAgICBpZiAoaXNHZXQgJiYgZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kaW5nIGEgUE9KTyAtPiBzZXJpYWxpemUgaXQgcmVjdXJzaXZlbHkgaW50byBVUkxTZWFyY2hQYXJhbXNcbiAgICAgICAgY29uc3QgaXNEYXRhUG9qbyA9IGRhdGEgIT09IG51bGwgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGRhdGEpID09PSBPYmplY3QucHJvdG90eXBlO1xuICAgICAgICBpZiAoaXNEYXRhUG9qbykge1xuICAgICAgICAgICAgLy8gZm9yIEdFVCByZXF1ZXN0cywgYXBwZW5kIHZhbHVlcyB0byBVUkwgYW5kIHJldHVybiBlbXB0eSByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBidWlsZCBgbmV3IFVSTFNlYXJjaFBhcmFtcygpYCB0byBhY3QgYXMgdGhlIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWREYXRhID0gaXNHZXQgPyB1cmwuc2VhcmNoUGFyYW1zIDogbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvUXVlcnlTdHJpbmcodHJhbnNmb3JtZWREYXRhLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc0dldFxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogdHJhbnNmb3JtZWREYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cbn1cblxuY2xhc3MgQWJvcnRFeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFib3J0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShuYWphKSB7XG4gICAgICAgIG5hamEudWlIYW5kbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ludGVyYWN0aW9uJywgdGhpcy5jaGVja0Fib3J0YWJsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdpbml0JywgdGhpcy5vbkluaXRpYWxpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIG5hamEuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlJywgdGhpcy5jaGVja0Fib3J0YWJsZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdzdGFydCcsIHRoaXMuc2F2ZUFib3J0Q29udHJvbGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIHRoaXMuY2xlYXJBYm9ydENvbnRyb2xsZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIG9uSW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgJiYgZXZlbnQua2V5ID09PSAnRXNjYXBlJ1xuICAgICAgICAgICAgICAgICYmICEoZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmFib3J0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tBYm9ydGFibGUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuYWJvcnRhYmxlID0gJ2VsZW1lbnQnIGluIGV2ZW50LmRldGFpbFxuICAgICAgICAgICAgPyAoKF9hID0gZXZlbnQuZGV0YWlsLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5hamEtYWJvcnQnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gZXZlbnQuZGV0YWlsLmVsZW1lbnQuZm9ybSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldEF0dHJpYnV0ZSgnZGF0YS1uYWphLWFib3J0JykpICE9PSAnb2ZmJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLXBhcmVuc1xuICAgICAgICAgICAgOiBvcHRpb25zLmFib3J0ICE9PSBmYWxzZTtcbiAgICAgICAgLy8gcHJvcGFnYXRlIHRvIG9wdGlvbnMgaWYgY2FsbGVkIGluIGludGVyYWN0aW9uIGV2ZW50XG4gICAgICAgIG9wdGlvbnMuYWJvcnQgPSB0aGlzLmFib3J0YWJsZTtcbiAgICB9XG4gICAgc2F2ZUFib3J0Q29udHJvbGxlcihldmVudCkge1xuICAgICAgICBjb25zdCB7IGFib3J0Q29udHJvbGxlciB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IGFib3J0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgY2xlYXJBYm9ydENvbnRyb2xsZXIoKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hYm9ydGFibGUgPSB0cnVlO1xuICAgIH1cbn1cblxuY2xhc3MgVW5pcXVlRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBpbml0aWFsaXplKG5hamEpIHtcbiAgICAgICAgbmFqYS51aUhhbmRsZXIuYWRkRXZlbnRMaXN0ZW5lcignaW50ZXJhY3Rpb24nLCB0aGlzLmNoZWNrVW5pcXVlbmVzcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgbmFqYS5hZGRFdmVudExpc3RlbmVyKCdzdGFydCcsIHRoaXMuYWJvcnRQcmV2aW91c1JlcXVlc3QuYmluZCh0aGlzKSk7XG4gICAgICAgIG5hamEuYWRkRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCB0aGlzLmNsZWFyUmVxdWVzdC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgY2hlY2tVbmlxdWVuZXNzKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgb3B0aW9ucyB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCB1bmlxdWUgPSAoX2EgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uYWphLXVuaXF1ZScpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IgPSBlbGVtZW50LmZvcm0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFqYS11bmlxdWUnKTtcbiAgICAgICAgb3B0aW9ucy51bmlxdWUgPSB1bmlxdWUgPT09ICdvZmYnID8gZmFsc2UgOiB1bmlxdWUgIT09IG51bGwgJiYgdW5pcXVlICE9PSB2b2lkIDAgPyB1bmlxdWUgOiAnZGVmYXVsdCc7XG4gICAgfVxuICAgIGFib3J0UHJldmlvdXNSZXF1ZXN0KGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB7IGFib3J0Q29udHJvbGxlciwgb3B0aW9ucyB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAob3B0aW9ucy51bmlxdWUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmFib3J0Q29udHJvbGxlcnMuZ2V0KChfYSA9IG9wdGlvbnMudW5pcXVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZGVmYXVsdCcpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVycy5zZXQoKF9jID0gb3B0aW9ucy51bmlxdWUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdkZWZhdWx0JywgYWJvcnRDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclJlcXVlc3QoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHJlcXVlc3QsIG9wdGlvbnMgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKCFyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkICYmIG9wdGlvbnMudW5pcXVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXJzLmRlbGV0ZSgoX2EgPSBvcHRpb25zLnVuaXF1ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2RlZmF1bHQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgbmFqYSA9IG5ldyBOYWphKCk7XG5uYWphLnJlZ2lzdGVyRXh0ZW5zaW9uKG5ldyBBYm9ydEV4dGVuc2lvbigpKTtcbm5hamEucmVnaXN0ZXJFeHRlbnNpb24obmV3IFVuaXF1ZUV4dGVuc2lvbigpKTtcblxuZXhwb3J0IGRlZmF1bHQgbmFqYTtcbmV4cG9ydCB7IEh0dHBFcnJvciwgTmFqYSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmFqYS5lc20uanMubWFwXG4iLCIvKipcbiAqIEFzc2VydCBhIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB0aGF0IGl0IHNob3VsZCBzYXRpc2Z5LlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIGZvciByZXBsYWNpbmcgcGxhY2Vob2xkZXJzIGluIHRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlKGNvbmRpdGlvbiwgbWVzc2FnZSwgLi4uYXJncykge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpKTtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnQgYSB0ZXh0IGFuZCBhcmd1bWVudHMgdG8gb25lIHN0cmluZy5cbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBmb3JtYXRpbmcgdGV4dFxuICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZSgvJVtvc10vZ3UsICgpID0+IGFueVRvU3RyaW5nKGFyZ3NbaSsrXSkpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geCBUaGUgdmFsdWUgdG8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFueVRvU3RyaW5nKHgpIHtcbiAgICBpZiAodHlwZW9mIHggIT09IFwib2JqZWN0XCIgfHwgeCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpO1xufVxuXG5sZXQgY3VycmVudEVycm9ySGFuZGxlcjtcbi8qKlxuICogU2V0IHRoZSBlcnJvciBoYW5kbGVyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBlcnJvciBoYW5kbGVyIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0RXJyb3JIYW5kbGVyKHZhbHVlKSB7XG4gICAgYXNzZXJ0VHlwZSh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkLCBcIlRoZSBlcnJvciBoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWQsIGJ1dCBnb3QgJW8uXCIsIHZhbHVlKTtcbiAgICBjdXJyZW50RXJyb3JIYW5kbGVyID0gdmFsdWU7XG59XG4vKipcbiAqIFByaW50IGEgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSBtYXliZUVycm9yIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlcG9ydEVycm9yKG1heWJlRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG1heWJlRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgPyBtYXliZUVycm9yXG4gICAgICAgICAgICA6IG5ldyBFcnJvcihhbnlUb1N0cmluZyhtYXliZUVycm9yKSk7XG4gICAgICAgIC8vIENhbGwgdGhlIHVzZXItZGVmaW5lZCBlcnJvciBoYW5kbGVyIGlmIGV4aXN0cy5cbiAgICAgICAgaWYgKGN1cnJlbnRFcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRFcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3BhdGNoIGFuIGBlcnJvcmAgZXZlbnQgaWYgdGhpcyBpcyBvbiBhIGJyb3dzZXIuXG4gICAgICAgIGlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2YgRXJyb3JFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBlcnJvciwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBhbiBgdW5jYXVnaHRFeGNlcHRpb25gIGV2ZW50IGlmIHRoaXMgaXMgb24gTm9kZS5qcy5cbiAgICAgICAgLy9pc3RhbmJ1bCBpZ25vcmUgZWxzZVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBwcmludCB0aGUgZXJyb3IuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgLy8gaWdub3JlLlxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgZ2xvYmFsIG9iamVjdC5cbiAqL1xuLy9pc3RhbmJ1bCBpZ25vcmUgbmV4dFxuY29uc3QgR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICA/IHNlbGZcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG5sZXQgY3VycmVudFdhcm5IYW5kbGVyO1xuLyoqXG4gKiBTZXQgdGhlIHdhcm5pbmcgaGFuZGxlci5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgd2FybmluZyBoYW5kbGVyIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0V2FybmluZ0hhbmRsZXIodmFsdWUpIHtcbiAgICBhc3NlcnRUeXBlKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQsIFwiVGhlIHdhcm5pbmcgaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkLCBidXQgZ290ICVvLlwiLCB2YWx1ZSk7XG4gICAgY3VycmVudFdhcm5IYW5kbGVyID0gdmFsdWU7XG59XG4vKipcbiAqIFRoZSB3YXJuaW5nIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBXYXJuaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcG9ydCB0aGlzIHdhcm5pbmcuXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyBvZiB0aGUgd2FybmluZy5cbiAgICAgKi9cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdXNlci1kZWZpbmVkIHdhcm5pbmcgaGFuZGxlciBpZiBleGlzdHMuXG4gICAgICAgICAgICBpZiAoY3VycmVudFdhcm5IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdhcm5IYW5kbGVyKHsgLi4udGhpcywgYXJncyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIHByaW50IHRoZSB3YXJuaW5nLlxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSAoKF9hID0gbmV3IEVycm9yKCkuc3RhY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCIpLnJlcGxhY2UoL14oPzouKz9cXG4pezJ9L2d1LCBcIlxcblwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lc3NhZ2UsIC4uLmFyZ3MsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZS5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgSW5pdEV2ZW50V2FzQ2FsbGVkV2hpbGVEaXNwYXRjaGluZyA9IG5ldyBXYXJuaW5nKFwiVzAxXCIsIFwiVW5hYmxlIHRvIGluaXRpYWxpemUgZXZlbnQgdW5kZXIgZGlzcGF0Y2hpbmcuXCIpO1xuY29uc3QgRmFsc3lXYXNBc3NpZ25lZFRvQ2FuY2VsQnViYmxlID0gbmV3IFdhcm5pbmcoXCJXMDJcIiwgXCJBc3NpZ25pbmcgYW55IGZhbHN5IHZhbHVlIHRvICdjYW5jZWxCdWJibGUnIHByb3BlcnR5IGhhcyBubyBlZmZlY3QuXCIpO1xuY29uc3QgVHJ1dGh5V2FzQXNzaWduZWRUb1JldHVyblZhbHVlID0gbmV3IFdhcm5pbmcoXCJXMDNcIiwgXCJBc3NpZ25pbmcgYW55IHRydXRoeSB2YWx1ZSB0byAncmV0dXJuVmFsdWUnIHByb3BlcnR5IGhhcyBubyBlZmZlY3QuXCIpO1xuY29uc3QgTm9uQ2FuY2VsYWJsZUV2ZW50V2FzQ2FuY2VsZWQgPSBuZXcgV2FybmluZyhcIlcwNFwiLCBcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBvbiBub24tY2FuY2VsYWJsZSBldmVudHMuXCIpO1xuY29uc3QgQ2FuY2VsZWRJblBhc3NpdmVMaXN0ZW5lciA9IG5ldyBXYXJuaW5nKFwiVzA1XCIsIFwiVW5hYmxlIHRvIHByZXZlbnREZWZhdWx0IGluc2lkZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIGludm9jYXRpb24uXCIpO1xuY29uc3QgRXZlbnRMaXN0ZW5lcldhc0R1cGxpY2F0ZWQgPSBuZXcgV2FybmluZyhcIlcwNlwiLCBcIkFuIGV2ZW50IGxpc3RlbmVyIHdhc24ndCBhZGRlZCBiZWNhdXNlIGl0IGhhcyBiZWVuIGFkZGVkIGFscmVhZHk6ICVvLCAlb1wiKTtcbmNvbnN0IE9wdGlvbldhc0lnbm9yZWQgPSBuZXcgV2FybmluZyhcIlcwN1wiLCBcIlRoZSAlbyBvcHRpb24gdmFsdWUgd2FzIGFiYW5kb25lZCBiZWNhdXNlIHRoZSBldmVudCBsaXN0ZW5lciB3YXNuJ3QgYWRkZWQgYXMgZHVwbGljYXRlZC5cIik7XG5jb25zdCBJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IG5ldyBXYXJuaW5nKFwiVzA4XCIsIFwiVGhlICdjYWxsYmFjaycgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB0aGF0IGhhcyAnaGFuZGxlRXZlbnQnIG1ldGhvZDogJW9cIik7XG5jb25zdCBJbnZhbGlkQXR0cmlidXRlSGFuZGxlciA9IG5ldyBXYXJuaW5nKFwiVzA5XCIsIFwiRXZlbnQgYXR0cmlidXRlIGhhbmRsZXIgbXVzdCBiZSBhIGZ1bmN0aW9uOiAlb1wiKTtcblxuLyplc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGBFdmVudGAgaW50ZXJmYWNlLCB0aGF0IHdyYXBzIGEgZ2l2ZW4gZXZlbnQgb2JqZWN0LlxuICogYEV2ZW50VGFyZ2V0YCBzaGltIGNhbiBjb250cm9sIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGlzIGBFdmVudGAgb2JqZWN0cy5cbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNldmVudFxuICovXG5jbGFzcyBFdmVudCB7XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1ub25lXG4gICAgICovXG4gICAgc3RhdGljIGdldCBOT05FKCkge1xuICAgICAgICByZXR1cm4gTk9ORTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jYXB0dXJpbmdfcGhhc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IENBUFRVUklOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIENBUFRVUklOR19QSEFTRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1hdF90YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEFUX1RBUkdFVCgpIHtcbiAgICAgICAgcmV0dXJuIEFUX1RBUkdFVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1idWJibGluZ19waGFzZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQlVCQkxJTkdfUEhBU0UoKSB7XG4gICAgICAgIHJldHVybiBCVUJCTElOR19QSEFTRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGlzIGV2ZW50IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIGV2ZW50SW5pdERpY3QgT3B0aW9ucyB0byBpbml0aWFsaXplLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtZXZlbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBldmVudEluaXREaWN0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHJ1c3RlZFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGV2ZW50SW5pdERpY3QgIT09IG51bGwgJiYgZXZlbnRJbml0RGljdCAhPT0gdm9pZCAwID8gZXZlbnRJbml0RGljdCA6IHt9O1xuICAgICAgICBpbnRlcm5hbERhdGFNYXAuc2V0KHRoaXMsIHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyh0eXBlKSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IEJvb2xlYW4ob3B0cy5idWJibGVzKSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IEJvb2xlYW4ob3B0cy5jYW5jZWxhYmxlKSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiBCb29sZWFuKG9wdHMuY29tcG9zZWQpLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbkZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZzogZmFsc2UsXG4gICAgICAgICAgICBjYW5jZWxlZEZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgaW5QYXNzaXZlTGlzdGVuZXJGbGFnOiBmYWxzZSxcbiAgICAgICAgICAgIGRpc3BhdGNoRmxhZzogZmFsc2UsXG4gICAgICAgICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIGV2ZW50LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtdHlwZVxuICAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtdGFyZ2V0XG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgYHRhcmdldGAgcHJvcGVydHkgaW5zdGVhZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXNyY2VsZW1lbnRcbiAgICAgKi9cbiAgICBnZXQgc3JjRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY3VycmVudHRhcmdldFxuICAgICAqL1xuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jdXJyZW50VGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdGFyZ2V0IG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoaW5nLlxuICAgICAqIFRoaXMgZG9lc24ndCBzdXBwb3J0IG5vZGUgdHJlZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWNvbXBvc2VkcGF0aFxuICAgICAqL1xuICAgIGNvbXBvc2VkUGF0aCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9ICQodGhpcykuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbY3VycmVudFRhcmdldF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LW5vbmVcbiAgICAgKi9cbiAgICBnZXQgTk9ORSgpIHtcbiAgICAgICAgcmV0dXJuIE5PTkU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FwdHVyaW5nX3BoYXNlXG4gICAgICovXG4gICAgZ2V0IENBUFRVUklOR19QSEFTRSgpIHtcbiAgICAgICAgcmV0dXJuIENBUFRVUklOR19QSEFTRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1hdF90YXJnZXRcbiAgICAgKi9cbiAgICBnZXQgQVRfVEFSR0VUKCkge1xuICAgICAgICByZXR1cm4gQVRfVEFSR0VUO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWJ1YmJsaW5nX3BoYXNlXG4gICAgICovXG4gICAgZ2V0IEJVQkJMSU5HX1BIQVNFKCkge1xuICAgICAgICByZXR1cm4gQlVCQkxJTkdfUEhBU0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGV2ZW50IHBoYXNlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtZXZlbnRwaGFzZVxuICAgICAqL1xuICAgIGdldCBldmVudFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5kaXNwYXRjaEZsYWcgPyAyIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBldmVudCBidWJibGluZy5cbiAgICAgKiBCZWNhdXNlIHRoaXMgc2hpbSBkb2Vzbid0IHN1cHBvcnQgbm9kZSB0cmVlLCB0aGlzIG1lcmVseSBjaGFuZ2VzIHRoZSBgY2FuY2VsQnViYmxlYCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXN0b3Bwcm9wYWdhdGlvblxuICAgICAqL1xuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgJCh0aGlzKS5zdG9wUHJvcGFnYXRpb25GbGFnID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIGV2ZW50IGJ1YmJsaW5nIHdhcyBzdG9wcGVkLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1jYW5jZWxidWJibGVcbiAgICAgKi9cbiAgICBnZXQgY2FuY2VsQnViYmxlKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5zdG9wUHJvcGFnYXRpb25GbGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIGV2ZW50IGJ1YmJsaW5nIGlmIGB0cnVlYCBpcyBzZXQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgc3RvcFByb3BhZ2F0aW9uKClgIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FuY2VsYnViYmxlXG4gICAgICovXG4gICAgc2V0IGNhbmNlbEJ1YmJsZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICQodGhpcykuc3RvcFByb3BhZ2F0aW9uRmxhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBGYWxzeVdhc0Fzc2lnbmVkVG9DYW5jZWxCdWJibGUud2FybigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgZXZlbnQgYnViYmxpbmcgYW5kIHN1YnNlcXVlbnQgZXZlbnQgbGlzdGVuZXIgY2FsbGluZ3MuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1zdG9waW1tZWRpYXRlcHJvcGFnYXRpb25cbiAgICAgKi9cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAkKHRoaXMpO1xuICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbkZsYWcgPSBkYXRhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbkZsYWcgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhpcyBldmVudCB3aWxsIGJ1YmJsZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWJ1YmJsZXNcbiAgICAgKi9cbiAgICBnZXQgYnViYmxlcygpIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykuYnViYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGVkIGJ5IHRoZSBgcHJldmVudERlZmF1bHQoKWAgbWV0aG9kLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY2FuY2VsYWJsZVxuICAgICAqL1xuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jYW5jZWxhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBhY3QuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgZGVmYXVsdFByZXZlbnRlZGAgcHJvZXBydHkgaW5zdGVhZC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LXJldHVybnZhbHVlXG4gICAgICovXG4gICAgZ2V0IHJldHVyblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gISQodGhpcykuY2FuY2VsZWRGbGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGZhbHNlYCBpcyBzZXQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBgcHJldmVudERlZmF1bHQoKWAgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1yZXR1cm52YWx1ZVxuICAgICAqL1xuICAgIHNldCByZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBzZXRDYW5jZWxGbGFnKCQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgVHJ1dGh5V2FzQXNzaWduZWRUb1JldHVyblZhbHVlLndhcm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ldmVudC1wcmV2ZW50ZGVmYXVsdFxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzZXRDYW5jZWxGbGFnKCQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2FzIGNhbmNlbGVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtZGVmYXVsdHByZXZlbnRlZFxuICAgICAqL1xuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gJCh0aGlzKS5jYW5jZWxlZEZsYWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtY29tcG9zZWRcbiAgICAgKi9cbiAgICBnZXQgY29tcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiAkKHRoaXMpLmNvbXBvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWV2ZW50LWlzdHJ1c3RlZFxuICAgICAqL1xuICAgIC8vaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBnZXQgaXNUcnVzdGVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZXZlbnQtdGltZXN0YW1wXG4gICAgICovXG4gICAgZ2V0IHRpbWVTdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuICQodGhpcykudGltZVN0YW1wO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBEb24ndCB1c2UgdGhpcyBtZXRob2QuIFRoZSBjb25zdHJ1Y3RvciBkaWQgaW5pdGlhbGl6YXRpb24uXG4gICAgICovXG4gICAgaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAkKHRoaXMpO1xuICAgICAgICBpZiAoZGF0YS5kaXNwYXRjaEZsYWcpIHtcbiAgICAgICAgICAgIEluaXRFdmVudFdhc0NhbGxlZFdoaWxlRGlzcGF0Y2hpbmcud2FybigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGludGVybmFsRGF0YU1hcC5zZXQodGhpcywge1xuICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyh0eXBlKSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IEJvb2xlYW4oYnViYmxlcyksXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBCb29sZWFuKGNhbmNlbGFibGUpLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogbnVsbCxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbkZsYWc6IGZhbHNlLFxuICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZzogZmFsc2UsXG4gICAgICAgICAgICBjYW5jZWxlZEZsYWc6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IE5PTkUgPSAwO1xuY29uc3QgQ0FQVFVSSU5HX1BIQVNFID0gMTtcbmNvbnN0IEFUX1RBUkdFVCA9IDI7XG5jb25zdCBCVUJCTElOR19QSEFTRSA9IDM7XG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKi9cbmNvbnN0IGludGVybmFsRGF0YU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEdldCBwcml2YXRlIGRhdGEuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCB0byBnZXQgcHJpdmF0ZSBkYXRhLlxuICogQHBhcmFtIG5hbWUgVGhlIHZhcmlhYmxlIG5hbWUgdG8gcmVwb3J0LlxuICogQHJldHVybnMgVGhlIHByaXZhdGUgZGF0YSBvZiB0aGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uICQoZXZlbnQsIG5hbWUgPSBcInRoaXNcIikge1xuICAgIGNvbnN0IHJldHYgPSBpbnRlcm5hbERhdGFNYXAuZ2V0KGV2ZW50KTtcbiAgICBhc3NlcnRUeXBlKHJldHYgIT0gbnVsbCwgXCInJXMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgRXZlbnQgY29uc3RydWN0b3IgY3JlYXRlZCwgYnV0IGdvdCBhbm90aGVyIG9uZTogJW9cIiwgbmFtZSwgZXZlbnQpO1xuICAgIHJldHVybiByZXR2O1xufVxuLyoqXG4gKiBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI3NldC10aGUtY2FuY2VsZWQtZmxhZ1xuICogQHBhcmFtIGRhdGEgcHJpdmF0ZSBkYXRhLlxuICovXG5mdW5jdGlvbiBzZXRDYW5jZWxGbGFnKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5pblBhc3NpdmVMaXN0ZW5lckZsYWcpIHtcbiAgICAgICAgQ2FuY2VsZWRJblBhc3NpdmVMaXN0ZW5lci53YXJuKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkYXRhLmNhbmNlbGFibGUpIHtcbiAgICAgICAgTm9uQ2FuY2VsYWJsZUV2ZW50V2FzQ2FuY2VsZWQud2FybigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEuY2FuY2VsZWRGbGFnID0gdHJ1ZTtcbn1cbi8vIFNldCBlbnVtZXJhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQsIFwiTk9ORVwiLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQsIFwiQ0FQVFVSSU5HX1BIQVNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudCwgXCJBVF9UQVJHRVRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LCBcIkJVQkJMSU5HX1BIQVNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbmNvbnN0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhFdmVudC5wcm90b3R5cGUpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGtleXNbaV0gPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwga2V5c1tpXSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufVxuLy8gRW5zdXJlIGBldmVudCBpbnN0YW5jZW9mIHdpbmRvdy5FdmVudGAgaXMgYHRydWVgLlxuaWYgKHR5cGVvZiBHbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEdsb2JhbC5FdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihFdmVudC5wcm90b3R5cGUsIEdsb2JhbC5FdmVudC5wcm90b3R5cGUpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBJbnZhbGlkU3RhdGVFcnJvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcihtZXNzYWdlKSB7XG4gICAgaWYgKEdsb2JhbC5ET01FeGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWwuRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIFwiSW52YWxpZFN0YXRlRXJyb3JcIik7XG4gICAgfVxuICAgIGlmIChET01FeGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBET01FeGNlcHRpb24gPSBjbGFzcyBET01FeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBET01FeGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgICAgICAgICBnZXQgY29kZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgICAgICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZFN0YXRlRXJyb3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRE9NRXhjZXB0aW9uLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29kZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgICAgICBuYW1lOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZUVycm9yQ29kZVByb3BlcnRpZXMoRE9NRXhjZXB0aW9uKTtcbiAgICAgICAgZGVmaW5lRXJyb3JDb2RlUHJvcGVydGllcyhET01FeGNlcHRpb24ucHJvdG90eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24obWVzc2FnZSk7XG59XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBET01FeGNlcHRpb247XG5jb25zdCBFcnJvckNvZGVNYXAgPSB7XG4gICAgSU5ERVhfU0laRV9FUlI6IDEsXG4gICAgRE9NU1RSSU5HX1NJWkVfRVJSOiAyLFxuICAgIEhJRVJBUkNIWV9SRVFVRVNUX0VSUjogMyxcbiAgICBXUk9OR19ET0NVTUVOVF9FUlI6IDQsXG4gICAgSU5WQUxJRF9DSEFSQUNURVJfRVJSOiA1LFxuICAgIE5PX0RBVEFfQUxMT1dFRF9FUlI6IDYsXG4gICAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiA3LFxuICAgIE5PVF9GT1VORF9FUlI6IDgsXG4gICAgTk9UX1NVUFBPUlRFRF9FUlI6IDksXG4gICAgSU5VU0VfQVRUUklCVVRFX0VSUjogMTAsXG4gICAgSU5WQUxJRF9TVEFURV9FUlI6IDExLFxuICAgIFNZTlRBWF9FUlI6IDEyLFxuICAgIElOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUjogMTMsXG4gICAgTkFNRVNQQUNFX0VSUjogMTQsXG4gICAgSU5WQUxJRF9BQ0NFU1NfRVJSOiAxNSxcbiAgICBWQUxJREFUSU9OX0VSUjogMTYsXG4gICAgVFlQRV9NSVNNQVRDSF9FUlI6IDE3LFxuICAgIFNFQ1VSSVRZX0VSUjogMTgsXG4gICAgTkVUV09SS19FUlI6IDE5LFxuICAgIEFCT1JUX0VSUjogMjAsXG4gICAgVVJMX01JU01BVENIX0VSUjogMjEsXG4gICAgUVVPVEFfRVhDRUVERURfRVJSOiAyMixcbiAgICBUSU1FT1VUX0VSUjogMjMsXG4gICAgSU5WQUxJRF9OT0RFX1RZUEVfRVJSOiAyNCxcbiAgICBEQVRBX0NMT05FX0VSUjogMjUsXG59O1xuZnVuY3Rpb24gZGVmaW5lRXJyb3JDb2RlUHJvcGVydGllcyhvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoRXJyb3JDb2RlTWFwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBFcnJvckNvZGVNYXBba2V5XTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgRXZlbnRgIGludGVyZmFjZSwgdGhhdCB3cmFwcyBhIGdpdmVuIGV2ZW50IG9iamVjdC5cbiAqIFRoaXMgY2xhc3MgY29udHJvbHMgdGhlIGludGVybmFsIHN0YXRlIG9mIGBFdmVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jaW50ZXJmYWNlLWV2ZW50XG4gKi9cbmNsYXNzIEV2ZW50V3JhcHBlciBleHRlbmRzIEV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBXcmFwIGEgZ2l2ZW4gZXZlbnQgb2JqZWN0IHRvIGNvbnRyb2wgc3RhdGVzLlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQtbGlrZSBvYmplY3QgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd3JhcChldmVudCkge1xuICAgICAgICByZXR1cm4gbmV3IChnZXRXcmFwcGVyQ2xhc3NPZihldmVudCkpKGV2ZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICAgICAgc3VwZXIoZXZlbnQudHlwZSwge1xuICAgICAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IGV2ZW50LmNhbmNlbGFibGUsXG4gICAgICAgICAgICBjb21wb3NlZDogZXZlbnQuY29tcG9zZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXZlbnQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICBzdXBlci5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgc3VwZXIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcm5hbERhdGFNYXAkMS5zZXQodGhpcywgeyBvcmlnaW5hbDogZXZlbnQgfSk7XG4gICAgICAgIC8vIERlZmluZSBhY2Nlc3NvcnNcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKGV2ZW50LCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIHN1cGVyLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkJDEodGhpcyk7XG4gICAgICAgIGlmIChcInN0b3BQcm9wYWdhdGlvblwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FuY2VsQnViYmxlKCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuY2FuY2VsQnViYmxlO1xuICAgIH1cbiAgICBzZXQgY2FuY2VsQnViYmxlKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmNhbmNlbEJ1YmJsZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkJDEodGhpcyk7XG4gICAgICAgIGlmIChcImNhbmNlbEJ1YmJsZVwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5jYW5jZWxCdWJibGUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIHN1cGVyLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBjb25zdCB7IG9yaWdpbmFsIH0gPSAkJDEodGhpcyk7XG4gICAgICAgIGlmIChcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcmV0dXJuVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5yZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgc2V0IHJldHVyblZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnJldHVyblZhbHVlID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luYWwgfSA9ICQkMSh0aGlzKTtcbiAgICAgICAgaWYgKFwicmV0dXJuVmFsdWVcIiBpbiBvcmlnaW5hbCkge1xuICAgICAgICAgICAgb3JpZ2luYWwucmV0dXJuVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgc3VwZXIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgeyBvcmlnaW5hbCB9ID0gJCQxKHRoaXMpO1xuICAgICAgICBpZiAoXCJwcmV2ZW50RGVmYXVsdFwiIGluIG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBvcmlnaW5hbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0aW1lU3RhbXAoKSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luYWwgfSA9ICQkMSh0aGlzKTtcbiAgICAgICAgaWYgKFwidGltZVN0YW1wXCIgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC50aW1lU3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnRpbWVTdGFtcDtcbiAgICB9XG59XG4vKipcbiAqIFByaXZhdGUgZGF0YSBmb3IgZXZlbnQgd3JhcHBlcnMuXG4gKi9cbmNvbnN0IGludGVybmFsRGF0YU1hcCQxID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IHRvIGdldCBwcml2YXRlIGRhdGEuXG4gKiBAcmV0dXJucyBUaGUgcHJpdmF0ZSBkYXRhIG9mIHRoZSBldmVudC5cbiAqL1xuZnVuY3Rpb24gJCQxKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0diA9IGludGVybmFsRGF0YU1hcCQxLmdldChldmVudCk7XG4gICAgYXNzZXJ0VHlwZShyZXR2ICE9IG51bGwsIFwiJ3RoaXMnIGlzIGV4cGVjdGVkIGFuIEV2ZW50IG9iamVjdCwgYnV0IGdvdFwiLCBldmVudCk7XG4gICAgcmV0dXJuIHJldHY7XG59XG4vKipcbiAqIENhY2hlIGZvciB3cmFwcGVyIGNsYXNzZXMuXG4gKiBAdHlwZSB7V2Vha01hcDxPYmplY3QsIEZ1bmN0aW9uPn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHdyYXBwZXJDbGFzc0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbi8vIE1ha2UgYXNzb2NpYXRpb24gZm9yIHdyYXBwZXJzLlxud3JhcHBlckNsYXNzQ2FjaGUuc2V0KE9iamVjdC5wcm90b3R5cGUsIEV2ZW50V3JhcHBlcik7XG5pZiAodHlwZW9mIEdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgR2xvYmFsLkV2ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd3JhcHBlckNsYXNzQ2FjaGUuc2V0KEdsb2JhbC5FdmVudC5wcm90b3R5cGUsIEV2ZW50V3JhcHBlcik7XG59XG4vKipcbiAqIEdldCB0aGUgd3JhcHBlciBjbGFzcyBvZiBhIGdpdmVuIHByb3RvdHlwZS5cbiAqIEBwYXJhbSBvcmlnaW5hbEV2ZW50IFRoZSBldmVudCBvYmplY3QgdG8gd3JhcC5cbiAqL1xuZnVuY3Rpb24gZ2V0V3JhcHBlckNsYXNzT2Yob3JpZ2luYWxFdmVudCkge1xuICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbEV2ZW50KTtcbiAgICBpZiAocHJvdG90eXBlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50V3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHdyYXBwZXIgPSB3cmFwcGVyQ2xhc3NDYWNoZS5nZXQocHJvdG90eXBlKTtcbiAgICBpZiAod3JhcHBlciA9PSBudWxsKSB7XG4gICAgICAgIHdyYXBwZXIgPSBkZWZpbmVXcmFwcGVyKGdldFdyYXBwZXJDbGFzc09mKHByb3RvdHlwZSksIHByb3RvdHlwZSk7XG4gICAgICAgIHdyYXBwZXJDbGFzc0NhY2hlLnNldChwcm90b3R5cGUsIHdyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlcjtcbn1cbi8qKlxuICogRGVmaW5lIG5ldyB3cmFwcGVyIGNsYXNzLlxuICogQHBhcmFtIEJhc2VFdmVudFdyYXBwZXIgVGhlIGJhc2Ugd3JhcHBlciBjbGFzcy5cbiAqIEBwYXJhbSBvcmlnaW5hbFByb3RvdHlwZSBUaGUgcHJvdG90eXBlIG9mIHRoZSBvcmlnaW5hbCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lV3JhcHBlcihCYXNlRXZlbnRXcmFwcGVyLCBvcmlnaW5hbFByb3RvdHlwZSkge1xuICAgIGNsYXNzIEN1c3RvbUV2ZW50V3JhcHBlciBleHRlbmRzIEJhc2VFdmVudFdyYXBwZXIge1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3JpZ2luYWxQcm90b3R5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXZlbnRXcmFwcGVyLnByb3RvdHlwZSwga2V5c1tpXSwgZGVmaW5lUmVkaXJlY3REZXNjcmlwdG9yKG9yaWdpbmFsUHJvdG90eXBlLCBrZXlzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBDdXN0b21FdmVudFdyYXBwZXI7XG59XG4vKipcbiAqIEdldCB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciB0byByZWRpcmVjdCBhIGdpdmVuIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3Iob2JqLCBrZXkpIHtcbiAgICBjb25zdCBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSAkJDEodGhpcykub3JpZ2luYWw7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYmluZChvcmlnaW5hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSAkJDEodGhpcykub3JpZ2luYWw7XG4gICAgICAgICAgICBvcmlnaW5hbFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZC5jb25maWd1cmFibGUsXG4gICAgICAgIGVudW1lcmFibGU6IGQuZW51bWVyYWJsZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBsaXN0ZW5lci5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnLlxuICogQHBhcmFtIHBhc3NpdmUgVGhlIHBhc3NpdmUgZmxhZy5cbiAqIEBwYXJhbSBvbmNlIFRoZSBvbmNlIGZsYWcuXG4gKiBAcGFyYW0gc2lnbmFsIFRoZSBhYm9ydCBzaWduYWwuXG4gKiBAcGFyYW0gc2lnbmFsTGlzdGVuZXIgVGhlIGFib3J0IGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgYWJvcnQgc2lnbmFsLlxuICovXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lcihjYWxsYmFjaywgY2FwdHVyZSwgcGFzc2l2ZSwgb25jZSwgc2lnbmFsLCBzaWduYWxMaXN0ZW5lcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBmbGFnczogKGNhcHR1cmUgPyAxIC8qIENhcHR1cmUgKi8gOiAwKSB8XG4gICAgICAgICAgICAocGFzc2l2ZSA/IDIgLyogUGFzc2l2ZSAqLyA6IDApIHxcbiAgICAgICAgICAgIChvbmNlID8gNCAvKiBPbmNlICovIDogMCksXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgc2lnbmFsTGlzdGVuZXIsXG4gICAgfTtcbn1cbi8qKlxuICogU2V0IHRoZSBgcmVtb3ZlZGAgZmxhZyB0byB0aGUgZ2l2ZW4gbGlzdGVuZXIuXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBzZXRSZW1vdmVkKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIuZmxhZ3MgfD0gOCAvKiBSZW1vdmVkICovO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbGlzdGVuZXIgaGFzIHRoZSBgY2FwdHVyZWAgZmxhZyBvciBub3QuXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc0NhcHR1cmUobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgMSAvKiBDYXB0dXJlICovKSA9PT0gMSAvKiBDYXB0dXJlICovO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbGlzdGVuZXIgaGFzIHRoZSBgcGFzc2l2ZWAgZmxhZyBvciBub3QuXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1Bhc3NpdmUobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgMiAvKiBQYXNzaXZlICovKSA9PT0gMiAvKiBQYXNzaXZlICovO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbGlzdGVuZXIgaGFzIHRoZSBgb25jZWAgZmxhZyBvciBub3QuXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc09uY2UobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgNCAvKiBPbmNlICovKSA9PT0gNCAvKiBPbmNlICovO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbGlzdGVuZXIgaGFzIHRoZSBgcmVtb3ZlZGAgZmxhZyBvciBub3QuXG4gKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1JlbW92ZWQobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLmZsYWdzICYgOCAvKiBSZW1vdmVkICovKSA9PT0gOCAvKiBSZW1vdmVkICovO1xufVxuLyoqXG4gKiBDYWxsIGFuIGV2ZW50IGxpc3RlbmVyLlxuICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsLlxuICogQHBhcmFtIHRhcmdldCBUaGUgZXZlbnQgdGFyZ2V0IG9iamVjdCBmb3IgYHRoaXNBcmdgLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBvYmplY3QgZm9yIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSBhdHRyaWJ1dGUgYHRydWVgIGlmIHRoaXMgY2FsbGJhY2sgaXMgYW4gZXZlbnQgYXR0cmlidXRlIGhhbmRsZXIuXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHsgY2FsbGJhY2sgfSwgdGFyZ2V0LCBldmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2suaGFuZGxlRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2suaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoICh0aHJvd25FcnJvcikge1xuICAgICAgICByZXBvcnRFcnJvcih0aHJvd25FcnJvcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGluZGV4IG9mIGdpdmVuIGxpc3RlbmVyLlxuICogVGhpcyByZXR1cm5zIGAtMWAgaWYgbm90IGZvdW5kLlxuICogQHBhcmFtIGxpc3QgVGhlIGxpc3RlbmVyIGxpc3QuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpbmQuXG4gKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleE9mTGlzdGVuZXIoeyBsaXN0ZW5lcnMgfSwgY2FsbGJhY2ssIGNhcHR1cmUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgaXNDYXB0dXJlKGxpc3RlbmVyc1tpXSkgPT09IGNhcHR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBsaXN0ZW5lci5cbiAqIERvZXMgY29weS1vbi13cml0ZSBpZiBuZWVkZWQuXG4gKiBAcGFyYW0gbGlzdCBUaGUgbGlzdGVuZXIgbGlzdC5cbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0gY2FwdHVyZSBUaGUgY2FwdHVyZSBmbGFnLlxuICogQHBhcmFtIHBhc3NpdmUgVGhlIHBhc3NpdmUgZmxhZy5cbiAqIEBwYXJhbSBvbmNlIFRoZSBvbmNlIGZsYWcuXG4gKiBAcGFyYW0gc2lnbmFsIFRoZSBhYm9ydCBzaWduYWwuXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlLCBwYXNzaXZlLCBvbmNlLCBzaWduYWwpIHtcbiAgICBsZXQgc2lnbmFsTGlzdGVuZXI7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBzaWduYWxMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyLmJpbmQobnVsbCwgbGlzdCwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHNpZ25hbExpc3RlbmVyKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXIgPSBjcmVhdGVMaXN0ZW5lcihjYWxsYmFjaywgY2FwdHVyZSwgcGFzc2l2ZSwgb25jZSwgc2lnbmFsLCBzaWduYWxMaXN0ZW5lcik7XG4gICAgaWYgKGxpc3QuY293KSB7XG4gICAgICAgIGxpc3QuY293ID0gZmFsc2U7XG4gICAgICAgIGxpc3QubGlzdGVuZXJzID0gWy4uLmxpc3QubGlzdGVuZXJzLCBsaXN0ZW5lcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaXN0Lmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RlbmVyO1xufVxuLyoqXG4gKiBSZW1vdmUgYSBsaXN0ZW5lci5cbiAqIEBwYXJhbSBsaXN0IFRoZSBsaXN0ZW5lciBsaXN0LlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaW5kLlxuICogQHBhcmFtIGNhcHR1cmUgVGhlIGNhcHR1cmUgZmxhZyB0byBmaW5kLlxuICogQHJldHVybnMgYHRydWVgIGlmIGl0IG11dGF0ZWQgdGhlIGxpc3QgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG4gICAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhPZkxpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lckF0KGxpc3QsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZW1vdmUgYSBsaXN0ZW5lci5cbiAqIEBwYXJhbSBsaXN0IFRoZSBsaXN0ZW5lciBsaXN0LlxuICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0IGxpc3RlbmVyLlxuICogQHBhcmFtIGRpc2FibGVDb3cgRGlzYWJsZSBjb3B5LW9uLXdyaXRlIGlmIHRydWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgaXQgbXV0YXRlZCB0aGUgYGxpc3RlbmVyc2AgYXJyYXkgZGlyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyQXQobGlzdCwgaW5kZXgsIGRpc2FibGVDb3cgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbGlzdC5saXN0ZW5lcnNbaW5kZXhdO1xuICAgIC8vIFNldCB0aGUgcmVtb3ZlZCBmbGFnLlxuICAgIHNldFJlbW92ZWQobGlzdGVuZXIpO1xuICAgIC8vIERpc3Bvc2UgdGhlIGFib3J0IHNpZ25hbCBsaXN0ZW5lciBpZiBleGlzdHMuXG4gICAgaWYgKGxpc3RlbmVyLnNpZ25hbCkge1xuICAgICAgICBsaXN0ZW5lci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGxpc3RlbmVyLnNpZ25hbExpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5LlxuICAgIGlmIChsaXN0LmNvdyAmJiAhZGlzYWJsZUNvdykge1xuICAgICAgICBsaXN0LmNvdyA9IGZhbHNlO1xuICAgICAgICBsaXN0Lmxpc3RlbmVycyA9IGxpc3QubGlzdGVuZXJzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxpc3QubGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGBMaXN0ZW5lckxpc3RNYXBgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJMaXN0TWFwKCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGxpc3RlbmVyIGxpc3Qgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBJZiB0aGUgbGlzdGVuZXIgbGlzdCBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQsIGluaXRpYWxpemUgYW5kIHJldHVybiBpdC5cbiAqIEBwYXJhbSBsaXN0ZW5lck1hcCBUaGUgbGlzdGVuZXIgbGlzdCBtYXAuXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBnZXQuXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmVyTGlzdChsaXN0ZW5lck1hcCwgdHlwZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IGxpc3RlbmVyTWFwW3R5cGVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAobGlzdGVuZXJNYXBbdHlwZV0gPSB7XG4gICAgICAgIGF0dHJDYWxsYmFjazogdW5kZWZpbmVkLFxuICAgICAgICBhdHRyTGlzdGVuZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgY293OiBmYWxzZSxcbiAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICB9KSk7XG59XG5cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBFdmVudFRhcmdldGAgaW50ZXJmYWNlLlxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2V2ZW50dGFyZ2V0XG4gKi9cbmNsYXNzIEV2ZW50VGFyZ2V0IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGludGVybmFsRGF0YU1hcCQyLnNldCh0aGlzLCBjcmVhdGVMaXN0ZW5lckxpc3RNYXAoKSk7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGF0aW9uXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlMCwgY2FsbGJhY2swLCBvcHRpb25zMCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lck1hcCA9ICQkMih0aGlzKTtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgY2FwdHVyZSwgb25jZSwgcGFzc2l2ZSwgc2lnbmFsLCB0eXBlLCB9ID0gbm9ybWFsaXplQWRkT3B0aW9ucyh0eXBlMCwgY2FsbGJhY2swLCBvcHRpb25zMCk7XG4gICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsIHx8IChzaWduYWwgPT09IG51bGwgfHwgc2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWduYWwuYWJvcnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ID0gZW5zdXJlTGlzdGVuZXJMaXN0KGxpc3RlbmVyTWFwLCB0eXBlKTtcbiAgICAgICAgLy8gRmluZCBleGlzdGluZyBsaXN0ZW5lci5cbiAgICAgICAgY29uc3QgaSA9IGZpbmRJbmRleE9mTGlzdGVuZXIobGlzdCwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5EdXBsaWNhdGUobGlzdC5saXN0ZW5lcnNbaV0sIHBhc3NpdmUsIG9uY2UsIHNpZ25hbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgbGlzdGVuZXIuXG4gICAgICAgIGFkZExpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlLCBwYXNzaXZlLCBvbmNlLCBzaWduYWwpO1xuICAgIH1cbiAgICAvLyBJbXBsZW1lbnRhdGlvblxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZTAsIGNhbGxiYWNrMCwgb3B0aW9uczApIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJNYXAgPSAkJDIodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2ssIGNhcHR1cmUsIHR5cGUgfSA9IG5vcm1hbGl6ZU9wdGlvbnModHlwZTAsIGNhbGxiYWNrMCwgb3B0aW9uczApO1xuICAgICAgICBjb25zdCBsaXN0ID0gbGlzdGVuZXJNYXBbdHlwZV07XG4gICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIGxpc3QpIHtcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3QsIGNhbGxiYWNrLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbXBsZW1lbnRhdGlvblxuICAgIGRpc3BhdGNoRXZlbnQoZSkge1xuICAgICAgICBjb25zdCBsaXN0ID0gJCQyKHRoaXMpW1N0cmluZyhlLnR5cGUpXTtcbiAgICAgICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnQgPSBlIGluc3RhbmNlb2YgRXZlbnQgPyBlIDogRXZlbnRXcmFwcGVyLndyYXAoZSk7XG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9ICQoZXZlbnQsIFwiZXZlbnRcIik7XG4gICAgICAgIGlmIChldmVudERhdGEuZGlzcGF0Y2hGbGFnKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVJbnZhbGlkU3RhdGVFcnJvcihcIlRoaXMgZXZlbnQgaGFzIGJlZW4gaW4gZGlzcGF0Y2hpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50RGF0YS5kaXNwYXRjaEZsYWcgPSB0cnVlO1xuICAgICAgICBldmVudERhdGEudGFyZ2V0ID0gZXZlbnREYXRhLmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50RGF0YS5zdG9wUHJvcGFnYXRpb25GbGFnKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvdywgbGlzdGVuZXJzIH0gPSBsaXN0O1xuICAgICAgICAgICAgLy8gU2V0IGNvcHktb24td3JpdGUgZmxhZy5cbiAgICAgICAgICAgIGxpc3QuY293ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENhbGwgbGlzdGVuZXJzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGlmIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVtb3ZlZChsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGxpc3RlbmVyIGlmIGhhcyB0aGUgYG9uY2VgIGZsYWcuXG4gICAgICAgICAgICAgICAgaWYgKGlzT25jZShsaXN0ZW5lcikgJiYgcmVtb3ZlTGlzdGVuZXJBdChsaXN0LCBpLCAhY293KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoaXMgbGlzdGVuZXIgd2FzIHJlbW92ZWQsIHRoZSBuZXh0IGluZGV4IGlzIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENhbGwgdGhpcyBsaXN0ZW5lciB3aXRoIHRoZSBgcGFzc2l2ZWAgZmxhZy5cbiAgICAgICAgICAgICAgICBldmVudERhdGEuaW5QYXNzaXZlTGlzdGVuZXJGbGFnID0gaXNQYXNzaXZlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhsaXN0ZW5lciwgdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGV2ZW50RGF0YS5pblBhc3NpdmVMaXN0ZW5lckZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBTdG9wIGlmIHRoZSBgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClgIG1ldGhvZCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgICAgIGlmIChldmVudERhdGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXN0b3JlIGNvcHktb24td3JpdGUgZmxhZy5cbiAgICAgICAgICAgIGlmICghY293KSB7XG4gICAgICAgICAgICAgICAgbGlzdC5jb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmVudERhdGEudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgZXZlbnREYXRhLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICBldmVudERhdGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICBldmVudERhdGEuc3RvcFByb3BhZ2F0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICBldmVudERhdGEuZGlzcGF0Y2hGbGFnID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAhZXZlbnREYXRhLmNhbmNlbGVkRmxhZztcbiAgICB9XG59XG4vKipcbiAqIEludGVybmFsIGRhdGEuXG4gKi9cbmNvbnN0IGludGVybmFsRGF0YU1hcCQyID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogR2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGV2ZW50IHRhcmdldCBvYmplY3QgdG8gZ2V0IHByaXZhdGUgZGF0YS5cbiAqIEBwYXJhbSBuYW1lIFRoZSB2YXJpYWJsZSBuYW1lIHRvIHJlcG9ydC5cbiAqIEByZXR1cm5zIFRoZSBwcml2YXRlIGRhdGEgb2YgdGhlIGV2ZW50LlxuICovXG5mdW5jdGlvbiAkJDIodGFyZ2V0LCBuYW1lID0gXCJ0aGlzXCIpIHtcbiAgICBjb25zdCByZXR2ID0gaW50ZXJuYWxEYXRhTWFwJDIuZ2V0KHRhcmdldCk7XG4gICAgYXNzZXJ0VHlwZShyZXR2ICE9IG51bGwsIFwiJyVzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IEV2ZW50VGFyZ2V0IGNvbnN0cnVjdG9yIGNyZWF0ZWQsIGJ1dCBnb3QgYW5vdGhlciBvbmU6ICVvXCIsIG5hbWUsIHRhcmdldCk7XG4gICAgcmV0dXJuIHJldHY7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBZGRPcHRpb25zKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGFzc2VydENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrICE9PSBudWxsICYmIGNhbGxiYWNrICE9PSB2b2lkIDAgPyBjYWxsYmFjayA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9ucy5jYXB0dXJlKSxcbiAgICAgICAgICAgIHBhc3NpdmU6IEJvb2xlYW4ob3B0aW9ucy5wYXNzaXZlKSxcbiAgICAgICAgICAgIG9uY2U6IEJvb2xlYW4ob3B0aW9ucy5vbmNlKSxcbiAgICAgICAgICAgIHNpZ25hbDogKF9hID0gb3B0aW9ucy5zaWduYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogU3RyaW5nKHR5cGUpLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgIT09IG51bGwgJiYgY2FsbGJhY2sgIT09IHZvaWQgMCA/IGNhbGxiYWNrIDogdW5kZWZpbmVkLFxuICAgICAgICBjYXB0dXJlOiBCb29sZWFuKG9wdGlvbnMpLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgb25jZTogZmFsc2UsXG4gICAgICAgIHNpZ25hbDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKHR5cGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0Q2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcodHlwZSksXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgIT09IG51bGwgJiYgY2FsbGJhY2sgIT09IHZvaWQgMCA/IGNhbGxiYWNrIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FwdHVyZTogQm9vbGVhbihvcHRpb25zLmNhcHR1cmUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBTdHJpbmcodHlwZSksXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayAhPT0gbnVsbCAmJiBjYWxsYmFjayAhPT0gdm9pZCAwID8gY2FsbGJhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9ucyksXG4gICAgfTtcbn1cbi8qKlxuICogQXNzZXJ0IHRoZSB0eXBlIG9mICdjYWxsYmFjaycgYXJndW1lbnQuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBhc3NlcnRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICAodHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBjYWxsYmFjayAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhbGxiYWNrLmhhbmRsZUV2ZW50ID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrID09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIEludmFsaWRFdmVudExpc3RlbmVyLndhcm4oY2FsbGJhY2spO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoZm9ybWF0KEludmFsaWRFdmVudExpc3RlbmVyLm1lc3NhZ2UsIFtjYWxsYmFja10pKTtcbn1cbi8qKlxuICogUHJpbnQgd2FybmluZyBmb3IgZHVwbGljYXRlZC5cbiAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgY3VycmVudCBsaXN0ZW5lciB0aGF0IGlzIGR1cGxpY2F0ZWQuXG4gKiBAcGFyYW0gcGFzc2l2ZSBUaGUgcGFzc2l2ZSBmbGFnIG9mIHRoZSBuZXcgZHVwbGljYXRlZCBsaXN0ZW5lci5cbiAqIEBwYXJhbSBvbmNlIFRoZSBvbmNlIGZsYWcgb2YgdGhlIG5ldyBkdXBsaWNhdGVkIGxpc3RlbmVyLlxuICogQHBhcmFtIHNpZ25hbCBUaGUgc2lnbmFsIG9iamVjdCBvZiB0aGUgbmV3IGR1cGxpY2F0ZWQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIHdhcm5EdXBsaWNhdGUobGlzdGVuZXIsIHBhc3NpdmUsIG9uY2UsIHNpZ25hbCkge1xuICAgIEV2ZW50TGlzdGVuZXJXYXNEdXBsaWNhdGVkLndhcm4oaXNDYXB0dXJlKGxpc3RlbmVyKSA/IFwiY2FwdHVyZVwiIDogXCJidWJibGVcIiwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICAgIGlmIChpc1Bhc3NpdmUobGlzdGVuZXIpICE9PSBwYXNzaXZlKSB7XG4gICAgICAgIE9wdGlvbldhc0lnbm9yZWQud2FybihcInBhc3NpdmVcIik7XG4gICAgfVxuICAgIGlmIChpc09uY2UobGlzdGVuZXIpICE9PSBvbmNlKSB7XG4gICAgICAgIE9wdGlvbldhc0lnbm9yZWQud2FybihcIm9uY2VcIik7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lci5zaWduYWwgIT09IHNpZ25hbCkge1xuICAgICAgICBPcHRpb25XYXNJZ25vcmVkLndhcm4oXCJzaWduYWxcIik7XG4gICAgfVxufVxuLy8gU2V0IGVudW1lcmFibGVcbmNvbnN0IGtleXMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGtleXMkMS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChrZXlzJDFbaV0gPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50VGFyZ2V0LnByb3RvdHlwZSwga2V5cyQxW2ldLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59XG4vLyBFbnN1cmUgYGV2ZW50VGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkV2ZW50VGFyZ2V0YCBpcyBgdHJ1ZWAuXG5pZiAodHlwZW9mIEdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBHbG9iYWwuRXZlbnRUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXZlbnRUYXJnZXQucHJvdG90eXBlLCBHbG9iYWwuRXZlbnRUYXJnZXQucHJvdG90eXBlKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBnaXZlbiBldmVudCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRXZlbnRUYXJnZXRgIG9iamVjdCB0byBnZXQuXG4gKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZSh0YXJnZXQsIHR5cGUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxpc3RNYXAgPSAkJDIodGFyZ2V0LCBcInRhcmdldFwiKTtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gbGlzdE1hcFt0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJDYWxsYmFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbn1cbi8qKlxuICogU2V0IGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgZ2l2ZW4gZXZlbnQgYXR0cmlidXRlLlxuICogQHBhcmFtIHRhcmdldCBUaGUgYEV2ZW50VGFyZ2V0YCBvYmplY3QgdG8gc2V0LlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBzZXRFdmVudEF0dHJpYnV0ZVZhbHVlKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBJbnZhbGlkQXR0cmlidXRlSGFuZGxlci53YXJuKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICh0eXBlb2YgY2FsbGJhY2sgPT09IFwib2JqZWN0XCIgJiYgY2FsbGJhY2sgIT09IG51bGwpKSB7XG4gICAgICAgIHVwc2VydEV2ZW50QXR0cmlidXRlTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVFdmVudEF0dHJpYnV0ZUxpc3RlbmVyKHRhcmdldCwgdHlwZSk7XG4gICAgfVxufVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFVwZGF0ZSBvciBpbnNlcnQgdGhlIGdpdmVuIGV2ZW50IGF0dHJpYnV0ZSBoYW5kbGVyLlxuICogQHBhcmFtIHRhcmdldCBUaGUgYEV2ZW50VGFyZ2V0YCBvYmplY3QgdG8gc2V0LlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGV2ZW50IGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiB1cHNlcnRFdmVudEF0dHJpYnV0ZUxpc3RlbmVyKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBsaXN0ID0gZW5zdXJlTGlzdGVuZXJMaXN0KCQkMih0YXJnZXQsIFwidGFyZ2V0XCIpLCBTdHJpbmcodHlwZSkpO1xuICAgIGxpc3QuYXR0ckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgaWYgKGxpc3QuYXR0ckxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgbGlzdC5hdHRyTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcihsaXN0LCBkZWZpbmVFdmVudEF0dHJpYnV0ZUNhbGxiYWNrKGxpc3QpLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBldmVudCBhdHRyaWJ1dGUgaGFuZGxlci5cbiAqIEBwYXJhbSB0YXJnZXQgVGhlIGBFdmVudFRhcmdldGAgb2JqZWN0IHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIGNhbGxiYWNrIFRoZSBldmVudCBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRBdHRyaWJ1dGVMaXN0ZW5lcih0YXJnZXQsIHR5cGUpIHtcbiAgICBjb25zdCBsaXN0TWFwID0gJCQyKHRhcmdldCwgXCJ0YXJnZXRcIik7XG4gICAgY29uc3QgbGlzdCA9IGxpc3RNYXBbU3RyaW5nKHR5cGUpXTtcbiAgICBpZiAobGlzdCAmJiBsaXN0LmF0dHJMaXN0ZW5lcikge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0LCBsaXN0LmF0dHJMaXN0ZW5lci5jYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICBsaXN0LmF0dHJDYWxsYmFjayA9IGxpc3QuYXR0ckxpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogRGVmaW5lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIGxpc3RlbmVyIGxpc3Qgb2JqZWN0LlxuICogSXQgY2FsbHMgYGF0dHJDYWxsYmFja2AgcHJvcGVydHkgaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gbGlzdCBUaGUgYExpc3RlbmVyTGlzdGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVFdmVudEF0dHJpYnV0ZUNhbGxiYWNrKGxpc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gbGlzdC5hdHRyQ2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIERlZmluZSBhbiBgRXZlbnRUYXJnZXRgIGNsYXNzIHRoYXQgaGFzIGV2ZW50IGF0dGlidXRlcy5cbiAqIEBwYXJhbSB0eXBlcyBUaGUgdHlwZXMgdG8gZGVmaW5lIGV2ZW50IGF0dHJpYnV0ZXMuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGdldEV2ZW50QXR0cmlidXRlVmFsdWVgL2BzZXRFdmVudEF0dHJpYnV0ZVZhbHVlYCBwYWlyIG9uIHlvdXIgZGVyaXZlZCBjbGFzcyBpbnN0ZWFkIGJlY2F1c2Ugb2Ygc3RhdGljIGFuYWx5c2lzIGZyaWVuZGx5LlxuICovXG5mdW5jdGlvbiBkZWZpbmVDdXN0b21FdmVudFRhcmdldCguLi50eXBlcykge1xuICAgIGNsYXNzIEN1c3RvbUV2ZW50VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlZmluZUV2ZW50QXR0cmlidXRlKEN1c3RvbUV2ZW50VGFyZ2V0LnByb3RvdHlwZSwgdHlwZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gQ3VzdG9tRXZlbnRUYXJnZXQ7XG59XG4vKipcbiAqIERlZmluZSBhbiBldmVudCBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRXZlbnRUYXJnZXRgIG9iamVjdCB0byBkZWZpbmUgYW4gZXZlbnQgYXR0cmlidXRlLlxuICogQHBhcmFtIHR5cGUgVGhlIGV2ZW50IHR5cGUgdG8gZGVmaW5lLlxuICogQHBhcmFtIF9ldmVudENsYXNzIFVudXNlZCwgYnV0IHRvIGluZmVyIGBFdmVudGAgY2xhc3MgdHlwZS5cbiAqIEBkZXByZWNhdGVkIFVzZSBgZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZWAvYHNldEV2ZW50QXR0cmlidXRlVmFsdWVgIHBhaXIgb24geW91ciBkZXJpdmVkIGNsYXNzIGluc3RlYWQgYmVjYXVzZSBvZiBzdGF0aWMgYW5hbHlzaXMgZnJpZW5kbHkuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUV2ZW50QXR0cmlidXRlKHRhcmdldCwgdHlwZSwgX2V2ZW50Q2xhc3MpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBgb24ke3R5cGV9YCwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RXZlbnRBdHRyaWJ1dGVWYWx1ZSh0aGlzLCB0eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICBzZXRFdmVudEF0dHJpYnV0ZVZhbHVlKHRoaXMsIHR5cGUsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudFRhcmdldDtcbmV4cG9ydCB7IEV2ZW50LCBFdmVudFRhcmdldCwgZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXQsIGRlZmluZUV2ZW50QXR0cmlidXRlLCBnZXRFdmVudEF0dHJpYnV0ZVZhbHVlLCBzZXRFcnJvckhhbmRsZXIsIHNldEV2ZW50QXR0cmlidXRlVmFsdWUsIHNldFdhcm5pbmdIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=